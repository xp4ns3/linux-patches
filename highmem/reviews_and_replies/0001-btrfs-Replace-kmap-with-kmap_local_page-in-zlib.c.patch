From 5283e8f7a8b0988773cad6451eafa3c66c84c1d9 Mon Sep 17 00:00:00 2001
From: "Fabio M. De Francesco" <fmdefrancesco@gmail.com>
Date: Tue, 31 May 2022 16:53:35 +0200
Subject: [PATCH] btrfs: Replace kmap() with kmap_local_page() in zlib.c

The use of kmap() is being deprecated in favor of kmap_local_page(). With
kmap_local_page(), the mapping is per thread, CPU local and not globally
visible.

Therefore, use kmap_local_page() / kunmap_local() in zlib.c because in
this file the mappings are per thread and are not visible in other
contexts; meanwhile refactor zlib_compress_pages() to comply with nested
local mapping / unmapping ordering rules.

Tested with xfstests on QEMU + KVM 32 bits VM with 4GB of RAM and
HIGHMEM64G enabled.

Suggested-by: Ira Weiny <ira.weiny@intel.com>
Signed-off-by: Fabio M. De Francesco <fmdefrancesco@gmail.com>
---
 fs/btrfs/zlib.c | 68 ++++++++++++++++++++++++++++++++-----------------
 1 file changed, 45 insertions(+), 23 deletions(-)

diff --git a/fs/btrfs/zlib.c b/fs/btrfs/zlib.c
index 767a0c6c9694..85c45f380982 100644
--- a/fs/btrfs/zlib.c
+++ b/fs/btrfs/zlib.c
@@ -97,8 +97,8 @@ int zlib_compress_pages(struct list_head *ws, struct address_space *mapping,
 {
 	struct workspace *workspace = list_entry(ws, struct workspace, list);
 	int ret;
-	char *data_in;
-	char *cpage_out;
+	char *data_in = NULL;
+	char *cpage_out = NULL;
 	int nr_pages = 0;
 	struct page *in_page = NULL;
 	struct page *out_page = NULL;
@@ -126,7 +126,7 @@ int zlib_compress_pages(struct list_head *ws, struct address_space *mapping,
 		ret = -ENOMEM;
 		goto out;
 	}
-	cpage_out = kmap(out_page);
+	cpage_out = kmap_local_page(out_page);
 	pages[0] = out_page;
 	nr_pages = 1;
 
@@ -148,26 +148,26 @@ int zlib_compress_pages(struct list_head *ws, struct address_space *mapping,
 				int i;
 
 				for (i = 0; i < in_buf_pages; i++) {
-					if (in_page) {
-						kunmap(in_page);
+					if (data_in) {
+						kunmap_local(data_in);
 						put_page(in_page);
 					}
 					in_page = find_get_page(mapping,
 								start >> PAGE_SHIFT);
-					data_in = kmap(in_page);
+					data_in = kmap_local_page(in_page);
 					memcpy(workspace->buf + i * PAGE_SIZE,
 					       data_in, PAGE_SIZE);
 					start += PAGE_SIZE;

	[after looking below]

> > Ok after looking below it may be best to do the unmap here and set data_in =
> > NULL;  And only handle the remap if strm.next_in is using the mapped address.

> Not sure to understand this by only looking at this patch.
> I'll need to read again the entire function.

Unfortunately, I can't yet see why we need to move the un-mapping of data_in at
the end of the for loop. What are the reasons behind your argument?

 				}
 				workspace->strm.next_in = workspace->buf;
 			} else {
-				if (in_page) {
-					kunmap(in_page);
+				if (data_in) {
+					kunmap_local(data_in);
 					put_page(in_page);
 				}
 				in_page = find_get_page(mapping,
 							start >> PAGE_SHIFT);
-				data_in = kmap(in_page);
+				data_in = kmap_local_page(in_page);
 				start += PAGE_SIZE;
 				workspace->strm.next_in = data_in;
 			}
@@ -196,7 +196,10 @@ int zlib_compress_pages(struct list_head *ws, struct address_space *mapping,
 		 * the stream end if required
 		 */
 		if (workspace->strm.avail_out == 0) {
-			kunmap(out_page);
+			kunmap_local(data_in);
+			put_page(in_page);

> > We don't want to put the page here.

> > put_page() releases a reference on the page that find_get_page() took.  If you
> > release it the page in the page cache may be going away.

> I know this, page will be acquired again later

> > All we need to do is unmap/map the page.  Keep the reference for it.

+
+			kunmap_local(cpage_out);
 			if (nr_pages == nr_dest_pages) {
 				out_page = NULL;
 				ret = -E2BIG;
@@ -207,7 +210,15 @@ int zlib_compress_pages(struct list_head *ws, struct address_space *mapping,
 				ret = -ENOMEM;
 				goto out;
 			}
-			cpage_out = kmap(out_page);
+
+			cpage_out = kmap_local_page(out_page);
+
+			in_page = find_get_page(mapping, start >> PAGE_SHIFT);

> > Ah well...  Ok this may work.

> I think so.

No need to keep the reference to that page. Correct?

+			data_in = kmap_local_page(in_page);
+			workspace->strm.next_in = data_in;

> > Oh no it won't...  See how strm.next_in is sometimes set to workspace->buf vs
> > data_in above?  I did not catch this detail when I was looking before.

> I did not note it either.

> > This will have to be accounted for in the remap...

> Yes, absolutely.

No, I'm not any longer sure. Please read below...

> >	[See above...]

> > I think this is probalby working some of the time and not others.  This may be
> > why test 138 hangs.  Not sure.  You could put in some debug prints comparing
> > workspace->strm.next_in to workspace->buf...  Better to simply compare them
> > then put in a print if they don't seem correct.

> Let me think a bit more on this... 
> I'm not sure to understand where and how to compare these fields :-(

Why do you care of these two different assignments?

I mean that we are in two different (if ... else ...) blocks.
Not sure to understand this code correctly, but it looks like if in_buf_pages > 1, 
strm.next_in is assigned with workspace->buf (which is the start of an array that contains 
whatever memcpy() copies from data_in to (workspace->buf + i * PAGE_SIZE) at each iteration
of a for loop; otherwise, if in_buf_pages is not > 1, strm.next_in is directly assigned 
with data_in.

I can't see why we care of this detail. What am I missing?

+			workspace->strm.avail_in = min(bytes_left,
+						       (unsigned long)workspace->buf_size);
+
 			pages[nr_pages] = out_page;
 			nr_pages++;
 			workspace->strm.avail_out = PAGE_SIZE;
@@ -233,8 +244,11 @@ int zlib_compress_pages(struct list_head *ws, struct address_space *mapping,
 			ret = -EIO;
 			goto out;
 		} else if (workspace->strm.avail_out == 0) {
+			kunmap_local(data_in);
+			put_page(in_page);
+
 			/* get another page for the stream end */
-			kunmap(out_page);
+			kunmap_local(cpage_out);
 			if (nr_pages == nr_dest_pages) {
 				out_page = NULL;
 				ret = -E2BIG;
@@ -245,7 +259,14 @@ int zlib_compress_pages(struct list_head *ws, struct address_space *mapping,
 				ret = -ENOMEM;
 				goto out;
 			}
-			cpage_out = kmap(out_page);
+			cpage_out = kmap_local_page(out_page);
+
+			in_page = find_get_page(mapping, start >> PAGE_SHIFT);
+			data_in = kmap_local_page(in_page);
+			workspace->strm.next_in = data_in;
+			workspace->strm.avail_in = min(bytes_left,
+						       (unsigned long)workspace->buf_size);

> > I think there is the potential for the same issue here.

> > :-(

> Yes it seems the very same situation.

However, as I have just said above, I'm not yet able to understand why we should care.
A similar question again... why this should break our changes? I suppose that if this design 
works properly with kmap(), it should also work properly with kmap_local_page().

Obviously, maybe that I'm still missing why and where this design is un-suited with straightforward
conversions to kmap_local_page().

> This code is a bit too complex for my current knowledge and skills :-(
> I'm not worried of complex things just because they are complex...
> I'm only worried about the time it takes to figure out how to address these kinds of issues. 

Today this code is a bit less complex than what it was when I wrote about it last time, anyway
I'm pretty sure that I'm still unable to see lots of things.

While waiting for your reply, I'm still working to make my changes pass (x)fstests.

Not yet sure whether or not I'd better send an RFC PATCH.
I've learned that this strategy pays (obvioulsy I'm talking about what happened with the conversion 
of zstd.c).

Thanks,

Fabio

+
 			pages[nr_pages] = out_page;
 			nr_pages++;
 			workspace->strm.avail_out = PAGE_SIZE;
@@ -264,13 +285,13 @@ int zlib_compress_pages(struct list_head *ws, struct address_space *mapping,
 	*total_in = workspace->strm.total_in;
 out:
 	*out_pages = nr_pages;
-	if (out_page)
-		kunmap(out_page);
-
-	if (in_page) {
-		kunmap(in_page);
+	if (data_in) {
+		kunmap_local(data_in);
 		put_page(in_page);
 	}
+	if (cpage_out)
+		kunmap_local(cpage_out);
+
 	return ret;
 }
 
@@ -287,7 +308,7 @@ int zlib_decompress_bio(struct list_head *ws, struct compressed_bio *cb)
 	unsigned long buf_start;
 	struct page **pages_in = cb->compressed_pages;
 
-	data_in = kmap(pages_in[page_in_index]);
+	data_in = kmap_local_page(pages_in[page_in_index]);
 	workspace->strm.next_in = data_in;
 	workspace->strm.avail_in = min_t(size_t, srclen, PAGE_SIZE);
 	workspace->strm.total_in = 0;
@@ -309,7 +330,7 @@ int zlib_decompress_bio(struct list_head *ws, struct compressed_bio *cb)
 
 	if (Z_OK != zlib_inflateInit2(&workspace->strm, wbits)) {
 		pr_warn("BTRFS: inflateInit failed\n");
-		kunmap(pages_in[page_in_index]);
+		kunmap_local(data_in);
 		return -EIO;
 	}
 	while (workspace->strm.total_in < srclen) {
@@ -336,13 +357,14 @@ int zlib_decompress_bio(struct list_head *ws, struct compressed_bio *cb)
 
 		if (workspace->strm.avail_in == 0) {
 			unsigned long tmp;
-			kunmap(pages_in[page_in_index]);
+
+			kunmap_local(data_in);
 			page_in_index++;
 			if (page_in_index >= total_pages_in) {
 				data_in = NULL;
 				break;
 			}
-			data_in = kmap(pages_in[page_in_index]);
+			data_in = kmap_local_page(pages_in[page_in_index]);
 			workspace->strm.next_in = data_in;
 			tmp = srclen - workspace->strm.total_in;
 			workspace->strm.avail_in = min(tmp, PAGE_SIZE);
@@ -355,7 +377,7 @@ int zlib_decompress_bio(struct list_head *ws, struct compressed_bio *cb)
 done:
 	zlib_inflateEnd(&workspace->strm);
 	if (data_in)
-		kunmap(pages_in[page_in_index]);
+		kunmap_local(data_in);
 	if (!ret)
 		zero_fill_bio(cb->orig_bio);
 	return ret;
-- 
2.36.1

