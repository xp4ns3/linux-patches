

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>High Memory Handling &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Linux Memory Management Documentation" href="index.html"/>
        <link rel="next" title="Heterogeneous Memory Management (HMM)" href="hmm.html"/>
        <link rel="prev" title="Frontswap" href="frontswap.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Memory Management Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="active_mm.html">Active MM</a></li>
<li class="toctree-l2"><a class="reference internal" href="arch_pgtable_helpers.html">Architecture Page Table Helpers</a></li>
<li class="toctree-l2"><a class="reference internal" href="arch_pgtable_helpers.html#pte-page-table-helpers">PTE Page Table Helpers</a></li>
<li class="toctree-l2"><a class="reference internal" href="arch_pgtable_helpers.html#pmd-page-table-helpers">PMD Page Table Helpers</a></li>
<li class="toctree-l2"><a class="reference internal" href="arch_pgtable_helpers.html#pud-page-table-helpers">PUD Page Table Helpers</a></li>
<li class="toctree-l2"><a class="reference internal" href="arch_pgtable_helpers.html#hugetlb-page-table-helpers">HugeTLB Page Table Helpers</a></li>
<li class="toctree-l2"><a class="reference internal" href="arch_pgtable_helpers.html#swap-page-table-helpers">SWAP Page Table Helpers</a></li>
<li class="toctree-l2"><a class="reference internal" href="balance.html">Memory Balancing</a></li>
<li class="toctree-l2"><a class="reference internal" href="damon/index.html">DAMON: Data Access MONitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="free_page_reporting.html">Free Page Reporting</a></li>
<li class="toctree-l2"><a class="reference internal" href="frontswap.html">Frontswap</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">High Memory Handling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-high-memory">What Is High Memory?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#temporary-virtual-mappings">Temporary Virtual Mappings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cost-of-temporary-mappings">Cost of Temporary Mappings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i386-pae">i386 PAE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="hmm.html">Heterogeneous Memory Management (HMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="hwpoison.html">hwpoison</a></li>
<li class="toctree-l2"><a class="reference internal" href="hugetlbfs_reserv.html">Hugetlbfs Reservation</a></li>
<li class="toctree-l2"><a class="reference internal" href="ksm.html">Kernel Samepage Merging</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory-model.html">Physical Memory Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmu_notifier.html">When do you need to notify inside page table lock ?</a></li>
<li class="toctree-l2"><a class="reference internal" href="numa.html">What is NUMA?</a></li>
<li class="toctree-l2"><a class="reference internal" href="overcommit-accounting.html">Overcommit Accounting</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_migration.html">Page migration</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_frags.html">Page fragments</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_owner.html">page owner: Tracking about who allocated each page</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_table_check.html">Page Table Check</a></li>
<li class="toctree-l2"><a class="reference internal" href="remap_file_pages.html">remap_file_pages() system call</a></li>
<li class="toctree-l2"><a class="reference internal" href="slub.html">Short users guide for SLUB</a></li>
<li class="toctree-l2"><a class="reference internal" href="split_page_table_lock.html">Split page table lock</a></li>
<li class="toctree-l2"><a class="reference internal" href="transhuge.html">Transparent Hugepage Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="unevictable-lru.html">Unevictable LRU Infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="vmalloced-kernel-stacks.html">Virtually Mapped Kernel Stack Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="z3fold.html">z3fold</a></li>
<li class="toctree-l2"><a class="reference internal" href="zsmalloc.html">zsmalloc</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Memory Management Documentation</a> &raquo;</li>
        
      <li>High Memory Handling</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/vm/highmem.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="high-memory-handling">
<span id="highmem"></span><h1>High Memory Handling<a class="headerlink" href="#high-memory-handling" title="Permalink to this headline">¶</a></h1>
<p>By: Peter Zijlstra &lt;<a class="reference external" href="mailto:a&#46;p&#46;zijlstra&#37;&#52;&#48;chello&#46;nl">a<span>&#46;</span>p<span>&#46;</span>zijlstra<span>&#64;</span>chello<span>&#46;</span>nl</a>&gt;</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#what-is-high-memory" id="id1">What Is High Memory?</a></li>
<li><a class="reference internal" href="#temporary-virtual-mappings" id="id2">Temporary Virtual Mappings</a></li>
<li><a class="reference internal" href="#cost-of-temporary-mappings" id="id3">Cost of Temporary Mappings</a></li>
<li><a class="reference internal" href="#i386-pae" id="id4">i386 PAE</a></li>
<li><a class="reference internal" href="#functions" id="id5">Functions</a></li>
</ul>
</div>
<div class="section" id="what-is-high-memory">
<h2><a class="toc-backref" href="#id1">What Is High Memory?</a><a class="headerlink" href="#what-is-high-memory" title="Permalink to this headline">¶</a></h2>
<p>High memory (highmem) is used when the size of physical memory approaches or
exceeds the maximum size of virtual memory.  At that point it becomes
impossible for the kernel to keep all of the available physical memory mapped
at all times.  This means the kernel needs to start using temporary mappings of
the pieces of physical memory that it wants to access.</p>
<p>The part of (physical) memory not covered by a permanent mapping is what we
refer to as ‘highmem’.  There are various architecture dependent constraints on
where exactly that border lies.</p>
<p>In the i386 arch, for example, we choose to map the kernel into every process’s
VM space so that we don’t have to pay the full TLB invalidation costs for
kernel entry/exit.  This means the available virtual memory space (4GiB on
i386) has to be divided between user and kernel space.</p>
<p>The traditional split for architectures using this approach is 3:1, 3GiB for
userspace and the top 1GiB for kernel space:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+--------+ 0xffffffff
| Kernel |
+--------+ 0xc0000000
|        |
| User   |
|        |
+--------+ 0x00000000
</pre></div>
</div>
<p>This means that the kernel can at most map 1GiB of physical memory at any one
time, but because we need virtual address space for other things - including
temporary maps to access the rest of the physical memory - the actual direct
map will typically be less (usually around ~896MiB).</p>
<p>Other architectures that have mm context tagged TLBs can have separate kernel
and user maps.  Some hardware (like some ARMs), however, have limited virtual
space when they use mm context tags.</p>
</div>
<div class="section" id="temporary-virtual-mappings">
<h2><a class="toc-backref" href="#id2">Temporary Virtual Mappings</a><a class="headerlink" href="#temporary-virtual-mappings" title="Permalink to this headline">¶</a></h2>
<p>The kernel contains several ways of creating temporary mappings:</p>
<ul>
<li><p class="first">kmap_local_*().  These provide a set of functions that are used to require
short term mappings. They can be invoked from any context (including
interrupts) but the mappings can only be used in the context which acquired
it.</p>
<p>These mappings are per thread, CPU local (i.e., migration from one CPU to
another is disabled - this is why they are called “local”), but they don’t
disable preemption. It’s valid to take pagefaults in a local kmap region,
unless the context in which the local mapping is acquired does not allow
it for other reasons.</p>
<p>If a task holding local kmaps is preempted, the maps are removed on context
switch and restored when the task comes back on the CPU. As the maps are
strictly CPU local, it is guaranteed that the task stays on the CPU and
that the CPU cannot be unplugged until the local kmaps are released.</p>
<p>Nesting kmap_local.*() and kmap_atomic.*() mappings is allowed to a certain
extent (up to KMAP_TYPE_NR). Nested kmap_local.*() and kunmap_local.*()
invocations have to be strictly ordered because the map implementation is
stack based.</p>
</li>
<li><p class="first"><a class="reference internal" href="#c.kmap_atomic" title="kmap_atomic"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap_atomic()</span></code></a>.  This permits a very short duration mapping of a single
page.  Since the mapping is restricted to the CPU that issued it, it
performs well, but the issuing task is therefore required to stay on that
CPU until it has finished, lest some other task displace its mappings.</p>
<p><a class="reference internal" href="#c.kmap_atomic" title="kmap_atomic"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap_atomic()</span></code></a> may also be used by interrupt contexts, since it does not
sleep and the caller too can not sleep until after kunmap_atomic() is called.
Each call of <a class="reference internal" href="#c.kmap_atomic" title="kmap_atomic"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap_atomic()</span></code></a> in the kernel creates a non-preemptible section and
disable pagefaults.</p>
<p>This could be a source of unwanted latency, so it should be only used if it is
absolutely required, otherwise the corresponding kmap_local_*() variant should
be used if it is feasible.</p>
<p>On 64-bit systems, calls to <a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a> and <a class="reference internal" href="#c.kmap_atomic" title="kmap_atomic"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap_atomic()</span></code></a> have no real work to do
because a 64-bit address space is more than sufficient to address all the
physical memory, so all of physical memory appears in the direct mapping.</p>
<p>It is assumed that k[un]map_atomic() won’t fail.</p>
</li>
<li><p class="first"><a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a>.  This should be used to make short duration mapping of a single
page with no restrictions on preemption or migration. It comes with an
overhead as mapping space is restricted and protected by a global lock
for synchronization. When mapping is no more needed, the address that
the page was mapped to must be released with <a class="reference internal" href="#c.kunmap" title="kunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kunmap()</span></code></a>.</p>
<p>Mapping changes must be propagated across all the CPUs. <a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a> also
requires global TLB invalidation when the kmap’s pool wraps and it might
block when the mapping space is fully utilized until a slot becomes
available. Therefore, <a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a> is only callable from preemptible context.</p>
<p>All the above work is necessary if a mapping must last for a relatively
long time but the bulk of high-memory mappings in the kernel are
short-lived and only used in one place. This means that the cost of
<a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a> is mostly wasted in such cases. <a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a> was not intended for long
term mappings but it has morphed in that direction and its use is
strongly discouraged in newer code and the set of the preceding functions
should be preferred.</p>
</li>
<li><p class="first"><a class="reference internal" href="../core-api/mm-api.html#c.vmap" title="vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmap()</span></code></a>.  This can be used to make a long duration mapping of multiple
physical pages into a contiguous virtual space.  It needs global
synchronization to unmap.</p>
</li>
</ul>
</div>
<div class="section" id="cost-of-temporary-mappings">
<h2><a class="toc-backref" href="#id3">Cost of Temporary Mappings</a><a class="headerlink" href="#cost-of-temporary-mappings" title="Permalink to this headline">¶</a></h2>
<p>The cost of creating temporary mappings can be quite high.  The arch has to
manipulate the kernel’s page tables, the data TLB and/or the MMU’s registers.</p>
<p>If CONFIG_HIGHMEM is not set, then the kernel will try and create a mapping
simply with a bit of arithmetic that will convert the page struct address into
a pointer to the page contents rather than juggling mappings about.  In such a
case, the unmap operation may be a null operation.</p>
<p>If CONFIG_MMU is not set, then there can be no temporary mappings and no
highmem.  In such a case, the arithmetic approach will also be used.</p>
</div>
<div class="section" id="i386-pae">
<h2><a class="toc-backref" href="#id4">i386 PAE</a><a class="headerlink" href="#i386-pae" title="Permalink to this headline">¶</a></h2>
<p>The i386 arch, under some circumstances, will permit you to stick up to 64GiB
of RAM into your 32-bit machine.  This has a number of consequences:</p>
<ul class="simple">
<li>Linux needs a page-frame structure for each page in the system and the
pageframes need to live in the permanent mapping, which means:</li>
<li>you can have 896M/sizeof(struct page) page-frames at most; with struct
page being 32-bytes that would end up being something in the order of 112G
worth of pages; the kernel, however, needs to store more than just
page-frames in that memory…</li>
<li>PAE makes your page tables larger - which slows the system down as more
data has to be accessed to traverse in TLB fills and the like.  One
advantage is that PAE has more PTE bits and can provide advanced features
like NX and PAT.</li>
</ul>
<p>The general recommendation is that you don’t use more than 8GiB on a 32-bit
machine - although more might work for you and your workload, you’re pretty
much on your own - don’t expect kernel developers to really care much if things
come apart.</p>
</div>
<div class="section" id="functions">
<h2><a class="toc-backref" href="#id5">Functions</a><a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.kmap">
void * <code class="descname">kmap</code><span class="sig-paren">(</span>struct page<em>&nbsp;*page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a page for long term usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt>
<dd>Pointer to the page to be mapped</dd>
</dl>
<p><strong>Return</strong></p>
<p>The virtual address of the mapping</p>
<p><strong>Description</strong></p>
<p>Can only be invoked from preemptible task context because on 32bit
systems with CONFIG_HIGHMEM enabled this function might sleep.</p>
<p>For systems with CONFIG_HIGHMEM=n and for pages in the low memory area
this returns the virtual address of the direct kernel mapping.</p>
<p>The returned virtual address is globally visible and valid up to the
point where it is unmapped via <a class="reference internal" href="#c.kunmap" title="kunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kunmap()</span></code></a>. The pointer can be handed to
other contexts.</p>
<p>For highmem pages on 32bit systems this can be slow as the mapping space
is limited and protected by a global lock. In case that there is no
mapping slot available the function blocks until a slot is released via
<a class="reference internal" href="#c.kunmap" title="kunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kunmap()</span></code></a>.</p>
<dl class="function">
<dt id="c.kunmap">
void <code class="descname">kunmap</code><span class="sig-paren">(</span>struct page<em>&nbsp;*page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap the virtual address mapped by <a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt>
<dd>Virtual address to be unmapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>Counterpart to <a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a>. A NOOP for CONFIG_HIGHMEM=n and for mappings of
pages in the low memory area.</p>
<dl class="function">
<dt id="c.kmap_to_page">
struct page * <code class="descname">kmap_to_page</code><span class="sig-paren">(</span>void<em>&nbsp;*addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmap_to_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the page for a kmap’ed address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt>
<dd>The address to look up</dd>
</dl>
<p><strong>Return</strong></p>
<p>The page which is mapped to <strong>addr</strong>.</p>
<dl class="function">
<dt id="c.kmap_flush_unused">
void <code class="descname">kmap_flush_unused</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.kmap_flush_unused" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush all unused kmap mappings in order to remove stray mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.kmap_local_page">
void * <code class="descname">kmap_local_page</code><span class="sig-paren">(</span>struct page<em>&nbsp;*page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmap_local_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a page for temporary usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt>
<dd>Pointer to the page to be mapped</dd>
</dl>
<p><strong>Return</strong></p>
<p>The virtual address of the mapping</p>
<p><strong>Description</strong></p>
<p>Can be invoked from any context.</p>
<p>Requires careful handling when nesting multiple mappings because the map
management is stack based. The unmap has to be in the reverse order of
the map operation:</p>
<p>addr1 = kmap_local_page(page1);
addr2 = kmap_local_page(page2);
…
kunmap_local(addr2);
kunmap_local(addr1);</p>
<p>Unmapping addr1 before addr2 is invalid and causes malfunction.</p>
<p>Contrary to <a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a> mappings the mapping is only valid in the context of
the caller and cannot be handed to other contexts.</p>
<p>On CONFIG_HIGHMEM=n kernels and for low memory pages this returns the
virtual address of the direct mapping. Only real highmem pages are
temporarily mapped.</p>
<p>While it is significantly faster than <a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a> for the higmem case it
comes with restrictions about the pointer validity. Only use when really
necessary.</p>
<p>On HIGHMEM enabled systems mapping a highmem page has the side effect of
disabling migration in order to keep the virtual address stable across
preemption. No caller of <a class="reference internal" href="#c.kmap_local_page" title="kmap_local_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap_local_page()</span></code></a> can rely on this side effect.</p>
<dl class="function">
<dt id="c.kmap_local_folio">
void * <code class="descname">kmap_local_folio</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em>&nbsp;*folio</em>, size_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmap_local_folio" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a page in this folio for temporary usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt>
<dd>The folio containing the page.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">offset</span></code></dt>
<dd>The byte offset within the folio which identifies the page.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Requires careful handling when nesting multiple mappings because the map
management is stack based. The unmap has to be in the reverse order of
the map operation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>addr1 = kmap_local_folio(folio1, offset1);
addr2 = kmap_local_folio(folio2, offset2);
...
kunmap_local(addr2);
kunmap_local(addr1);
</pre></div>
</div>
<p>Unmapping addr1 before addr2 is invalid and causes malfunction.</p>
<p>Contrary to <a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a> mappings the mapping is only valid in the context of
the caller and cannot be handed to other contexts.</p>
<p>On CONFIG_HIGHMEM=n kernels and for low memory pages this returns the
virtual address of the direct mapping. Only real highmem pages are
temporarily mapped.</p>
<p>While it is significantly faster than <a class="reference internal" href="#c.kmap" title="kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap()</span></code></a> for the higmem case it
comes with restrictions about the pointer validity. Only use when really
necessary.</p>
<p>On HIGHMEM enabled systems mapping a highmem page has the side effect of
disabling migration in order to keep the virtual address stable across
preemption. No caller of <a class="reference internal" href="#c.kmap_local_folio" title="kmap_local_folio"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap_local_folio()</span></code></a> can rely on this side effect.</p>
<p><strong>Context</strong></p>
<p>Can be invoked from any context.</p>
<p><strong>Return</strong></p>
<p>The virtual address of <strong>offset</strong>.</p>
<dl class="function">
<dt id="c.kmap_atomic">
void * <code class="descname">kmap_atomic</code><span class="sig-paren">(</span>struct page<em>&nbsp;*page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmap_atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomically map a page for temporary usage - Deprecated!</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt>
<dd>Pointer to the page to be mapped</dd>
</dl>
<p><strong>Return</strong></p>
<p>The virtual address of the mapping</p>
<p><strong>Description</strong></p>
<p>Effectively a wrapper around <a class="reference internal" href="#c.kmap_local_page" title="kmap_local_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap_local_page()</span></code></a> which disables pagefaults
and preemption.</p>
<p>Do not use in new code. Use <a class="reference internal" href="#c.kmap_local_page" title="kmap_local_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmap_local_page()</span></code></a> instead.</p>
<dl class="function">
<dt id="c.alloc_zeroed_user_highpage_movable">
struct page * <code class="descname">alloc_zeroed_user_highpage_movable</code><span class="sig-paren">(</span>struct vm_area_struct<em>&nbsp;*vma</em>, unsigned long<em>&nbsp;vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_zeroed_user_highpage_movable" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a zeroed HIGHMEM page for a VMA that the caller knows can move</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt>
<dd>The VMA the page is to be allocated for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">vaddr</span></code></dt>
<dd>The virtual address the page will be inserted into</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will allocate a page for a VMA that the caller knows will
be able to migrate in the future using move_pages() or reclaimed</p>
<p>An architecture may override this function by defining
__HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE_MOVABLE and providing their own
implementation.</p>
<dl class="function">
<dt id="c.folio_zero_segments">
void <code class="descname">folio_zero_segments</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em>&nbsp;*folio</em>, size_t<em>&nbsp;start1</em>, size_t<em>&nbsp;xend1</em>, size_t<em>&nbsp;start2</em>, size_t<em>&nbsp;xend2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_zero_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero two byte ranges in a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt>
<dd>The folio to write to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">start1</span></code></dt>
<dd>The first byte to zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">xend1</span></code></dt>
<dd>One more than the last byte in the first range.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">start2</span></code></dt>
<dd>The first byte to zero in the second range.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">xend2</span></code></dt>
<dd>One more than the last byte in the second range.</dd>
</dl>
<dl class="function">
<dt id="c.folio_zero_segment">
void <code class="descname">folio_zero_segment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em>&nbsp;*folio</em>, size_t<em>&nbsp;start</em>, size_t<em>&nbsp;xend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_zero_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero a byte range in a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt>
<dd>The folio to write to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">start</span></code></dt>
<dd>The first byte to zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">xend</span></code></dt>
<dd>One more than the last byte to zero.</dd>
</dl>
<dl class="function">
<dt id="c.folio_zero_range">
void <code class="descname">folio_zero_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em>&nbsp;*folio</em>, size_t<em>&nbsp;start</em>, size_t<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_zero_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero a byte range in a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt>
<dd>The folio to write to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">start</span></code></dt>
<dd>The first byte to zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt>
<dd>The number of bytes to zero.</dd>
</dl>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="hmm.html" class="btn btn-neutral float-right" title="Heterogeneous Memory Management (HMM)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="frontswap.html" class="btn btn-neutral" title="Frontswap" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>