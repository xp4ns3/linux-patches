

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>29. Software Guard eXtensions (SGX) &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="x86-specific Documentation" href="index.html"/>
        <link rel="next" title="30. Feature status on x86 architecture" href="features.html"/>
        <link rel="prev" title="28. Shared Virtual Addressing (SVA) with ENQCMD" href="sva.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../arch.html">CPU Architectures</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../arc/index.html">ARC architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arm/index.html">ARM Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arm64/index.html">ARM64 Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ia64/index.html">IA-64 Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../m68k/index.html">m68k Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../openrisc/index.html">OpenRISC Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parisc/index.html">PA-RISC Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../powerpc/index.html">powerpc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../riscv/index.html">RISC-V architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390/index.html">s390 Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sparc/index.html">Sparc Architecture</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">x86-specific Documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="boot.html">1. The Linux/x86 Boot Protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="booting-dt.html">2. DeviceTree Booting</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpuinfo.html">3. x86 Feature Flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="topology.html">4. x86 Topology</a></li>
<li class="toctree-l3"><a class="reference internal" href="exception-tables.html">5. Kernel level exception handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="kernel-stacks.html">6. Kernel Stacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="entry_64.html">7. Kernel Entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="earlyprintk.html">8. Early Printk</a></li>
<li class="toctree-l3"><a class="reference internal" href="orc-unwinder.html">9. ORC unwinder</a></li>
<li class="toctree-l3"><a class="reference internal" href="zero-page.html">10. Zero Page</a></li>
<li class="toctree-l3"><a class="reference internal" href="tlb.html">11. The TLB</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtrr.html">12. MTRR (Memory Type Range Register) control</a></li>
<li class="toctree-l3"><a class="reference internal" href="pat.html">13. PAT (Page Attribute Table)</a></li>
<li class="toctree-l3"><a class="reference internal" href="intel-hfi.html">14. Hardware-Feedback Interface for scheduling on Intel Hardware</a></li>
<li class="toctree-l3"><a class="reference internal" href="intel-iommu.html">15. Linux IOMMU Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="intel_txt.html">16. Intel(R) TXT Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="amd-memory-encryption.html">17. AMD Memory Encryption</a></li>
<li class="toctree-l3"><a class="reference internal" href="amd_hsmp.html">18. AMD HSMP interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="pti.html">19. Page Table Isolation (PTI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mds.html">20. Microarchitectural Data Sampling (MDS) mitigation</a></li>
<li class="toctree-l3"><a class="reference internal" href="microcode.html">21. The Linux Microcode Loader</a></li>
<li class="toctree-l3"><a class="reference internal" href="resctrl.html">22. User Interface for Resource Control feature</a></li>
<li class="toctree-l3"><a class="reference internal" href="tsx_async_abort.html">23. TSX Async Abort (TAA) mitigation</a></li>
<li class="toctree-l3"><a class="reference internal" href="buslock.html">24. Bus lock detection and handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="usb-legacy-support.html">25. USB Legacy support</a></li>
<li class="toctree-l3"><a class="reference internal" href="i386/index.html">26. i386 Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="x86_64/index.html">27. x86_64 Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="sva.html">28. Shared Virtual Addressing (SVA) with ENQCMD</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">29. Software Guard eXtensions (SGX)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">29.1. Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enclave-page-cache">29.2. Enclave Page Cache</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-interface">29.3. Application interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ksgxd">29.4. ksgxd</a></li>
<li class="toctree-l4"><a class="reference internal" href="#launch-control">29.5. Launch Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encryption-engines">29.6. Encryption engines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usage-models">29.7. Usage Models</a></li>
<li class="toctree-l4"><a class="reference internal" href="#impact-of-potential-kernel-sgx-bugs">29.8. Impact of Potential Kernel SGX Bugs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#virtual-epc">29.9. Virtual EPC</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="features.html">30. Feature status on x86 architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="elf_auxvec.html">31. x86-specific ELF Auxiliary Vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="xstate.html">32. Using XSTATE features in user space applications</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../xtensa/index.html">Xtensa Architecture</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../arch.html">CPU Architectures</a> &raquo;</li>
        
          <li><a href="index.html">x86-specific Documentation</a> &raquo;</li>
        
      <li>29. Software Guard eXtensions (SGX)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/x86/sgx.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="software-guard-extensions-sgx">
<h1>29. Software Guard eXtensions (SGX)<a class="headerlink" href="#software-guard-extensions-sgx" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>29.1. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Software Guard eXtensions (SGX) hardware enables for user space applications
to set aside private memory regions of code and data:</p>
<ul class="simple">
<li>Privileged (ring-0) ENCLS functions orchestrate the construction of the
regions.</li>
<li>Unprivileged (ring-3) ENCLU functions allow an application to enter and
execute inside the regions.</li>
</ul>
<p>These memory regions are called enclaves. An enclave can be only entered at a
fixed set of entry points. Each entry point can hold a single hardware thread
at a time.  While the enclave is loaded from a regular binary file by using
ENCLS functions, only the threads inside the enclave can access its memory. The
region is denied from outside access by the CPU, and encrypted before it leaves
from LLC.</p>
<p>The support can be determined by</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">sgx</span> <span class="pre">/proc/cpuinfo</span></code></div></blockquote>
<p>SGX must both be supported in the processor and enabled by the BIOS.  If SGX
appears to be unsupported on a system which has hardware support, ensure
support is enabled in the BIOS.  If a BIOS presents a choice between “Enabled”
and “Software Enabled” modes for SGX, choose “Enabled”.</p>
</div>
<div class="section" id="enclave-page-cache">
<h2>29.2. Enclave Page Cache<a class="headerlink" href="#enclave-page-cache" title="Permalink to this headline">¶</a></h2>
<p>SGX utilizes an <em>Enclave Page Cache (EPC)</em> to store pages that are associated
with an enclave. It is contained in a BIOS-reserved region of physical memory.
Unlike pages used for regular memory, pages can only be accessed from outside of
the enclave during enclave construction with special, limited SGX instructions.</p>
<p>Only a CPU executing inside an enclave can directly access enclave memory.
However, a CPU executing inside an enclave may access normal memory outside the
enclave.</p>
<p>The kernel manages enclave memory similar to how it treats device memory.</p>
<div class="section" id="enclave-page-types">
<h3>29.2.1. Enclave Page Types<a class="headerlink" href="#enclave-page-types" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><strong>SGX Enclave Control Structure (SECS)</strong></dt>
<dd>Enclave’s address range, attributes and other global data are defined
by this structure.</dd>
<dt><strong>Regular (REG)</strong></dt>
<dd>Regular EPC pages contain the code and data of an enclave.</dd>
<dt><strong>Thread Control Structure (TCS)</strong></dt>
<dd>Thread Control Structure pages define the entry points to an enclave and
track the execution state of an enclave thread.</dd>
<dt><strong>Version Array (VA)</strong></dt>
<dd>Version Array pages contain 512 slots, each of which can contain a version
number for a page evicted from the EPC.</dd>
</dl>
</div>
<div class="section" id="enclave-page-cache-map">
<h3>29.2.2. Enclave Page Cache Map<a class="headerlink" href="#enclave-page-cache-map" title="Permalink to this headline">¶</a></h3>
<p>The processor tracks EPC pages in a hardware metadata structure called the
<em>Enclave Page Cache Map (EPCM)</em>.  The EPCM contains an entry for each EPC page
which describes the owning enclave, access rights and page type among the other
things.</p>
<p>EPCM permissions are separate from the normal page tables.  This prevents the
kernel from, for instance, allowing writes to data which an enclave wishes to
remain read-only.  EPCM permissions may only impose additional restrictions on
top of normal x86 page permissions.</p>
<p>For all intents and purposes, the SGX architecture allows the processor to
invalidate all EPCM entries at will.  This requires that software be prepared to
handle an EPCM fault at any time.  In practice, this can happen on events like
power transitions when the ephemeral key that encrypts enclave memory is lost.</p>
</div>
</div>
<div class="section" id="application-interface">
<h2>29.3. Application interface<a class="headerlink" href="#application-interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="enclave-build-functions">
<h3>29.3.1. Enclave build functions<a class="headerlink" href="#enclave-build-functions" title="Permalink to this headline">¶</a></h3>
<p>In addition to the traditional compiler and linker build process, SGX has a
separate enclave “build” process.  Enclaves must be built before they can be
executed (entered). The first step in building an enclave is opening the
<strong>/dev/sgx_enclave</strong> device.  Since enclave memory is protected from direct
access, special privileged instructions are then used to copy data into enclave
pages and establish enclave page permissions.</p>
<dl class="function">
<dt id="c.sgx_ioc_enclave_create">
long <code class="descname">sgx_ioc_enclave_create</code><span class="sig-paren">(</span>struct sgx_encl<em>&nbsp;*encl</em>, void __user<em>&nbsp;*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_create" title="Permalink to this definition">¶</a></dt>
<dd><p>handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_CREATE</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt>
<dd>An enclave pointer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt>
<dd>The ioctl argument.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate kernel data structures for the enclave and invoke ECREATE.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li>0:         Success.</li>
<li>-EIO:      ECREATE failed.</li>
<li>-errno:    POSIX error.</li>
</ul>
<dl class="function">
<dt id="c.sgx_ioc_enclave_add_pages">
long <code class="descname">sgx_ioc_enclave_add_pages</code><span class="sig-paren">(</span>struct sgx_encl<em>&nbsp;*encl</em>, void __user<em>&nbsp;*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_add_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>The handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_ADD_PAGES</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt>
<dd>an enclave pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt>
<dd>a user pointer to a struct sgx_enclave_add_pages instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add one or more pages to an uninitialized enclave, and optionally extend the
measurement with the contents of the page. The SECINFO and measurement mask
are applied to all pages.</p>
<p>A SECINFO for a TCS is required to always contain zero permissions because
CPU silently zeros them. Allowing anything else would cause a mismatch in
the measurement.</p>
<p>mmap()’s protection bits are capped by the page permissions. For each page
address, the maximum protection bits are computed with the following
heuristics:</p>
<ol class="arabic simple">
<li>A regular page: PROT_R, PROT_W and PROT_X match the SECINFO permissions.</li>
<li>A TCS page: PROT_R | PROT_W.</li>
</ol>
<p>mmap() is not allowed to surpass the minimum of the maximum protection bits
within the given address range.</p>
<p>The function deinitializes kernel data structures for enclave and returns
-EIO in any of the following conditions:</p>
<ul class="simple">
<li>Enclave Page Cache (EPC), the physical memory holding enclaves, has
been invalidated. This will cause EADD and EEXTEND to fail.</li>
<li>If the source address is corrupted somehow when executing EADD.</li>
</ul>
<p><strong>Return</strong></p>
<ul class="simple">
<li>0:         Success.</li>
<li>-EACCES:   The source page is located in a noexec partition.</li>
<li>-ENOMEM:   Out of EPC pages.</li>
<li>-EINTR:    The call was interrupted before data was processed.</li>
<li><dl class="first docutils">
<dt>-EIO:      Either EADD or EEXTEND failed because invalid source address</dt>
<dd>or power cycle.</dd>
</dl>
</li>
<li>-errno:    POSIX error.</li>
</ul>
<dl class="function">
<dt id="c.sgx_ioc_enclave_init">
long <code class="descname">sgx_ioc_enclave_init</code><span class="sig-paren">(</span>struct sgx_encl<em>&nbsp;*encl</em>, void __user<em>&nbsp;*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_init" title="Permalink to this definition">¶</a></dt>
<dd><p>handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_INIT</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt>
<dd>an enclave pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt>
<dd>userspace pointer to a struct sgx_enclave_init instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush any outstanding enqueued EADD operations and perform EINIT.  The
Launch Enclave Public Key Hash MSRs are rewritten as necessary to match
the enclave’s MRSIGNER, which is caculated from the provided sigstruct.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li>0:         Success.</li>
<li>-EPERM:    Invalid SIGSTRUCT.</li>
<li>-EIO:      EINIT failed because of a power cycle.</li>
<li>-errno:    POSIX error.</li>
</ul>
<dl class="function">
<dt id="c.sgx_ioc_enclave_provision">
long <code class="descname">sgx_ioc_enclave_provision</code><span class="sig-paren">(</span>struct sgx_encl<em>&nbsp;*encl</em>, void __user<em>&nbsp;*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_provision" title="Permalink to this definition">¶</a></dt>
<dd><p>handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_PROVISION</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt>
<dd>an enclave pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt>
<dd>userspace pointer to a struct sgx_enclave_provision instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow ATTRIBUTE.PROVISION_KEY for an enclave by providing a file handle to
/dev/sgx_provision.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li>0:         Success.</li>
<li>-errno:    Otherwise.</li>
</ul>
</div>
<div class="section" id="enclave-vdso">
<h3>29.3.2. Enclave vDSO<a class="headerlink" href="#enclave-vdso" title="Permalink to this headline">¶</a></h3>
<p>Entering an enclave can only be done through SGX-specific EENTER and ERESUME
functions, and is a non-trivial process.  Because of the complexity of
transitioning to and from an enclave, enclaves typically utilize a library to
handle the actual transitions.  This is roughly analogous to how glibc
implementations are used by most applications to wrap system calls.</p>
<p>Another crucial characteristic of enclaves is that they can generate exceptions
as part of their normal operation that need to be handled in the enclave or are
unique to SGX.</p>
<p>Instead of the traditional signal mechanism to handle these exceptions, SGX
can leverage special exception fixup provided by the vDSO.  The kernel-provided
vDSO function wraps low-level transitions to/from the enclave like EENTER and
ERESUME.  The vDSO function intercepts exceptions that would otherwise generate
a signal and return the fault information directly to its caller.  This avoids
the need to juggle signal handlers.</p>
<dl class="type">
<dt id="c.vdso_sgx_enter_enclave_t">
<code class="descname">vdso_sgx_enter_enclave_t</code><a class="headerlink" href="#c.vdso_sgx_enter_enclave_t" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Typedef</strong>: Prototype for __vdso_sgx_enter_enclave(), a vDSO function to enter an SGX enclave.</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vdso_sgx_enter_enclave_t</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">rdi,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rsi,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rdx,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">function,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">r8,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">r9,</span> <span class="pre">struct</span> <span class="pre">sgx_enclave_run</span> <span class="pre">*run)</span></code></div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rdi</span></code></dt>
<dd>Pass-through value for RDI</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rsi</span></code></dt>
<dd>Pass-through value for RSI</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rdx</span></code></dt>
<dd>Pass-through value for RDX</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">function</span></code></dt>
<dd>ENCLU function, must be EENTER or ERESUME</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">r8</span></code></dt>
<dd>Pass-through value for R8</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">r9</span></code></dt>
<dd>Pass-through value for R9</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_enclave_run</span> <span class="pre">*run</span></code></dt>
<dd>struct sgx_enclave_run, must be non-NULL</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>__vdso_sgx_enter_enclave() does not ensure full compliance with the
x86-64 ABI, e.g. doesn’t handle XSAVE state.  Except for non-volatile
general purpose registers, EFLAGS.DF, and RSP alignment, preserving/setting
state in accordance with the x86-64 ABI is the responsibility of the enclave
and its runtime, i.e. __vdso_sgx_enter_enclave() cannot be called from C
code without careful consideration by both the enclave and its runtime.</p>
<p><strong>Description</strong></p>
<p>All general purpose registers except RAX, RBX and RCX are passed as-is to the
enclave.  RAX, RBX and RCX are consumed by EENTER and ERESUME and are loaded
with <strong>function</strong>, asynchronous exit pointer, and <strong>run.tcs</strong> respectively.</p>
<p>RBP and the stack are used to anchor __vdso_sgx_enter_enclave() to the
pre-enclave state, e.g. to retrieve <strong>run.exception</strong> and <strong>run.user_handler</strong>
after an enclave exit.  All other registers are available for use by the
enclave and its runtime, e.g. an enclave can push additional data onto the
stack (and modify RSP) to pass information to the optional user handler (see
below).</p>
<p>Most exceptions reported on ENCLU, including those that occur within the
enclave, are fixed up and reported synchronously instead of being delivered
via a standard signal. Debug Exceptions (#DB) and Breakpoints (#BP) are
never fixed up and are always delivered via standard signals. On synchronously
reported exceptions, -EFAULT is returned and details about the exception are
recorded in <strong>run.exception</strong>, the optional sgx_enclave_exception struct.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li>0:         ENCLU function was successfully executed.</li>
<li>-EINVAL:   Invalid ENCL number (neither EENTER nor ERESUME).</li>
</ul>
</div>
</div>
<div class="section" id="ksgxd">
<h2>29.4. ksgxd<a class="headerlink" href="#ksgxd" title="Permalink to this headline">¶</a></h2>
<p>SGX support includes a kernel thread called <em>ksgxd</em>.</p>
<div class="section" id="epc-sanitization">
<h3>29.4.1. EPC sanitization<a class="headerlink" href="#epc-sanitization" title="Permalink to this headline">¶</a></h3>
<p>ksgxd is started when SGX initializes.  Enclave memory is typically ready
for use when the processor powers on or resets.  However, if SGX has been in
use since the reset, enclave pages may be in an inconsistent state.  This might
occur after a crash and kexec() cycle, for instance.  At boot, ksgxd
reinitializes all enclave pages so that they can be allocated and re-used.</p>
<p>The sanitization is done by going through EPC address space and applying the
EREMOVE function to each physical page. Some enclave pages like SECS pages have
hardware dependencies on other pages which prevents EREMOVE from functioning.
Executing two EREMOVE passes removes the dependencies.</p>
</div>
<div class="section" id="page-reclaimer">
<h3>29.4.2. Page reclaimer<a class="headerlink" href="#page-reclaimer" title="Permalink to this headline">¶</a></h3>
<p>Similar to the core kswapd, ksgxd, is responsible for managing the
overcommitment of enclave memory.  If the system runs out of enclave memory,
<em>ksgxd</em> “swaps” enclave memory to normal memory.</p>
</div>
</div>
<div class="section" id="launch-control">
<h2>29.5. Launch Control<a class="headerlink" href="#launch-control" title="Permalink to this headline">¶</a></h2>
<p>SGX provides a launch control mechanism. After all enclave pages have been
copied, kernel executes EINIT function, which initializes the enclave. Only after
this the CPU can execute inside the enclave.</p>
<p>EINIT function takes an RSA-3072 signature of the enclave measurement.  The function
checks that the measurement is correct and signature is signed with the key
hashed to the four <strong>IA32_SGXLEPUBKEYHASH{0, 1, 2, 3}</strong> MSRs representing the
SHA256 of a public key.</p>
<p>Those MSRs can be configured by the BIOS to be either readable or writable.
Linux supports only writable configuration in order to give full control to the
kernel on launch control policy. Before calling EINIT function, the driver sets
the MSRs to match the enclave’s signing key.</p>
</div>
<div class="section" id="encryption-engines">
<h2>29.6. Encryption engines<a class="headerlink" href="#encryption-engines" title="Permalink to this headline">¶</a></h2>
<p>In order to conceal the enclave data while it is out of the CPU package, the
memory controller has an encryption engine to transparently encrypt and decrypt
enclave memory.</p>
<p>In CPUs prior to Ice Lake, the Memory Encryption Engine (MEE) is used to
encrypt pages leaving the CPU caches. MEE uses a n-ary Merkle tree with root in
SRAM to maintain integrity of the encrypted data. This provides integrity and
anti-replay protection but does not scale to large memory sizes because the time
required to update the Merkle tree grows logarithmically in relation to the
memory size.</p>
<p>CPUs starting from Icelake use Total Memory Encryption (TME) in the place of
MEE. TME-based SGX implementations do not have an integrity Merkle tree, which
means integrity and replay-attacks are not mitigated.  B, it includes
additional changes to prevent cipher text from being returned and SW memory
aliases from being created.</p>
<p>DMA to enclave memory is blocked by range registers on both MEE and TME systems
(SDM section 41.10).</p>
</div>
<div class="section" id="usage-models">
<h2>29.7. Usage Models<a class="headerlink" href="#usage-models" title="Permalink to this headline">¶</a></h2>
<div class="section" id="shared-library">
<h3>29.7.1. Shared Library<a class="headerlink" href="#shared-library" title="Permalink to this headline">¶</a></h3>
<p>Sensitive data and the code that acts on it is partitioned from the application
into a separate library. The library is then linked as a DSO which can be loaded
into an enclave. The application can then make individual function calls into
the enclave through special SGX instructions. A run-time within the enclave is
configured to marshal function parameters into and out of the enclave and to
call the correct library function.</p>
</div>
<div class="section" id="application-container">
<h3>29.7.2. Application Container<a class="headerlink" href="#application-container" title="Permalink to this headline">¶</a></h3>
<p>An application may be loaded into a container enclave which is specially
configured with a library OS and run-time which permits the application to run.
The enclave run-time and library OS work together to execute the application
when a thread enters the enclave.</p>
</div>
</div>
<div class="section" id="impact-of-potential-kernel-sgx-bugs">
<h2>29.8. Impact of Potential Kernel SGX Bugs<a class="headerlink" href="#impact-of-potential-kernel-sgx-bugs" title="Permalink to this headline">¶</a></h2>
<div class="section" id="epc-leaks">
<h3>29.8.1. EPC leaks<a class="headerlink" href="#epc-leaks" title="Permalink to this headline">¶</a></h3>
<p>When EPC page leaks happen, a WARNING like this is shown in dmesg:</p>
<p>“EREMOVE returned … and an EPC page was leaked.  SGX may become unusable…”</p>
<p>This is effectively a kernel use-after-free of an EPC page, and due
to the way SGX works, the bug is detected at freeing. Rather than
adding the page back to the pool of available EPC pages, the kernel
intentionally leaks the page to avoid additional errors in the future.</p>
<p>When this happens, the kernel will likely soon leak more EPC pages, and
SGX will likely become unusable because the memory available to SGX is
limited. However, while this may be fatal to SGX, the rest of the kernel
is unlikely to be impacted and should continue to work.</p>
<p>As a result, when this happpens, user should stop running any new
SGX workloads, (or just any new workloads), and migrate all valuable
workloads. Although a machine reboot can recover all EPC memory, the bug
should be reported to Linux developers.</p>
</div>
</div>
<div class="section" id="virtual-epc">
<h2>29.9. Virtual EPC<a class="headerlink" href="#virtual-epc" title="Permalink to this headline">¶</a></h2>
<p>The implementation has also a virtual EPC driver to support SGX enclaves
in guests. Unlike the SGX driver, an EPC page allocated by the virtual
EPC driver doesn’t have a specific enclave associated with it. This is
because KVM doesn’t track how a guest uses EPC pages.</p>
<p>As a result, the SGX core page reclaimer doesn’t support reclaiming EPC
pages allocated to KVM guests through the virtual EPC driver. If the
user wants to deploy SGX applications both on the host and in guests
on the same machine, the user should reserve enough EPC (by taking out
total virtual EPC size of all SGX VMs from the physical EPC size) for
host SGX applications so they can run with acceptable performance.</p>
<p>Architectural behavior is to restore all EPC pages to an uninitialized
state also after a guest reboot.  Because this state can be reached only
through the privileged <code class="docutils literal notranslate"><span class="pre">ENCLS[EREMOVE]</span></code> instruction, <code class="docutils literal notranslate"><span class="pre">/dev/sgx_vepc</span></code>
provides the <code class="docutils literal notranslate"><span class="pre">SGX_IOC_VEPC_REMOVE_ALL</span></code> ioctl to execute the instruction
on all pages in the virtual EPC.</p>
<p><code class="docutils literal notranslate"><span class="pre">EREMOVE</span></code> can fail for three reasons.  Userspace must pay attention
to expected failures and handle them as follows:</p>
<ol class="arabic simple">
<li>Page removal will always fail when any thread is running in the
enclave to which the page belongs.  In this case the ioctl will
return <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> independent of whether it has successfully removed
some pages; userspace can avoid these failures by preventing execution
of any vcpu which maps the virtual EPC.</li>
<li>Page removal will cause a general protection fault if two calls to
<code class="docutils literal notranslate"><span class="pre">EREMOVE</span></code> happen concurrently for pages that refer to the same
“SECS” metadata pages.  This can happen if there are concurrent
invocations to <code class="docutils literal notranslate"><span class="pre">SGX_IOC_VEPC_REMOVE_ALL</span></code>, or if a <code class="docutils literal notranslate"><span class="pre">/dev/sgx_vepc</span></code>
file descriptor in the guest is closed at the same time as
<code class="docutils literal notranslate"><span class="pre">SGX_IOC_VEPC_REMOVE_ALL</span></code>; it will also be reported as <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>.
This can be avoided in userspace by serializing calls to the ioctl()
and to close(), but in general it should not be a problem.</li>
<li>Finally, page removal will fail for SECS metadata pages which still
have child pages.  Child pages can be removed by executing
<code class="docutils literal notranslate"><span class="pre">SGX_IOC_VEPC_REMOVE_ALL</span></code> on all <code class="docutils literal notranslate"><span class="pre">/dev/sgx_vepc</span></code> file descriptors
mapped into the guest.  This means that the ioctl() must be called
twice: an initial set of calls to remove child pages and a subsequent
set of calls to remove SECS pages.  The second set of calls is only
required for those mappings that returned a nonzero value from the
first call.  It indicates a bug in the kernel or the userspace client
if any of the second round of <code class="docutils literal notranslate"><span class="pre">SGX_IOC_VEPC_REMOVE_ALL</span></code> calls has
a return code other than 0.</li>
</ol>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="features.html" class="btn btn-neutral float-right" title="30. Feature status on x86 architecture" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sva.html" class="btn btn-neutral" title="28. Shared Virtual Addressing (SVA) with ENQCMD" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>