

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Core Driver Infrastructure &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../../index.html"/>
        <link rel="up" title="drm/amdgpu AMDgpu driver" href="index.html"/>
        <link rel="next" title="drm/amd/display - Display Core (DC)" href="display/index.html"/>
        <link rel="prev" title="Module Parameters" href="module-parameters.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux GPU Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../driver-uapi.html">DRM Driver uAPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drm-client.html">Kernel clients</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../drivers.html">GPU Driver Documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">drm/amdgpu AMDgpu driver</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="module-parameters.html">Module Parameters</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Core Driver Infrastructure</a></li>
<li class="toctree-l4"><a class="reference internal" href="display/index.html">drm/amd/display - Display Core (DC)</a></li>
<li class="toctree-l4"><a class="reference internal" href="xgmi.html">AMDGPU XGMI Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="ras.html">AMDGPU RAS Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="thermal.html">GPU Power/Thermal Controls and Monitoring</a></li>
<li class="toctree-l4"><a class="reference internal" href="driver-misc.html">Misc AMDGPU driver information</a></li>
<li class="toctree-l4"><a class="reference internal" href="amdgpu-glossary.html">AMDGPU Glossary</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mcde.html">drm/mcde ST-Ericsson MCDE Multi-channel display engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="../meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pl111.html">drm/pl111 ARM PrimeCell PL110 and PL111 CLCD Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tve200.html">drm/tve200 Faraday TV Encoder 200</a></li>
<li class="toctree-l3"><a class="reference internal" href="../v3d.html">drm/v3d Broadcom V3D Graphics Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../vkms.html">drm/vkms Virtual Kernel Modesetting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="../xen-front.html">drm/xen-front Xen para-virtualized frontend driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../afbc.html">Arm Framebuffer Compression (AFBC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../komeda-kms.html">drm/komeda Arm display driver</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../backlight.html">Backlight support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../todo.html">TODO list</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rfc/index.html">GPU RFC Section</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Linux GPU Driver Developer’s Guide</a> &raquo;</li>
        
          <li><a href="../drivers.html">GPU Driver Documentation</a> &raquo;</li>
        
          <li><a href="index.html">drm/amdgpu AMDgpu driver</a> &raquo;</li>
        
      <li>Core Driver Infrastructure</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/gpu/amdgpu/driver-core.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="core-driver-infrastructure">
<h1>Core Driver Infrastructure<a class="headerlink" href="#core-driver-infrastructure" title="Permalink to this headline">¶</a></h1>
<div class="section" id="gpu-hardware-structure">
<h2>GPU Hardware Structure<a class="headerlink" href="#gpu-hardware-structure" title="Permalink to this headline">¶</a></h2>
<p>Each ASIC is a collection of hardware blocks.  We refer to them as
“IPs” (Intellectual Property blocks).  Each IP encapsulates certain
functionality. IPs are versioned and can also be mixed and matched.
E.g., you might have two different ASICs that both have System DMA (SDMA) 5.x IPs.
The driver is arranged by IPs.  There are driver components to handle
the initialization and operation of each IP.  There are also a bunch
of smaller IPs that don’t really need much if any driver interaction.
Those end up getting lumped into the common stuff in the soc files.
The soc files (e.g., vi.c, soc15.c nv.c) contain code for aspects of
the SoC itself rather than specific IPs.  E.g., things like GPU resets
and register access functions are SoC dependent.</p>
<p>An APU contains more than just CPU and GPU, it also contains all of
the platform stuff (audio, usb, gpio, etc.).  Also, a lot of
components are shared between the CPU, platform, and the GPU (e.g.,
SMU, PSP, etc.).  Specific components (CPU, GPU, etc.) usually have
their interface to interact with those common components.  For things
like S0i3 there is a ton of coordination required across all the
components, but that is probably a bit beyond the scope of this
section.</p>
<p>With respect to the GPU, we have the following major IPs:</p>
<dl class="docutils">
<dt>GMC (Graphics Memory Controller)</dt>
<dd>This was a dedicated IP on older pre-vega chips, but has since
become somewhat decentralized on vega and newer chips.  They now
have dedicated memory hubs for specific IPs or groups of IPs.  We
still treat it as a single component in the driver however since
the programming model is still pretty similar.  This is how the
different IPs on the GPU get the memory (VRAM or system memory).
It also provides the support for per process GPU virtual address
spaces.</dd>
<dt>IH (Interrupt Handler)</dt>
<dd>This is the interrupt controller on the GPU.  All of the IPs feed
their interrupts into this IP and it aggregates them into a set of
ring buffers that the driver can parse to handle interrupts from
different IPs.</dd>
<dt>PSP (Platform Security Processor)</dt>
<dd>This handles security policy for the SoC and executes trusted
applications, and validates and loads firmwares for other blocks.</dd>
<dt>SMU (System Management Unit)</dt>
<dd>This is the power management microcontroller.  It manages the entire
SoC.  The driver interacts with it to control power management
features like clocks, voltages, power rails, etc.</dd>
<dt>DCN (Display Controller Next)</dt>
<dd>This is the display controller.  It handles the display hardware.
It is described in more details in <a class="reference internal" href="display/index.html#amdgpu-display-core"><span class="std std-ref">Display Core</span></a>.</dd>
<dt>SDMA (System DMA)</dt>
<dd>This is a multi-purpose DMA engine.  The kernel driver uses it for
various things including paging and GPU page table updates.  It’s also
exposed to userspace for use by user mode drivers (OpenGL, Vulkan,
etc.)</dd>
<dt>GC (Graphics and Compute)</dt>
<dd>This is the graphics and compute engine, i.e., the block that
encompasses the 3D pipeline and and shader blocks.  This is by far the
largest block on the GPU.  The 3D pipeline has tons of sub-blocks.  In
addition to that, it also contains the CP microcontrollers (ME, PFP,
CE, MEC) and the RLC microcontroller.  It’s exposed to userspace for
user mode drivers (OpenGL, Vulkan, OpenCL, etc.)</dd>
<dt>VCN (Video Core Next)</dt>
<dd>This is the multi-media engine.  It handles video and image encode and
decode.  It’s exposed to userspace for user mode drivers (VA-API,
OpenMAX, etc.)</dd>
</dl>
<div class="section" id="graphics-and-compute-microcontrollers">
<h3>Graphics and Compute Microcontrollers<a class="headerlink" href="#graphics-and-compute-microcontrollers" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>CP (Command Processor)</dt>
<dd><p class="first">The name for the hardware block that encompasses the front end of the
GFX/Compute pipeline.  Consists mainly of a bunch of microcontrollers
(PFP, ME, CE, MEC).  The firmware that runs on these microcontrollers
provides the driver interface to interact with the GFX/Compute engine.</p>
<dl class="last docutils">
<dt>MEC (MicroEngine Compute)</dt>
<dd>This is the microcontroller that controls the compute queues on the
GFX/compute engine.</dd>
<dt>MES (MicroEngine Scheduler)</dt>
<dd>This is a new engine for managing queues.  This is currently unused.</dd>
</dl>
</dd>
<dt>RLC (RunList Controller)</dt>
<dd>This is another microcontroller in the GFX/Compute engine.  It handles
power management related functionality within the GFX/Compute engine.
The name is a vestige of old hardware where it was originally added
and doesn’t really have much relation to what the engine does now.</dd>
</dl>
</div>
</div>
<div class="section" id="driver-structure">
<h2>Driver Structure<a class="headerlink" href="#driver-structure" title="Permalink to this headline">¶</a></h2>
<p>In general, the driver has a list of all of the IPs on a particular
SoC and for things like init/fini/suspend/resume, more or less just
walks the list and handles each IP.</p>
<p>Some useful constructs:</p>
<dl class="docutils">
<dt>KIQ (Kernel Interface Queue)</dt>
<dd>This is a control queue used by the kernel driver to manage other gfx
and compute queues on the GFX/compute engine.  You can use it to
map/unmap additional queues, etc.</dd>
<dt>IB (Indirect Buffer)</dt>
<dd>A command buffer for a particular engine.  Rather than writing
commands directly to the queue, you can write the commands into a
piece of memory and then put a pointer to the memory into the queue.
The hardware will then follow the pointer and execute the commands in
the memory, then returning to the rest of the commands in the ring.</dd>
</dl>
</div>
<div class="section" id="memory-domains">
<span id="amdgpu-memory-domains"></span><h2>Memory Domains<a class="headerlink" href="#memory-domains" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_CPU</span></code>       System memory that is not GPU accessible.
Memory in this pool could be swapped out to disk if there is pressure.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_GTT</span></code>       GPU accessible system memory, mapped into the
GPU’s virtual address space via gart. Gart memory linearizes non-contiguous
pages of system memory, allows GPU access system memory in a linearized
fashion.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_VRAM</span></code>      Local video memory. For APUs, it is memory
carved out by the BIOS.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_GDS</span></code>       Global on-chip data storage used to share data
across shader threads.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_GWS</span></code>       Global wave sync, used to synchronize the
execution of all the waves on a device.</p>
<p><code class="docutils literal notranslate"><span class="pre">AMDGPU_GEM_DOMAIN_OA</span></code>        Ordered append, used by 3D or Compute engines
for appending data.</p>
</div>
<div class="section" id="buffer-objects">
<h2>Buffer Objects<a class="headerlink" href="#buffer-objects" title="Permalink to this headline">¶</a></h2>
<p>This defines the interfaces to operate on an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object which
represents memory used by driver (VRAM, system memory, etc.). The driver
provides DRM/GEM APIs to userspace. DRM/GEM APIs then use these interfaces
to create/destroy/set buffer object which are then managed by the kernel TTM
memory manager.
The interfaces are also used internally by kernel clients, including gfx,
uvd, etc. for kernel managed allocations used by the GPU.</p>
<dl class="function">
<dt id="c.amdgpu_bo_is_amdgpu_bo">
bool <code class="descname">amdgpu_bo_is_amdgpu_bo</code><span class="sig-paren">(</span>struct ttm_buffer_object<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_is_amdgpu_bo" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the buffer object is an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*bo</span></code></dt>
<dd>buffer object to be checked</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses destroy function associated with the object to determine if this is
an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code>.</p>
<p><strong>Return</strong></p>
<p>true if the object belongs to <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code>, false if not.</p>
<dl class="function">
<dt id="c.amdgpu_bo_placement_from_domain">
void <code class="descname">amdgpu_bo_placement_from_domain</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*abo</em>, u32<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_placement_from_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>set buffer’s placement</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*abo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object whose placement is to be set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>requested domain</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets buffer’s placement according to requested domain and the buffer’s
flags.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create_reserved">
int <code class="descname">amdgpu_bo_create_reserved</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, unsigned long<em>&nbsp;size</em>, int<em>&nbsp;align</em>, u32<em>&nbsp;domain</em>, struct amdgpu_bo<em>&nbsp;**bo_ptr</em>, u64<em>&nbsp;*gpu_addr</em>, void<em>&nbsp;**cpu_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create_reserved" title="Permalink to this definition">¶</a></dt>
<dd><p>create reserved BO for kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size for the new BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">align</span></code></dt>
<dd>alignment for the new BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>where to place it</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**bo_ptr</span></code></dt>
<dd>used to initialize BOs in structures</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*gpu_addr</span></code></dt>
<dd>GPU addr of the pinned BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**cpu_addr</span></code></dt>
<dd>optional CPU address mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and pins a BO for kernel internal use, and returns it still
reserved.</p>
<p><strong>Note</strong></p>
<p>For bo_ptr new BO is only created if bo_ptr points to NULL.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create_kernel">
int <code class="descname">amdgpu_bo_create_kernel</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, unsigned long<em>&nbsp;size</em>, int<em>&nbsp;align</em>, u32<em>&nbsp;domain</em>, struct amdgpu_bo<em>&nbsp;**bo_ptr</em>, u64<em>&nbsp;*gpu_addr</em>, void<em>&nbsp;**cpu_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>create BO for kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size for the new BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">align</span></code></dt>
<dd>alignment for the new BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>where to place it</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**bo_ptr</span></code></dt>
<dd>used to initialize BOs in structures</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*gpu_addr</span></code></dt>
<dd>GPU addr of the pinned BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**cpu_addr</span></code></dt>
<dd>optional CPU address mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and pins a BO for kernel internal use.</p>
<p><strong>Note</strong></p>
<p>For bo_ptr new BO is only created if bo_ptr points to NULL.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create_kernel_at">
int <code class="descname">amdgpu_bo_create_kernel_at</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, uint64_t<em>&nbsp;offset</em>, uint64_t<em>&nbsp;size</em>, uint32_t<em>&nbsp;domain</em>, struct amdgpu_bo<em>&nbsp;**bo_ptr</em>, void<em>&nbsp;**cpu_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create_kernel_at" title="Permalink to this definition">¶</a></dt>
<dd><p>create BO for kernel use at specific location</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt>
<dd>offset of the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>size of the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">domain</span></code></dt>
<dd>where to place it</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**bo_ptr</span></code></dt>
<dd>used to initialize BOs in structures</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**cpu_addr</span></code></dt>
<dd>optional CPU address mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a kernel BO at a specific offset in the address space of the domain.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_bo_free_kernel">
void <code class="descname">amdgpu_bo_free_kernel</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;**bo</em>, u64<em>&nbsp;*gpu_addr</em>, void<em>&nbsp;**cpu_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_free_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>free BO for kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**bo</span></code></dt>
<dd>amdgpu BO to free</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*gpu_addr</span></code></dt>
<dd>pointer to where the BO’s GPU memory space address was stored</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**cpu_addr</span></code></dt>
<dd>pointer to where the BO’s CPU memory space address was stored</dd>
</dl>
<p><strong>Description</strong></p>
<p>unmaps and unpin a BO for kernel internal use.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create">
int <code class="descname">amdgpu_bo_create</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo_param<em>&nbsp;*bp</em>, struct amdgpu_bo<em>&nbsp;**bo_ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_param</span> <span class="pre">*bp</span></code></dt>
<dd>parameters to be used for the buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**bo_ptr</span></code></dt>
<dd>pointer to the buffer object pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create_user">
int <code class="descname">amdgpu_bo_create_user</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo_param<em>&nbsp;*bp</em>, struct amdgpu_bo_user<em>&nbsp;**ubo_ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create_user" title="Permalink to this definition">¶</a></dt>
<dd><p>create an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo_user</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_param</span> <span class="pre">*bp</span></code></dt>
<dd>parameters to be used for the buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_user</span> <span class="pre">**ubo_ptr</span></code></dt>
<dd>pointer to the buffer object pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a BO to be used by user application;</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create_vm">
int <code class="descname">amdgpu_bo_create_vm</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo_param<em>&nbsp;*bp</em>, struct amdgpu_bo_vm<em>&nbsp;**vmbo_ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create_vm" title="Permalink to this definition">¶</a></dt>
<dd><p>create an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo_vm</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_param</span> <span class="pre">*bp</span></code></dt>
<dd>parameters to be used for the buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_vm</span> <span class="pre">**vmbo_ptr</span></code></dt>
<dd>pointer to the buffer object pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a BO to be for GPUVM.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_add_to_shadow_list">
void <code class="descname">amdgpu_bo_add_to_shadow_list</code><span class="sig-paren">(</span>struct amdgpu_bo_vm<em>&nbsp;*vmbo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_add_to_shadow_list" title="Permalink to this definition">¶</a></dt>
<dd><p>add a BO to the shadow list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_vm</span> <span class="pre">*vmbo</span></code></dt>
<dd>BO that will be inserted into the shadow list</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a BO to the shadow list.</p>
<dl class="function">
<dt id="c.amdgpu_bo_restore_shadow">
int <code class="descname">amdgpu_bo_restore_shadow</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*shadow</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a><em>&nbsp;**fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_restore_shadow" title="Permalink to this definition">¶</a></dt>
<dd><p>restore an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> shadow</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*shadow</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> shadow to be restored</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**fence</span></code></dt>
<dd>dma_fence associated with the operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies a buffer object’s shadow content back to the object.
This is used for recovering a buffer from its shadow in case of a gpu
reset where vram context may be lost.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_kmap">
int <code class="descname">amdgpu_bo_kmap</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em>, void<em>&nbsp;**ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_kmap" title="Permalink to this definition">¶</a></dt>
<dd><p>map an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object to be mapped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**ptr</span></code></dt>
<dd>kernel virtual address to be returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls ttm_bo_kmap() to set up the kernel virtual mapping; calls
<a class="reference internal" href="#c.amdgpu_bo_kptr" title="amdgpu_bo_kptr"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_bo_kptr()</span></code></a> to get the kernel virtual address.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_kptr">
void * <code class="descname">amdgpu_bo_kptr</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_kptr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a kernel virtual address of the buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls ttm_kmap_obj_virtual() to get the kernel virtual address</p>
<p><strong>Return</strong></p>
<p>the virtual address of a buffer object area.</p>
<dl class="function">
<dt id="c.amdgpu_bo_kunmap">
void <code class="descname">amdgpu_bo_kunmap</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_kunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object to be unmapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmaps a kernel map set up by <a class="reference internal" href="#c.amdgpu_bo_kmap" title="amdgpu_bo_kmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_bo_kmap()</span></code></a>.</p>
<dl class="function">
<dt id="c.amdgpu_bo_ref">
struct amdgpu_bo * <code class="descname">amdgpu_bo_ref</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>reference an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>References the contained <code class="xref c c-type docutils literal notranslate"><span class="pre">ttm_buffer_object</span></code>.</p>
<p><strong>Return</strong></p>
<p>a refcounted pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object.</p>
<dl class="function">
<dt id="c.amdgpu_bo_unref">
void <code class="descname">amdgpu_bo_unref</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;**bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>unreference an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unreferences the contained <code class="xref c c-type docutils literal notranslate"><span class="pre">ttm_buffer_object</span></code> and clear the pointer</p>
<dl class="function">
<dt id="c.amdgpu_bo_pin_restricted">
int <code class="descname">amdgpu_bo_pin_restricted</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em>, u32<em>&nbsp;domain</em>, u64<em>&nbsp;min_offset</em>, u64<em>&nbsp;max_offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_pin_restricted" title="Permalink to this definition">¶</a></dt>
<dd><p>pin an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object to be pinned</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>domain to be pinned to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">min_offset</span></code></dt>
<dd>the start of requested address range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">max_offset</span></code></dt>
<dd>the end of requested address range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pins the buffer object according to requested domain and address range. If
the memory is unbound gart memory, binds the pages into gart table. Adjusts
pin_count and pin_size accordingly.</p>
<p>Pinning means to lock pages in memory along with keeping them at a fixed
offset. It is required when a buffer can not be moved, for example, when
a display buffer is being scanned out.</p>
<p>Compared with <a class="reference internal" href="#c.amdgpu_bo_pin" title="amdgpu_bo_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_bo_pin()</span></code></a>, this function gives more flexibility on
where to pin a buffer if there are specific restrictions on where a buffer
must be located.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_pin">
int <code class="descname">amdgpu_bo_pin</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em>, u32<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>pin an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object to be pinned</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>domain to be pinned to</dd>
</dl>
<p><strong>Description</strong></p>
<p>A simple wrapper to <a class="reference internal" href="#c.amdgpu_bo_pin_restricted" title="amdgpu_bo_pin_restricted"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_bo_pin_restricted()</span></code></a>.
Provides a simpler API for buffers that do not have any strict restrictions
on where a buffer must be located.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_unpin">
void <code class="descname">amdgpu_bo_unpin</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_unpin" title="Permalink to this definition">¶</a></dt>
<dd><p>unpin an <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object to be unpinned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decreases the pin_count, and clears the flags if pin_count reaches 0.
Changes placement and pin size accordingly.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_init">
int <code class="descname">amdgpu_bo_init</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize memory manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls amdgpu_ttm_init() to initialize amdgpu memory manager.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fini">
void <code class="descname">amdgpu_bo_fini</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down memory manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reverses <a class="reference internal" href="#c.amdgpu_bo_init" title="amdgpu_bo_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">amdgpu_bo_init()</span></code></a> to tear down memory manager.</p>
<dl class="function">
<dt id="c.amdgpu_bo_set_tiling_flags">
int <code class="descname">amdgpu_bo_set_tiling_flags</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em>, u64<em>&nbsp;tiling_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_set_tiling_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>set tiling flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">tiling_flags</span></code></dt>
<dd>new flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets buffer object’s tiling flags with the new one. Used by GEM ioctl or
kernel driver to set the tiling flags on a buffer.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_get_tiling_flags">
void <code class="descname">amdgpu_bo_get_tiling_flags</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em>, u64<em>&nbsp;*tiling_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_get_tiling_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>get tiling flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*tiling_flags</span></code></dt>
<dd>returned flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets buffer object’s tiling flags. Used by GEM ioctl or kernel driver to
set the tiling flags on a buffer.</p>
<dl class="function">
<dt id="c.amdgpu_bo_set_metadata">
int <code class="descname">amdgpu_bo_set_metadata</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em>, void<em>&nbsp;*metadata</em>, uint32_t<em>&nbsp;metadata_size</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_set_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>set metadata</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*metadata</span></code></dt>
<dd>new metadata</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">metadata_size</span></code></dt>
<dd>size of the new metadata</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>flags of the new metadata</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets buffer object’s metadata, its size and flags.
Used via GEM ioctl.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_get_metadata">
int <code class="descname">amdgpu_bo_get_metadata</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em>, void<em>&nbsp;*buffer</em>, size_t<em>&nbsp;buffer_size</em>, uint32_t<em>&nbsp;*metadata_size</em>, uint64_t<em>&nbsp;*flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>get metadata</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd><code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt>
<dd>returned metadata</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">buffer_size</span></code></dt>
<dd>size of the buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">*metadata_size</span></code></dt>
<dd>size of the returned metadata</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">*flags</span></code></dt>
<dd>flags of the returned metadata</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets buffer object’s metadata, its size and flags. buffer_size shall not be
less than metadata_size.
Used via GEM ioctl.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_move_notify">
void <code class="descname">amdgpu_bo_move_notify</code><span class="sig-paren">(</span>struct ttm_buffer_object<em>&nbsp;*bo</em>, bool<em>&nbsp;evict</em>, struct <a class="reference internal" href="../drm-mm.html#c.ttm_resource" title="ttm_resource">ttm_resource</a><em>&nbsp;*new_mem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_move_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notification about a memory move</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*bo</span></code></dt>
<dd>pointer to a buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">evict</span></code></dt>
<dd>if this move is evicting the buffer from the graphics address space</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource</span> <span class="pre">*new_mem</span></code></dt>
<dd>new information of the bufer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks the corresponding <code class="xref c c-type docutils literal notranslate"><span class="pre">amdgpu_bo</span></code> buffer object as invalid, also performs
bookkeeping.
TTM driver callback which is called when ttm moves a buffer.</p>
<dl class="function">
<dt id="c.amdgpu_bo_release_notify">
void <code class="descname">amdgpu_bo_release_notify</code><span class="sig-paren">(</span>struct ttm_buffer_object<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_release_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notification about a BO being released</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*bo</span></code></dt>
<dd>pointer to a buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wipes VRAM buffers whose contents should not be leaked before the
memory is released.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fault_reserve_notify">
<a class="reference internal" href="../../core-api/mm-api.html#c.vm_fault_t" title="vm_fault_t">vm_fault_t</a> <code class="descname">amdgpu_bo_fault_reserve_notify</code><span class="sig-paren">(</span>struct ttm_buffer_object<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fault_reserve_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notification about a memory fault</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*bo</span></code></dt>
<dd>pointer to a buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notifies the driver we are taking a fault on this BO and have reserved it,
also performs bookkeeping.
TTM driver callback for dealing with vm faults.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fence">
void <code class="descname">amdgpu_bo_fence</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a><em>&nbsp;*fence</em>, bool<em>&nbsp;shared</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>add fence to buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>buffer object in question</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt>
<dd>fence to add</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">shared</span></code></dt>
<dd>true if fence should be added shared</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_bo_sync_wait_resv">
int <code class="descname">amdgpu_bo_sync_wait_resv</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_resv" title="dma_resv">dma_resv</a><em>&nbsp;*resv</em>, enum amdgpu_sync_mode<em>&nbsp;sync_mode</em>, void<em>&nbsp;*owner</em>, bool<em>&nbsp;intr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_sync_wait_resv" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for BO reservation fences</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*resv</span></code></dt>
<dd>reservation object to sync to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">amdgpu_sync_mode</span> <span class="pre">sync_mode</span></code></dt>
<dd>synchronization mode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*owner</span></code></dt>
<dd>fence owner</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt>
<dd>Whether the wait is interruptible</dd>
</dl>
<p><strong>Description</strong></p>
<p>Extract the fences from the reservation object and waits for them to finish.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_bo_sync_wait">
int <code class="descname">amdgpu_bo_sync_wait</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em>, void<em>&nbsp;*owner</em>, bool<em>&nbsp;intr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_sync_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for amdgpu_bo_sync_wait_resv</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>buffer object to wait for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*owner</span></code></dt>
<dd>fence owner</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt>
<dd>Whether the wait is interruptible</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper to wait for fences in a BO.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_bo_gpu_offset">
u64 <code class="descname">amdgpu_bo_gpu_offset</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_gpu_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>return GPU offset of bo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>amdgpu object for which we query the offset</dd>
</dl>
<p><strong>Note</strong></p>
<p>object should either be pinned or reserved when calling this
function, it might be useful to add check for this for debugging.</p>
<p><strong>Return</strong></p>
<p>current GPU offset of the object.</p>
<dl class="function">
<dt id="c.amdgpu_bo_gpu_offset_no_check">
u64 <code class="descname">amdgpu_bo_gpu_offset_no_check</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_gpu_offset_no_check" title="Permalink to this definition">¶</a></dt>
<dd><p>return GPU offset of bo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>amdgpu object for which we query the offset</dd>
</dl>
<p><strong>Return</strong></p>
<p>current GPU offset of the object without raising warnings.</p>
<dl class="function">
<dt id="c.amdgpu_bo_get_preferred_domain">
uint32_t <code class="descname">amdgpu_bo_get_preferred_domain</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, uint32_t<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_get_preferred_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>get preferred domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">domain</span></code></dt>
<dd>allowed <a class="reference internal" href="#amdgpu-memory-domains"><span class="std std-ref">memory domains</span></a></dd>
</dl>
<p><strong>Return</strong></p>
<p>Which of the allowed domains is preferred for allocating the BO.</p>
<dl class="function">
<dt id="c.amdgpu_bo_print_info">
u64 <code class="descname">amdgpu_bo_print_info</code><span class="sig-paren">(</span>int<em>&nbsp;id</em>, struct amdgpu_bo<em>&nbsp;*bo</em>, struct seq_file<em>&nbsp;*m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_print_info" title="Permalink to this definition">¶</a></dt>
<dd><p>print BO info in debugfs file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>Index or Id of the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>Requested BO for printing info</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m</span></code></dt>
<dd>debugfs file</dd>
</dl>
<p><strong>Description</strong></p>
<p>Print BO information in debugfs file</p>
<p><strong>Return</strong></p>
<p>Size of the BO in bytes.</p>
</div>
<div class="section" id="prime-buffer-sharing">
<h2>PRIME Buffer Sharing<a class="headerlink" href="#prime-buffer-sharing" title="Permalink to this headline">¶</a></h2>
<p>The following callback implementations are used for <a class="reference internal" href="../drm-mm.html#prime-buffer-sharing"><span class="std std-ref">sharing GEM buffer
objects between different devices via PRIME</span></a>.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_attach">
int <code class="descname">amdgpu_dma_buf_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a><em>&nbsp;*dmabuf</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em>&nbsp;*attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_attach" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.attach</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt>
<dd>DMA-buf where we attach to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt>
<dd>attachment to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the attachment as user to the exported DMA-buf.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_detach">
void <code class="descname">amdgpu_dma_buf_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a><em>&nbsp;*dmabuf</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em>&nbsp;*attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_detach" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.detach</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt>
<dd>DMA-buf where we remove the attachment from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt>
<dd>the attachment to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when an attachment is removed from the DMA-buf.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_pin">
int <code class="descname">amdgpu_dma_buf_pin</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em>&nbsp;*attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_pin" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.pin</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt>
<dd>attachment to pin down</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pin the BO which is backing the DMA-buf so that it can’t move any more.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_unpin">
void <code class="descname">amdgpu_dma_buf_unpin</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em>&nbsp;*attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_unpin" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.unpin</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt>
<dd>attachment to unpin</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unpin a previously pinned BO to make it movable again.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_map">
struct sg_table * <code class="descname">amdgpu_dma_buf_map</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em>&nbsp;*attach</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_map" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.map_dma_buf</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt>
<dd>DMA-buf attachment</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>DMA direction</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes sure that the shared DMA buffer can be accessed by the target device.
For now, simply pins it to the GTT domain, where it should be accessible by
all DMA devices.</p>
<p><strong>Return</strong></p>
<p>sg_table filled with the DMA addresses to use or ERR_PRT with negative error
code.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_unmap">
void <code class="descname">amdgpu_dma_buf_unmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em>&nbsp;*attach</em>, struct sg_table<em>&nbsp;*sgt</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_unmap" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.unmap_dma_buf</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt>
<dd>DMA-buf attachment</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sgt</span></code></dt>
<dd>sg_table to unmap</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>DMA direction</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called when a shared DMA buffer no longer needs to be accessible by
another device. For now, simply unpins the buffer from GTT.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_begin_cpu_access">
int <code class="descname">amdgpu_dma_buf_begin_cpu_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a><em>&nbsp;*dma_buf</em>, enum dma_data_direction<em>&nbsp;direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_begin_cpu_access" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.begin_cpu_access</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt>
<dd>Shared DMA buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt>
<dd>Direction of DMA transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called before CPU access to the shared DMA buffer’s memory. If it’s
a read access, the buffer is moved to the GTT domain if possible, for optimal
CPU read performance.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_export">
struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> * <code class="descname">amdgpu_gem_prime_export</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a><em>&nbsp;*gobj</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_export" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_export</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*gobj</span></code></dt>
<dd>GEM BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>Flags such as DRM_CLOEXEC and DRM_RDWR.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The main work is done by the <a class="reference internal" href="../drm-mm.html#c.drm_gem_prime_export" title="drm_gem_prime_export"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_prime_export</span></code></a> helper.</p>
<p><strong>Return</strong></p>
<p>Shared DMA buffer representing the GEM BO from the given device.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_create_obj">
struct <a class="reference internal" href="../drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="descname">amdgpu_dma_buf_create_obj</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em>&nbsp;*dev</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a><em>&nbsp;*dma_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_create_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>create BO for DMA-buf import</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt>
<dd>DMA-buf</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an empty SG BO for DMA-buf import.</p>
<p><strong>Return</strong></p>
<p>A new GEM BO of the given DRM device, representing the memory
described by the given DMA-buf attachment and scatter/gather table.</p>
<dl class="function">
<dt id="c.amdgpu_dma_buf_move_notify">
void <code class="descname">amdgpu_dma_buf_move_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em>&nbsp;*attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dma_buf_move_notify" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">attach.move_notify</span></code> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt>
<dd>the DMA-buf attachment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invalidate the DMA-buf attachment, making sure that the we re-create the
mapping before the next use.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_import">
struct <a class="reference internal" href="../drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="descname">amdgpu_gem_prime_import</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em>&nbsp;*dev</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a><em>&nbsp;*dma_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_import" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.gem_prime_import</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dma_buf</span></code></dt>
<dd>Shared DMA buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Import a dma_buf into a the driver and potentially create a new GEM object.</p>
<p><strong>Return</strong></p>
<p>GEM BO representing the shared DMA buffer for the given device.</p>
<dl class="function">
<dt id="c.amdgpu_dmabuf_is_xgmi_accessible">
bool <code class="descname">amdgpu_dmabuf_is_xgmi_accessible</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_dmabuf_is_xgmi_accessible" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if xgmi available for P2P transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer of the importer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>amdgpu buffer object</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if dmabuf accessible over xgmi, false otherwise.</p>
</div>
<div class="section" id="mmu-notifier">
<h2>MMU Notifier<a class="headerlink" href="#mmu-notifier" title="Permalink to this headline">¶</a></h2>
<p>For coherent userptr handling registers an MMU notifier to inform the driver
about updates on the page tables of a process.</p>
<p>When somebody tries to invalidate the page tables we block the update until
all operations on the pages in question are completed, then those pages are
marked as accessed and also dirty if it wasn’t a read only access.</p>
<p>New command submissions using the userptrs in question are delayed until all
page table invalidation are completed and we once more see a coherent process
address space.</p>
<dl class="function">
<dt id="c.amdgpu_mn_invalidate_gfx">
bool <code class="descname">amdgpu_mn_invalidate_gfx</code><span class="sig-paren">(</span>struct mmu_interval_notifier<em>&nbsp;*mni</em>, const struct mmu_notifier_range<em>&nbsp;*range</em>, unsigned long<em>&nbsp;cur_seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_invalidate_gfx" title="Permalink to this definition">¶</a></dt>
<dd><p>callback to notify about mm change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mmu_interval_notifier</span> <span class="pre">*mni</span></code></dt>
<dd>the range (mm) is about to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mmu_notifier_range</span> <span class="pre">*range</span></code></dt>
<dd>details on the invalidation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">cur_seq</span></code></dt>
<dd>Value to pass to mmu_interval_set_seq()</dd>
</dl>
<p><strong>Description</strong></p>
<p>Block for operations on BOs to finish and mark pages as accessed and
potentially dirty.</p>
<dl class="function">
<dt id="c.amdgpu_mn_invalidate_hsa">
bool <code class="descname">amdgpu_mn_invalidate_hsa</code><span class="sig-paren">(</span>struct mmu_interval_notifier<em>&nbsp;*mni</em>, const struct mmu_notifier_range<em>&nbsp;*range</em>, unsigned long<em>&nbsp;cur_seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_invalidate_hsa" title="Permalink to this definition">¶</a></dt>
<dd><p>callback to notify about mm change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mmu_interval_notifier</span> <span class="pre">*mni</span></code></dt>
<dd>the range (mm) is about to update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mmu_notifier_range</span> <span class="pre">*range</span></code></dt>
<dd>details on the invalidation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">cur_seq</span></code></dt>
<dd>Value to pass to mmu_interval_set_seq()</dd>
</dl>
<p><strong>Description</strong></p>
<p>We temporarily evict the BO attached to this range. This necessitates
evicting all user-mode queues of the process.</p>
<dl class="function">
<dt id="c.amdgpu_mn_register">
int <code class="descname">amdgpu_mn_register</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em>, unsigned long<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a BO for notifier updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>amdgpu buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>userptr addr we should monitor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a mmu_notifier for the given BO at the specified address.
Returns 0 on success, -ERRNO if anything goes wrong.</p>
<dl class="function">
<dt id="c.amdgpu_mn_unregister">
void <code class="descname">amdgpu_mn_unregister</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a BO for notifier updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>amdgpu buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove any registration of mmu notifier updates from the buffer object.</p>
</div>
<div class="section" id="amdgpu-virtual-memory">
<h2>AMDGPU Virtual Memory<a class="headerlink" href="#amdgpu-virtual-memory" title="Permalink to this headline">¶</a></h2>
<p>GPUVM is similar to the legacy gart on older asics, however
rather than there being a single global gart table
for the entire GPU, there are multiple VM page tables active
at any given time.  The VM page tables can contain a mix
vram pages and system memory pages and system memory pages
can be mapped as snooped (cached system pages) or unsnooped
(uncached system pages).
Each VM has an ID associated with it and there is a page table
associated with each VMID.  When executing a command buffer,
the kernel tells the the ring what VMID to use for that command
buffer.  VMIDs are allocated dynamically as commands are submitted.
The userspace drivers maintain their own address space and the kernel
sets up their pages tables accordingly when they submit their
command buffers and a VMID is assigned.
Cayman/Trinity support up to 8 active VMs at any given time;
SI supports 16.</p>
<dl class="type">
<dt id="c.amdgpu_prt_cb">
struct <code class="descname">amdgpu_prt_cb</code><a class="headerlink" href="#c.amdgpu_prt_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to disable partial resident texture feature from a fence callback</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amdgpu_prt_cb {
  struct amdgpu_device *adev;
  struct dma_fence_cb cb;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">adev</span></code></dt>
<dd>amdgpu device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt>
<dd>callback</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_set_pasid">
int <code class="descname">amdgpu_vm_set_pasid</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, u32<em>&nbsp;pasid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_set_pasid" title="Permalink to this definition">¶</a></dt>
<dd><p>manage pasid and vm ptr mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>amdgpu_vm pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">pasid</span></code></dt>
<dd>the pasid the VM is using on this GPU</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the pasid this VM is using on this GPU, can also be used to remove the
pasid by passing in zero.</p>
<dl class="function">
<dt id="c.amdgpu_vm_level_shift">
unsigned <code class="descname">amdgpu_vm_level_shift</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, unsigned<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_level_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>return the addr shift for each level</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bits the pfn needs to be right shifted for a level.</p>
<dl class="function">
<dt id="c.amdgpu_vm_num_entries">
unsigned <code class="descname">amdgpu_vm_num_entries</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, unsigned<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_num_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of entries in a PD/PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of entries in a page directory or page table.</p>
<dl class="function">
<dt id="c.amdgpu_vm_num_ats_entries">
unsigned <code class="descname">amdgpu_vm_num_ats_entries</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_num_ats_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of ATS entries in the root PD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of entries in the root page directory which needs the ATS setting.</p>
<dl class="function">
<dt id="c.amdgpu_vm_entries_mask">
uint32_t <code class="descname">amdgpu_vm_entries_mask</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, unsigned int<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_entries_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>the mask to get the entry number of a PD/PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The mask to extract the entry number of a PD/PT from an address.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_size">
unsigned <code class="descname">amdgpu_vm_bo_size</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, unsigned<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_size" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the BOs in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The size of the BO for a page directory or page table in bytes.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_evicted">
void <code class="descname">amdgpu_vm_bo_evicted</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base<em>&nbsp;*vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_evicted" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is evicted</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*vm_bo</span></code></dt>
<dd>vm_bo which is evicted</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for PDs/PTs and per VM BOs which are not at the location they should
be.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_moved">
void <code class="descname">amdgpu_vm_bo_moved</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base<em>&nbsp;*vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_moved" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is moved</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*vm_bo</span></code></dt>
<dd>vm_bo which is moved</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for per VM BOs which are moved, but that change is not yet reflected
in the page tables.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_idle">
void <code class="descname">amdgpu_vm_bo_idle</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base<em>&nbsp;*vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*vm_bo</span></code></dt>
<dd>vm_bo which is now idle</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for PDs/PTs and per VM BOs which have gone through the state machine
and are now idle.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_invalidated">
void <code class="descname">amdgpu_vm_bo_invalidated</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base<em>&nbsp;*vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_invalidated" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is invalidated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*vm_bo</span></code></dt>
<dd>vm_bo which is now invalidated</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for normal BOs which are invalidated and that change not yet reflected
in the PTs.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_relocated">
void <code class="descname">amdgpu_vm_bo_relocated</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base<em>&nbsp;*vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_relocated" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is reloacted</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*vm_bo</span></code></dt>
<dd>vm_bo which is relocated</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for PDs/PTs which needs to update their parent PD.
For the root PD, just move to idle state.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_done">
void <code class="descname">amdgpu_vm_bo_done</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base<em>&nbsp;*vm_bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_done" title="Permalink to this definition">¶</a></dt>
<dd><p>vm_bo is done</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*vm_bo</span></code></dt>
<dd>vm_bo which is now done</dd>
</dl>
<p><strong>Description</strong></p>
<p>State for normal BOs which are invalidated and that change has been updated
in the PTs.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_base_init">
void <code class="descname">amdgpu_vm_bo_base_init</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base<em>&nbsp;*base</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_base_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds bo to the list of bos associated with the vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*base</span></code></dt>
<dd>base structure for tracking BO usage in a VM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>vm to which bo is to be added</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>amdgpu buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a bo_va_base structure and add it to the appropriate lists</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_parent">
struct amdgpu_vm_bo_base * <code class="descname">amdgpu_vm_pt_parent</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base<em>&nbsp;*pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>get the parent page directory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*pt</span></code></dt>
<dd>child page table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to get the parent entry for the child page table. NULL if we are at
the root page directory.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_start">
void <code class="descname">amdgpu_vm_pt_start</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, uint64_t<em>&nbsp;start</em>, struct amdgpu_vm_pt_cursor<em>&nbsp;*cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start PD/PT walk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>amdgpu_vm structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>start address of the walk</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*cursor</span></code></dt>
<dd>state to initialize</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a amdgpu_vm_pt_cursor to start a walk.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_descendant">
bool <code class="descname">amdgpu_vm_pt_descendant</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm_pt_cursor<em>&nbsp;*cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_descendant" title="Permalink to this definition">¶</a></dt>
<dd><p>go to child node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*cursor</span></code></dt>
<dd>current state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk to the child node of the current node.</p>
<p><strong>Return</strong></p>
<p>True if the walk was possible, false otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_sibling">
bool <code class="descname">amdgpu_vm_pt_sibling</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm_pt_cursor<em>&nbsp;*cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_sibling" title="Permalink to this definition">¶</a></dt>
<dd><p>go to sibling node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*cursor</span></code></dt>
<dd>current state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk to the sibling node of the current node.</p>
<p><strong>Return</strong></p>
<p>True if the walk was possible, false otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_ancestor">
bool <code class="descname">amdgpu_vm_pt_ancestor</code><span class="sig-paren">(</span>struct amdgpu_vm_pt_cursor<em>&nbsp;*cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_ancestor" title="Permalink to this definition">¶</a></dt>
<dd><p>go to parent node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*cursor</span></code></dt>
<dd>current state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk to the parent node of the current node.</p>
<p><strong>Return</strong></p>
<p>True if the walk was possible, false otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_next">
void <code class="descname">amdgpu_vm_pt_next</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm_pt_cursor<em>&nbsp;*cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_next" title="Permalink to this definition">¶</a></dt>
<dd><p>get next PD/PT in hieratchy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*cursor</span></code></dt>
<dd>current state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the PD/PT tree to the next node.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_first_dfs">
void <code class="descname">amdgpu_vm_pt_first_dfs</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, struct amdgpu_vm_pt_cursor<em>&nbsp;*start</em>, struct amdgpu_vm_pt_cursor<em>&nbsp;*cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_first_dfs" title="Permalink to this definition">¶</a></dt>
<dd><p>start a deep first search</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>amdgpu_vm structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*start</span></code></dt>
<dd>optional cursor to start with</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*cursor</span></code></dt>
<dd>state to initialize</dd>
</dl>
<p><strong>Description</strong></p>
<p>Starts a deep first traversal of the PD/PT tree.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_continue_dfs">
bool <code class="descname">amdgpu_vm_pt_continue_dfs</code><span class="sig-paren">(</span>struct amdgpu_vm_pt_cursor<em>&nbsp;*start</em>, struct amdgpu_vm_bo_base<em>&nbsp;*entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_continue_dfs" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the deep first search should continue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*start</span></code></dt>
<dd>starting point for the search</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*entry</span></code></dt>
<dd>current entry</dd>
</dl>
<p><strong>Return</strong></p>
<p>True when the search should continue, false otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_next_dfs">
void <code class="descname">amdgpu_vm_pt_next_dfs</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm_pt_cursor<em>&nbsp;*cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_next_dfs" title="Permalink to this definition">¶</a></dt>
<dd><p>get the next node for a deep first search</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*cursor</span></code></dt>
<dd>current state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move the cursor to the next node in a deep first search.</p>
<dl class="function">
<dt id="c.amdgpu_vm_get_pd_bo">
void <code class="descname">amdgpu_vm_get_pd_bo</code><span class="sig-paren">(</span>struct amdgpu_vm<em>&nbsp;*vm</em>, struct list_head<em>&nbsp;*validated</em>, struct amdgpu_bo_list_entry<em>&nbsp;*entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_get_pd_bo" title="Permalink to this definition">¶</a></dt>
<dd><p>add the VM PD to a validation list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>vm providing the BOs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*validated</span></code></dt>
<dd>head of validation list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_list_entry</span> <span class="pre">*entry</span></code></dt>
<dd>entry to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the page directory to the list of BOs to
validate for command submission.</p>
<dl class="function">
<dt id="c.amdgpu_vm_del_from_lru_notify">
void <code class="descname">amdgpu_vm_del_from_lru_notify</code><span class="sig-paren">(</span>struct ttm_buffer_object<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_del_from_lru_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>update bulk_moveable flag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*bo</span></code></dt>
<dd>BO which was removed from the LRU</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure the bulk_moveable flag is updated when a BO is removed from the
LRU.</p>
<dl class="function">
<dt id="c.amdgpu_vm_move_to_lru_tail">
void <code class="descname">amdgpu_vm_move_to_lru_tail</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_move_to_lru_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>move all BOs to the end of LRU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>vm providing the BOs</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move all BOs to the end of LRU and remember their positions to put them
together.</p>
<dl class="function">
<dt id="c.amdgpu_vm_validate_pt_bos">
int <code class="descname">amdgpu_vm_validate_pt_bos</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, int (<em>*validate</em>)(void *p, struct amdgpu_bo *bo), void<em>&nbsp;*param</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_validate_pt_bos" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the page table BOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>vm providing the BOs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*validate)(void</span> <span class="pre">*p,</span> <span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo)</span></code></dt>
<dd>callback to do the validation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*param</span></code></dt>
<dd>parameter for the validation callback</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validate the page table BOs on command submission if neccessary.</p>
<p><strong>Return</strong></p>
<p>Validation result.</p>
<dl class="function">
<dt id="c.amdgpu_vm_ready">
bool <code class="descname">amdgpu_vm_ready</code><span class="sig-paren">(</span>struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>check VM is ready for updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>VM to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if all VM PDs/PTs are ready for updates</p>
<p><strong>Return</strong></p>
<p>True if VM is not evicting.</p>
<dl class="function">
<dt id="c.amdgpu_vm_clear_bo">
int <code class="descname">amdgpu_vm_clear_bo</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, struct amdgpu_bo_vm<em>&nbsp;*vmbo</em>, bool<em>&nbsp;immediate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_clear_bo" title="Permalink to this definition">¶</a></dt>
<dd><p>initially clear the PDs/PTs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>VM to clear BO from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_vm</span> <span class="pre">*vmbo</span></code></dt>
<dd>BO to clear</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">immediate</span></code></dt>
<dd>use an immediate update</dd>
</dl>
<p><strong>Description</strong></p>
<p>Root PD needs to be reserved when calling this.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_pt_create">
int <code class="descname">amdgpu_vm_pt_create</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, int<em>&nbsp;level</em>, bool<em>&nbsp;immediate</em>, struct amdgpu_bo_vm<em>&nbsp;**vmbo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pt_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create bo for PD/PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requesting vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">level</span></code></dt>
<dd>the page table level</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">immediate</span></code></dt>
<dd>use a immediate update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_vm</span> <span class="pre">**vmbo</span></code></dt>
<dd>pointer to the buffer object pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_alloc_pts">
int <code class="descname">amdgpu_vm_alloc_pts</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, struct amdgpu_vm_pt_cursor<em>&nbsp;*cursor</em>, bool<em>&nbsp;immediate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_alloc_pts" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a specific page table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>VM to allocate page tables for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*cursor</span></code></dt>
<dd>Which page table to allocate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">immediate</span></code></dt>
<dd>use an immediate update</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure a specific page table or directory is allocated.</p>
<p><strong>Return</strong></p>
<p>1 if page table needed to be allocated, 0 if page table was already
allocated, negative errno if an error occurred.</p>
<dl class="function">
<dt id="c.amdgpu_vm_free_table">
void <code class="descname">amdgpu_vm_free_table</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base<em>&nbsp;*entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_free_table" title="Permalink to this definition">¶</a></dt>
<dd><p>fre one PD/PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*entry</span></code></dt>
<dd>PDE to free</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_free_pts">
void <code class="descname">amdgpu_vm_free_pts</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, struct amdgpu_vm_pt_cursor<em>&nbsp;*start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_free_pts" title="Permalink to this definition">¶</a></dt>
<dd><p>free PD/PT levels</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>amdgpu vm structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt_cursor</span> <span class="pre">*start</span></code></dt>
<dd>optional cursor where to start freeing PDs/PTs</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the page directory or page table level and all sub levels.</p>
<dl class="function">
<dt id="c.amdgpu_vm_check_compute_bug">
void <code class="descname">amdgpu_vm_check_compute_bug</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_check_compute_bug" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether asic has compute vm bug</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_need_pipeline_sync">
bool <code class="descname">amdgpu_vm_need_pipeline_sync</code><span class="sig-paren">(</span>struct amdgpu_ring<em>&nbsp;*ring</em>, struct amdgpu_job<em>&nbsp;*job</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_need_pipeline_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if pipe sync is needed for job.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_ring</span> <span class="pre">*ring</span></code></dt>
<dd>ring on which the job will be submitted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_job</span> <span class="pre">*job</span></code></dt>
<dd>job to submit</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if sync is needed.</p>
<dl class="function">
<dt id="c.amdgpu_vm_flush">
int <code class="descname">amdgpu_vm_flush</code><span class="sig-paren">(</span>struct amdgpu_ring<em>&nbsp;*ring</em>, struct amdgpu_job<em>&nbsp;*job</em>, bool<em>&nbsp;need_pipe_sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>hardware flush the vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_ring</span> <span class="pre">*ring</span></code></dt>
<dd>ring to use for flush</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_job</span> <span class="pre">*job</span></code></dt>
<dd>related job</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">need_pipe_sync</span></code></dt>
<dd>is pipe sync needed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Emit a VM flush when it is necessary.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_find">
struct amdgpu_bo_va * <code class="descname">amdgpu_vm_bo_find</code><span class="sig-paren">(</span>struct amdgpu_vm<em>&nbsp;*vm</em>, struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find the bo_va for a specific vm &amp; bo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>requested buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find <strong>bo</strong> inside the requested vm.
Search inside the <strong>bos</strong> vm list for the requested vm
Returns the found bo_va or NULL if none is found</p>
<p>Object has to be reserved!</p>
<p><strong>Return</strong></p>
<p>Found bo_va or NULL.</p>
<dl class="function">
<dt id="c.amdgpu_vm_map_gart">
uint64_t <code class="descname">amdgpu_vm_map_gart</code><span class="sig-paren">(</span>const dma_addr_t<em>&nbsp;*pages_addr</em>, uint64_t<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_map_gart" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve gart mapping of addr</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">dma_addr_t</span> <span class="pre">*pages_addr</span></code></dt>
<dd>optional DMA address to use for lookup</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>the unmapped addr</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look up the physical address of the page that the pte resolves
to.</p>
<p><strong>Return</strong></p>
<p>The pointer for the page table entry.</p>
<dl class="function">
<dt id="c.amdgpu_vm_update_pde">
int <code class="descname">amdgpu_vm_update_pde</code><span class="sig-paren">(</span>struct amdgpu_vm_update_params<em>&nbsp;*params</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, struct amdgpu_vm_bo_base<em>&nbsp;*entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_update_pde" title="Permalink to this definition">¶</a></dt>
<dd><p>update a single level in the hierarchy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_update_params</span> <span class="pre">*params</span></code></dt>
<dd>parameters for the update</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*entry</span></code></dt>
<dd>entry to update</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes sure the requested entry in parent is up to date.</p>
<dl class="function">
<dt id="c.amdgpu_vm_invalidate_pds">
void <code class="descname">amdgpu_vm_invalidate_pds</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_invalidate_pds" title="Permalink to this definition">¶</a></dt>
<dd><p>mark all PDs as invalid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>related vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all PD level as invalid after an error.</p>
<dl class="function">
<dt id="c.amdgpu_vm_update_pdes">
int <code class="descname">amdgpu_vm_update_pdes</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, bool<em>&nbsp;immediate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_update_pdes" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure that all directories are valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">immediate</span></code></dt>
<dd>submit immediately to the paging queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes sure all directories are up to date.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_fragment">
void <code class="descname">amdgpu_vm_fragment</code><span class="sig-paren">(</span>struct amdgpu_vm_update_params<em>&nbsp;*params</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;end</em>, uint64_t<em>&nbsp;flags</em>, unsigned int<em>&nbsp;*frag</em>, uint64_t<em>&nbsp;*frag_end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_fragment" title="Permalink to this definition">¶</a></dt>
<dd><p>get fragment for PTEs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_update_params</span> <span class="pre">*params</span></code></dt>
<dd>see amdgpu_vm_update_params definition</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>first PTE to handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">end</span></code></dt>
<dd>last PTE to handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>hw mapping flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*frag</span></code></dt>
<dd>resulting fragment size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">*frag_end</span></code></dt>
<dd>end of this fragment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the first possible fragment for the start and end address.</p>
<dl class="function">
<dt id="c.amdgpu_vm_update_ptes">
int <code class="descname">amdgpu_vm_update_ptes</code><span class="sig-paren">(</span>struct amdgpu_vm_update_params<em>&nbsp;*params</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;end</em>, uint64_t<em>&nbsp;dst</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_update_ptes" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure that page tables are valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm_update_params</span> <span class="pre">*params</span></code></dt>
<dd>see amdgpu_vm_update_params definition</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>start of GPU address range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">end</span></code></dt>
<dd>end of GPU address range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">dst</span></code></dt>
<dd>destination address to map to, the next dst inside the function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>mapping flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the page tables in the range <strong>start</strong> - <strong>end</strong>.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_update_mapping">
int <code class="descname">amdgpu_vm_bo_update_mapping</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_device<em>&nbsp;*bo_adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, bool<em>&nbsp;immediate</em>, bool<em>&nbsp;unlocked</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_resv" title="dma_resv">dma_resv</a><em>&nbsp;*resv</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;last</em>, uint64_t<em>&nbsp;flags</em>, uint64_t<em>&nbsp;offset</em>, struct <a class="reference internal" href="../drm-mm.html#c.ttm_resource" title="ttm_resource">ttm_resource</a><em>&nbsp;*res</em>, dma_addr_t<em>&nbsp;*pages_addr</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a><em>&nbsp;**fence</em>, bool<em>&nbsp;*table_freed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_update_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>update a mapping in the vm page table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer of the VM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*bo_adev</span></code></dt>
<dd>amdgpu_device pointer of the mapped BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">immediate</span></code></dt>
<dd>immediate submission in a page fault</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">unlocked</span></code></dt>
<dd>unlocked invalidation during MM callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*resv</span></code></dt>
<dd>fences we need to sync to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>start of mapped range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">last</span></code></dt>
<dd>last mapped entry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>flags for the entries</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt>
<dd>offset into nodes and pages_addr</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ttm_resource</span> <span class="pre">*res</span></code></dt>
<dd>ttm_resource to map</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*pages_addr</span></code></dt>
<dd>DMA addresses to use for mapping</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**fence</span></code></dt>
<dd>optional resulting fence</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*table_freed</span></code></dt>
<dd>return true if page table is freed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the page table entries between <strong>start</strong> and <strong>last</strong>.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_update">
int <code class="descname">amdgpu_vm_bo_update</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo_va<em>&nbsp;*bo_va</em>, bool<em>&nbsp;clear</em>, bool<em>&nbsp;*table_freed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update all BO mappings in the vm page table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*bo_va</span></code></dt>
<dd>requested BO and VM object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">clear</span></code></dt>
<dd>if true clear the entries</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*table_freed</span></code></dt>
<dd>return true if page table is freed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the page table entries for <strong>bo_va</strong>.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_update_prt_state">
void <code class="descname">amdgpu_vm_update_prt_state</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_update_prt_state" title="Permalink to this definition">¶</a></dt>
<dd><p>update the global PRT state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_prt_get">
void <code class="descname">amdgpu_vm_prt_get</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_get" title="Permalink to this definition">¶</a></dt>
<dd><p>add a PRT user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_prt_put">
void <code class="descname">amdgpu_vm_prt_put</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_put" title="Permalink to this definition">¶</a></dt>
<dd><p>drop a PRT user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_prt_cb">
void <code class="descname">amdgpu_vm_prt_cb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a><em>&nbsp;*fence</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_fence_cb" title="dma_fence_cb">dma_fence_cb</a><em>&nbsp;*_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>callback for updating the PRT status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt>
<dd>fence for the callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_cb</span> <span class="pre">*_cb</span></code></dt>
<dd>the callback function</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_add_prt_cb">
void <code class="descname">amdgpu_vm_add_prt_cb</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a><em>&nbsp;*fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_add_prt_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>add callback for updating the PRT status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt>
<dd>fence for the callback</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_free_mapping">
void <code class="descname">amdgpu_vm_free_mapping</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, struct amdgpu_bo_va_mapping<em>&nbsp;*mapping</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a><em>&nbsp;*fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_free_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>free a mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va_mapping</span> <span class="pre">*mapping</span></code></dt>
<dd>mapping to be freed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt>
<dd>fence of the unmap operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free a mapping and make sure we decrease the PRT usage count if applicable.</p>
<dl class="function">
<dt id="c.amdgpu_vm_prt_fini">
void <code class="descname">amdgpu_vm_prt_fini</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>finish all prt mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a cleanup callback to disable PRT support after VM dies.</p>
<dl class="function">
<dt id="c.amdgpu_vm_clear_freed">
int <code class="descname">amdgpu_vm_clear_freed</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, struct <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a><em>&nbsp;**fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_clear_freed" title="Permalink to this definition">¶</a></dt>
<dd><p>clear freed BOs in the PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**fence</span></code></dt>
<dd>optional resulting fence (unchanged if no work needed to be done
or if an error occurred)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure all freed BOs are cleared in the PT.
PTs have to be reserved and mutex must be locked!</p>
<p><strong>Return</strong></p>
<p>0 for success.</p>
<dl class="function">
<dt id="c.amdgpu_vm_handle_moved">
int <code class="descname">amdgpu_vm_handle_moved</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_handle_moved" title="Permalink to this definition">¶</a></dt>
<dd><p>handle moved BOs in the PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure all BOs which are moved are updated in the PTs.</p>
<p>PTs have to be reserved!</p>
<p><strong>Return</strong></p>
<p>0 for success.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_add">
struct amdgpu_bo_va * <code class="descname">amdgpu_vm_bo_add</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a bo to a specific vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>amdgpu buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add <strong>bo</strong> into the requested vm.
Add <strong>bo</strong> to the list of bos associated with the vm</p>
<p>Object has to be reserved!</p>
<p><strong>Return</strong></p>
<p>Newly added bo_va or NULL for failure</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_insert_map">
void <code class="descname">amdgpu_vm_bo_insert_map</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo_va<em>&nbsp;*bo_va</em>, struct amdgpu_bo_va_mapping<em>&nbsp;*mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_insert_map" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a new mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*bo_va</span></code></dt>
<dd>bo_va to store the address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va_mapping</span> <span class="pre">*mapping</span></code></dt>
<dd>the mapping to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new mapping into all structures.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_map">
int <code class="descname">amdgpu_vm_bo_map</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo_va<em>&nbsp;*bo_va</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;offset</em>, uint64_t<em>&nbsp;size</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_map" title="Permalink to this definition">¶</a></dt>
<dd><p>map bo inside a vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*bo_va</span></code></dt>
<dd>bo_va to store the address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>where to map the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt>
<dd>requested offset in the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>BO size in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>attributes of pages (read/write/valid/etc.)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a mapping of the BO at the specefied addr into the VM.</p>
<p>Object has to be reserved and unreserved outside!</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_replace_map">
int <code class="descname">amdgpu_vm_bo_replace_map</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo_va<em>&nbsp;*bo_va</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;offset</em>, uint64_t<em>&nbsp;size</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_replace_map" title="Permalink to this definition">¶</a></dt>
<dd><p>map bo inside a vm, replacing existing mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*bo_va</span></code></dt>
<dd>bo_va to store the address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>where to map the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt>
<dd>requested offset in the BO</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>BO size in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>attributes of pages (read/write/valid/etc.)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a mapping of the BO at the specefied addr into the VM. Replace existing
mappings as we do so.</p>
<p>Object has to be reserved and unreserved outside!</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_unmap">
int <code class="descname">amdgpu_vm_bo_unmap</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo_va<em>&nbsp;*bo_va</em>, uint64_t<em>&nbsp;saddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_unmap" title="Permalink to this definition">¶</a></dt>
<dd><p>remove bo mapping from vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*bo_va</span></code></dt>
<dd>bo_va to remove the address from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>where to the BO is mapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a mapping of the BO at the specefied addr from the VM.</p>
<p>Object has to be reserved and unreserved outside!</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_clear_mappings">
int <code class="descname">amdgpu_vm_bo_clear_mappings</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_clear_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all mappings in a specific range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>VM structure to use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>start of the range</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>size of the range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove all mappings in a range, split them as appropriate.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_lookup_mapping">
struct amdgpu_bo_va_mapping * <code class="descname">amdgpu_vm_bo_lookup_mapping</code><span class="sig-paren">(</span>struct amdgpu_vm<em>&nbsp;*vm</em>, uint64_t<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_lookup_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>find mapping by address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>the requested VM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>the address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a mapping by it’s address.</p>
<p><strong>Return</strong></p>
<p>The amdgpu_bo_va_mapping matching for addr or NULL</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_trace_cs">
void <code class="descname">amdgpu_vm_bo_trace_cs</code><span class="sig-paren">(</span>struct amdgpu_vm<em>&nbsp;*vm</em>, struct ww_acquire_ctx<em>&nbsp;*ticket</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_trace_cs" title="Permalink to this definition">¶</a></dt>
<dd><p>trace all reserved mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>the requested vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ticket</span></code></dt>
<dd>CS ticket</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trace all mappings of BOs reserved during a command submission.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_del">
void <code class="descname">amdgpu_vm_bo_del</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo_va<em>&nbsp;*bo_va</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a bo from a specific vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*bo_va</span></code></dt>
<dd>requested bo_va</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove <strong>bo_va-&gt;bo</strong> from the requested vm.</p>
<p>Object have to be reserved!</p>
<dl class="function">
<dt id="c.amdgpu_vm_evictable">
bool <code class="descname">amdgpu_vm_evictable</code><span class="sig-paren">(</span>struct amdgpu_bo<em>&nbsp;*bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_evictable" title="Permalink to this definition">¶</a></dt>
<dd><p>check if we can evict a VM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>A page table of the VM.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if it is possible to evict a VM.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_invalidate">
void <code class="descname">amdgpu_vm_bo_invalidate</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_bo<em>&nbsp;*bo</em>, bool<em>&nbsp;evicted</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the bo as invalid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo</span></code></dt>
<dd>amdgpu buffer object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">evicted</span></code></dt>
<dd>is the BO evicted</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark <strong>bo</strong> as invalid.</p>
<dl class="function">
<dt id="c.amdgpu_vm_get_block_size">
uint32_t <code class="descname">amdgpu_vm_get_block_size</code><span class="sig-paren">(</span>uint64_t<em>&nbsp;vm_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_get_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate VM page table size as power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">vm_size</span></code></dt>
<dd>VM size</dd>
</dl>
<p><strong>Return</strong></p>
<p>VM page table as power of two</p>
<dl class="function">
<dt id="c.amdgpu_vm_adjust_size">
void <code class="descname">amdgpu_vm_adjust_size</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, uint32_t<em>&nbsp;min_vm_size</em>, uint32_t<em>&nbsp;fragment_size_default</em>, unsigned<em>&nbsp;max_level</em>, unsigned<em>&nbsp;max_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_adjust_size" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust vm size, block size and fragment size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">min_vm_size</span></code></dt>
<dd>the minimum vm size in GB if it’s set auto</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">fragment_size_default</span></code></dt>
<dd>Default PTE fragment size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">max_level</span></code></dt>
<dd>max VMPT level</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">max_bits</span></code></dt>
<dd>max address space size in bits</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_wait_idle">
long <code class="descname">amdgpu_vm_wait_idle</code><span class="sig-paren">(</span>struct amdgpu_vm<em>&nbsp;*vm</em>, long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_wait_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for the VM to become idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>VM object to wait for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>timeout to wait for VM to become idle</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_init">
int <code class="descname">amdgpu_vm_init</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a vm instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Init <strong>vm</strong> fields.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_check_clean_reserved">
int <code class="descname">amdgpu_vm_check_clean_reserved</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_check_clean_reserved" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a VM is clean</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>the VM to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>check all entries of the root PD, if any subsequent PDs are allocated,
it means there are page table creating and filling, and is no a clean
VM</p>
<p><strong>Return</strong></p>
<blockquote>
<div>0 if this VM is clean</div></blockquote>
<dl class="function">
<dt id="c.amdgpu_vm_make_compute">
int <code class="descname">amdgpu_vm_make_compute</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_make_compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a GFX VM into a compute VM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>This only works on GFX VMs that don’t have any BOs added and no
page tables allocated yet.</p>
<p>Changes the following VM parameters:
- use_cpu_for_update
- pte_supports_ats</p>
<p>Reinitializes the page directory to reflect the changed ATS
setting.</p>
<p><strong>Return</strong></p>
<p>0 for success, -errno for errors.</p>
<dl class="function">
<dt id="c.amdgpu_vm_release_compute">
void <code class="descname">amdgpu_vm_release_compute</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_release_compute" title="Permalink to this definition">¶</a></dt>
<dd><p>release a compute vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>a vm turned into compute vm by calling amdgpu_vm_make_compute</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a correspondant of amdgpu_vm_make_compute. It decouples compute
pasid from vm. Compute should stop use of vm after this call.</p>
<dl class="function">
<dt id="c.amdgpu_vm_fini">
void <code class="descname">amdgpu_vm_fini</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a vm instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tear down <strong>vm</strong>.
Unbind the VM and remove all bos from the vm bo list</p>
<dl class="function">
<dt id="c.amdgpu_vm_manager_init">
void <code class="descname">amdgpu_vm_manager_init</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_manager_init" title="Permalink to this definition">¶</a></dt>
<dd><p>init the VM manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the VM manager structures</p>
<dl class="function">
<dt id="c.amdgpu_vm_manager_fini">
void <code class="descname">amdgpu_vm_manager_fini</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_manager_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup VM manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup the VM manager and free resources.</p>
<dl class="function">
<dt id="c.amdgpu_vm_ioctl">
int <code class="descname">amdgpu_vm_ioctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em>&nbsp;*dev</em>, void<em>&nbsp;*data</em>, struct <a class="reference internal" href="../drm-internals.html#c.drm_file" title="drm_file">drm_file</a><em>&nbsp;*filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages VMID reservation for vm hubs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt>
<dd>drm device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt>
<dd>drm_amdgpu_vm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*filp</span></code></dt>
<dd>drm file pointer</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -errno for errors.</p>
<dl class="function">
<dt id="c.amdgpu_vm_get_task_info">
void <code class="descname">amdgpu_vm_get_task_info</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, u32<em>&nbsp;pasid</em>, struct amdgpu_task_info<em>&nbsp;*task_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_get_task_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts task info for a PASID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>drm device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">pasid</span></code></dt>
<dd>PASID identifier for VM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_task_info</span> <span class="pre">*task_info</span></code></dt>
<dd>task_info to fill.</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_set_task_info">
void <code class="descname">amdgpu_vm_set_task_info</code><span class="sig-paren">(</span>struct amdgpu_vm<em>&nbsp;*vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_set_task_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets VMs task info.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>vm for which to set the info</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_handle_fault">
bool <code class="descname">amdgpu_vm_handle_fault</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, u32<em>&nbsp;pasid</em>, uint64_t<em>&nbsp;addr</em>, bool<em>&nbsp;write_fault</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_handle_fault" title="Permalink to this definition">¶</a></dt>
<dd><p>graceful handling of VM faults.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">pasid</span></code></dt>
<dd>PASID of the VM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>Address of the fault</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">write_fault</span></code></dt>
<dd>true is write fault, false is read fault</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to gracefully handle a VM fault. Return true if the fault was handled and
shouldn’t be reported any more.</p>
<dl class="function">
<dt id="c.amdgpu_debugfs_vm_bo_info">
void <code class="descname">amdgpu_debugfs_vm_bo_info</code><span class="sig-paren">(</span>struct amdgpu_vm<em>&nbsp;*vm</em>, struct seq_file<em>&nbsp;*m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_debugfs_vm_bo_info" title="Permalink to this definition">¶</a></dt>
<dd><p>print BO info for the VM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*vm</span></code></dt>
<dd>Requested VM for printing BO info</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m</span></code></dt>
<dd>debugfs file</dd>
</dl>
<p><strong>Description</strong></p>
<p>Print BO information in debugfs file for the VM</p>
</div>
<div class="section" id="interrupt-handling">
<h2>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h2>
<p>Interrupts generated within GPU hardware raise interrupt requests that are
passed to amdgpu IRQ handler which is responsible for detecting source and
type of the interrupt and dispatching matching handlers. If handling an
interrupt requires calling kernel functions that may sleep processing is
dispatched to work handlers.</p>
<p>If MSI functionality is not disabled by module parameter then MSI
support will be enabled.</p>
<p>For GPU interrupt sources that may be driven by another driver, IRQ domain
support is used (with mapping between virtual and hardware IRQs).</p>
<dl class="function">
<dt id="c.amdgpu_hotplug_work_func">
void <code class="descname">amdgpu_hotplug_work_func</code><span class="sig-paren">(</span>struct work_struct<em>&nbsp;*work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_hotplug_work_func" title="Permalink to this definition">¶</a></dt>
<dd><p>work handler for display hotplug event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt>
<dd>work struct pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the hotplug event work handler (all ASICs).
The work gets scheduled from the IRQ handler if there
was a hotplug interrupt.  It walks through the connector table
and calls hotplug handler for each connector. After this, it sends
a DRM hotplug event to alert userspace.</p>
<p>This design approach is required in order to defer hotplug event handling
from the IRQ handler to a work handler because hotplug handler has to use
mutexes which cannot be locked in an IRQ handler (since <a class="reference internal" href="../../kernel-hacking/locking.html#c.mutex_lock" title="mutex_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">mutex_lock</span></code></a> may
sleep).</p>
<dl class="function">
<dt id="c.amdgpu_irq_disable_all">
void <code class="descname">amdgpu_irq_disable_all</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>disable <em>all</em> interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable all types of interrupts from all sources.</p>
<dl class="function">
<dt id="c.amdgpu_irq_handler">
irqreturn_t <code class="descname">amdgpu_irq_handler</code><span class="sig-paren">(</span>int<em>&nbsp;irq</em>, void<em>&nbsp;*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>IRQ handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>IRQ number (unused)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt>
<dd>pointer to DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>IRQ handler for amdgpu driver (all ASICs).</p>
<p><strong>Return</strong></p>
<p>result of handling the IRQ, as defined by <code class="xref c c-type docutils literal notranslate"><span class="pre">irqreturn_t</span></code></p>
<dl class="function">
<dt id="c.amdgpu_irq_handle_ih1">
void <code class="descname">amdgpu_irq_handle_ih1</code><span class="sig-paren">(</span>struct work_struct<em>&nbsp;*work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_handle_ih1" title="Permalink to this definition">¶</a></dt>
<dd><p>kick of processing for IH1</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt>
<dd>work structure in struct amdgpu_irq</dd>
</dl>
<p><strong>Description</strong></p>
<p>Kick of processing IH ring 1.</p>
<dl class="function">
<dt id="c.amdgpu_irq_handle_ih2">
void <code class="descname">amdgpu_irq_handle_ih2</code><span class="sig-paren">(</span>struct work_struct<em>&nbsp;*work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_handle_ih2" title="Permalink to this definition">¶</a></dt>
<dd><p>kick of processing for IH2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt>
<dd>work structure in struct amdgpu_irq</dd>
</dl>
<p><strong>Description</strong></p>
<p>Kick of processing IH ring 2.</p>
<dl class="function">
<dt id="c.amdgpu_irq_handle_ih_soft">
void <code class="descname">amdgpu_irq_handle_ih_soft</code><span class="sig-paren">(</span>struct work_struct<em>&nbsp;*work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_handle_ih_soft" title="Permalink to this definition">¶</a></dt>
<dd><p>kick of processing for ih_soft</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt>
<dd>work structure in struct amdgpu_irq</dd>
</dl>
<p><strong>Description</strong></p>
<p>Kick of processing IH soft ring.</p>
<dl class="function">
<dt id="c.amdgpu_msi_ok">
bool <code class="descname">amdgpu_msi_ok</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_msi_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether MSI functionality is enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer (unused)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether MSI functionality has been disabled via module parameter
(all ASICs).</p>
<p><strong>Return</strong></p>
<p><em>true</em> if MSIs are allowed to be enabled or <em>false</em> otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_init">
int <code class="descname">amdgpu_irq_init</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize interrupt handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up work functions for hotplug and reset interrupts, enables MSI
functionality, initializes vblank, hotplug and reset interrupt handling.</p>
<p><strong>Return</strong></p>
<p>0 on success or error code on failure</p>
<dl class="function">
<dt id="c.amdgpu_irq_fini_sw">
void <code class="descname">amdgpu_irq_fini_sw</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_fini_sw" title="Permalink to this definition">¶</a></dt>
<dd><p>shut down interrupt handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tears down work functions for hotplug and reset interrupts, disables MSI
functionality, shuts down vblank, hotplug and reset interrupt handling,
turns off interrupts from all sources (all ASICs).</p>
<dl class="function">
<dt id="c.amdgpu_irq_add_id">
int <code class="descname">amdgpu_irq_add_id</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, unsigned<em>&nbsp;client_id</em>, unsigned<em>&nbsp;src_id</em>, struct amdgpu_irq_src<em>&nbsp;*source</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_add_id" title="Permalink to this definition">¶</a></dt>
<dd><p>register IRQ source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">client_id</span></code></dt>
<dd>client id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">src_id</span></code></dt>
<dd>source id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*source</span></code></dt>
<dd>IRQ source pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers IRQ source on a client.</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_dispatch">
void <code class="descname">amdgpu_irq_dispatch</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_ih_ring<em>&nbsp;*ih</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_dispatch" title="Permalink to this definition">¶</a></dt>
<dd><p>dispatch IRQ to IP blocks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_ih_ring</span> <span class="pre">*ih</span></code></dt>
<dd>interrupt ring instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dispatches IRQ to IP blocks.</p>
<dl class="function">
<dt id="c.amdgpu_irq_delegate">
void <code class="descname">amdgpu_irq_delegate</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_iv_entry<em>&nbsp;*entry</em>, unsigned int<em>&nbsp;num_dw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_delegate" title="Permalink to this definition">¶</a></dt>
<dd><p>delegate IV to soft IH ring</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_iv_entry</span> <span class="pre">*entry</span></code></dt>
<dd>IV entry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_dw</span></code></dt>
<dd>size of IV</dd>
</dl>
<p><strong>Description</strong></p>
<p>Delegate the IV to the soft IH ring and schedule processing of it. Used
if the hardware delegation to IH1 or IH2 doesn’t work for some reason.</p>
<dl class="function">
<dt id="c.amdgpu_irq_update">
int <code class="descname">amdgpu_irq_update</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_irq_src<em>&nbsp;*src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update hardware interrupt state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates interrupt state for the specific source (all ASICs).</p>
<dl class="function">
<dt id="c.amdgpu_irq_gpu_reset_resume_helper">
void <code class="descname">amdgpu_irq_gpu_reset_resume_helper</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_gpu_reset_resume_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>update interrupt states on all sources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates state of all types of interrupts on all sources on resume after
reset.</p>
<dl class="function">
<dt id="c.amdgpu_irq_get">
int <code class="descname">amdgpu_irq_get</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_irq_src<em>&nbsp;*src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_get" title="Permalink to this definition">¶</a></dt>
<dd><p>enable interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables specified type of interrupt on the specified source (all ASICs).</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_put">
int <code class="descname">amdgpu_irq_put</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_irq_src<em>&nbsp;*src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_put" title="Permalink to this definition">¶</a></dt>
<dd><p>disable interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables specified type of interrupt on the specified source (all ASICs).</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_enabled">
bool <code class="descname">amdgpu_irq_enabled</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, struct amdgpu_irq_src<em>&nbsp;*src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether interrupt is enabled or not</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the given type of interrupt is enabled on the given source.</p>
<p><strong>Return</strong></p>
<p><em>true</em> if interrupt is enabled, <em>false</em> if interrupt is disabled or on
invalid parameters</p>
<dl class="function">
<dt id="c.amdgpu_irqdomain_map">
int <code class="descname">amdgpu_irqdomain_map</code><span class="sig-paren">(</span>struct irq_domain<em>&nbsp;*d</em>, unsigned int<em>&nbsp;irq</em>, irq_hw_number_t<em>&nbsp;hwirq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irqdomain_map" title="Permalink to this definition">¶</a></dt>
<dd><p>create mapping between virtual and hardware IRQ numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt>
<dd>amdgpu IRQ domain pointer (unused)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>virtual IRQ number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt>
<dd>hardware irq number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Current implementation assigns simple interrupt handler to the given virtual
IRQ.</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_add_domain">
int <code class="descname">amdgpu_irq_add_domain</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_add_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>create a linear IRQ domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an IRQ domain for GPU interrupt sources
that may be driven by another driver (e.g., ACP).</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_remove_domain">
void <code class="descname">amdgpu_irq_remove_domain</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_remove_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the IRQ domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the IRQ domain for GPU interrupt sources
that may be driven by another driver (e.g., ACP).</p>
<dl class="function">
<dt id="c.amdgpu_irq_create_mapping">
unsigned <code class="descname">amdgpu_irq_create_mapping</code><span class="sig-paren">(</span>struct amdgpu_device<em>&nbsp;*adev</em>, unsigned<em>&nbsp;src_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_create_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>create mapping between domain Linux IRQs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">src_id</span></code></dt>
<dd>IH source id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates mapping between a domain IRQ (GPU IH src id) and a Linux IRQ
Use this for components that generate a GPU interrupt, but are driven
by a different driver (e.g., ACP).</p>
<p><strong>Return</strong></p>
<p>Linux IRQ</p>
</div>
<div class="section" id="ip-blocks">
<h2>IP Blocks<a class="headerlink" href="#ip-blocks" title="Permalink to this headline">¶</a></h2>
<p>GPUs are composed of IP (intellectual property) blocks. These
IP blocks provide various functionalities: display, graphics,
video decode, etc. The IP blocks that comprise a particular GPU
are listed in the GPU’s respective SoC file. amdgpu_device.c
acquires the list of IP blocks for the GPU in use on initialization.
It can then operate on this list to perform standard driver operations
such as: init, fini, suspend, resume, etc.</p>
<p>IP block implementations are named using the following convention:
&lt;functionality&gt;_v&lt;version&gt; (E.g.: gfx_v6_0).</p>
<dl class="type">
<dt id="c.amd_ip_block_type">
enum <code class="descname">amd_ip_block_type</code><a class="headerlink" href="#c.amd_ip_block_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to classify IP blocks by functionality.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_COMMON</span></code></dt>
<dd>GPU Family</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_GMC</span></code></dt>
<dd>Graphics Memory Controller</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_IH</span></code></dt>
<dd>Interrupt Handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_SMC</span></code></dt>
<dd>System Management Controller</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_PSP</span></code></dt>
<dd>Platform Security Processor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_DCE</span></code></dt>
<dd>Display and Compositing Engine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_GFX</span></code></dt>
<dd>Graphics and Compute Engine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_SDMA</span></code></dt>
<dd>System DMA Engine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_UVD</span></code></dt>
<dd>Unified Video Decoder</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_VCE</span></code></dt>
<dd>Video Compression Engine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_ACP</span></code></dt>
<dd>Audio Co-Processor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_VCN</span></code></dt>
<dd>Video Core/Codec Next</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_MES</span></code></dt>
<dd>Micro-Engine Scheduler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_JPEG</span></code></dt>
<dd>JPEG Engine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AMD_IP_BLOCK_TYPE_NUM</span></code></dt>
<dd>Total number of IP block types</dd>
</dl>
<dl class="type">
<dt id="c.amd_ip_funcs">
struct <code class="descname">amd_ip_funcs</code><a class="headerlink" href="#c.amd_ip_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>general hooks for managing amdgpu IP Blocks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amd_ip_funcs {
  char *name;
  int (*early_init)(void *handle);
  int (*late_init)(void *handle);
  int (*sw_init)(void *handle);
  int (*sw_fini)(void *handle);
  int (*early_fini)(void *handle);
  int (*hw_init)(void *handle);
  int (*hw_fini)(void *handle);
  void (*late_fini)(void *handle);
  int (*suspend)(void *handle);
  int (*resume)(void *handle);
  bool (*is_idle)(void *handle);
  int (*wait_for_idle)(void *handle);
  bool (*check_soft_reset)(void *handle);
  int (*pre_soft_reset)(void *handle);
  int (*soft_reset)(void *handle);
  int (*post_soft_reset)(void *handle);
  int (*set_clockgating_state)(void *handle, enum amd_clockgating_state state);
  int (*set_powergating_state)(void *handle, enum amd_powergating_state state);
  void (*get_clockgating_state)(void *handle, u32 *flags);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>Name of IP block</dd>
<dt><code class="docutils literal notranslate"><span class="pre">early_init</span></code></dt>
<dd>sets up early driver state (pre sw_init),
does not configure hw - Optional</dd>
<dt><code class="docutils literal notranslate"><span class="pre">late_init</span></code></dt>
<dd>sets up late driver/hw state (post hw_init) - Optional</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw_init</span></code></dt>
<dd>sets up driver state, does not configure hw</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw_fini</span></code></dt>
<dd>tears down driver state, does not configure hw</dd>
<dt><code class="docutils literal notranslate"><span class="pre">early_fini</span></code></dt>
<dd>tears down stuff before dev detached from driver</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_init</span></code></dt>
<dd>sets up the hw state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_fini</span></code></dt>
<dd>tears down the hw state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">late_fini</span></code></dt>
<dd>final cleanup</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt>
<dd>handles IP specific hw/sw changes for suspend</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt>
<dd>handles IP specific hw/sw changes for resume</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_idle</span></code></dt>
<dd>returns current IP block idle status</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_for_idle</span></code></dt>
<dd>poll for idle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">check_soft_reset</span></code></dt>
<dd>check soft reset the IP block</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pre_soft_reset</span></code></dt>
<dd>pre soft reset the IP block</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_reset</span></code></dt>
<dd>soft reset the IP block</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_soft_reset</span></code></dt>
<dd>post soft reset the IP block</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_clockgating_state</span></code></dt>
<dd>enable/disable cg for the IP block</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_powergating_state</span></code></dt>
<dd>enable/disable pg for the IP block</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_clockgating_state</span></code></dt>
<dd>get current clockgating status</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks provide an interface for controlling the operational state
of IP blocks. After acquiring a list of IP blocks for the GPU in use,
the driver can make chip-wide state changes by walking this list and
making calls to hooks from each IP block. This list is ordered to ensure
that the driver initializes the IP blocks in a safe sequence.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="display/index.html" class="btn btn-neutral float-right" title="drm/amd/display - Display Core (DC)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="module-parameters.html" class="btn btn-neutral" title="Module Parameters" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>