

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DRM Driver uAPI &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developer’s Guide" href="index.html"/>
        <link rel="next" title="Kernel clients" href="drm-client.html"/>
        <link rel="prev" title="Userland interfaces" href="drm-uapi.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">DRM Driver uAPI</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#drm-i915-uapi">drm/i915 uAPI</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-client.html">Kernel clients</a></li>
<li class="toctree-l2"><a class="reference internal" href="drivers.html">GPU Driver Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight.html">Backlight support</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfc/index.html">GPU RFC Section</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux GPU Driver Developer’s Guide</a> &raquo;</li>
        
      <li>DRM Driver uAPI</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/driver-uapi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="drm-driver-uapi">
<h1>DRM Driver uAPI<a class="headerlink" href="#drm-driver-uapi" title="Permalink to this headline">¶</a></h1>
<div class="section" id="drm-i915-uapi">
<h2>drm/i915 uAPI<a class="headerlink" href="#drm-i915-uapi" title="Permalink to this headline">¶</a></h2>
<p id="uevents-generated-by-i915-on-it-s-device-node"><strong>uevents generated by i915 on it’s device node</strong></p>
<dl class="docutils">
<dt>I915_L3_PARITY_UEVENT - Generated when the driver receives a parity mismatch</dt>
<dd>event from the gpu l3 cache. Additional information supplied is ROW,
BANK, SUBBANK, SLICE of the affected cacheline. Userspace should keep
track of these events and if a specific cache-line seems to have a
persistent error remap it with the l3 remapping tool supplied in
intel-gpu-tools.  The value supplied with the event is always 1.</dd>
<dt>I915_ERROR_UEVENT - Generated upon error detection, currently only via</dt>
<dd>hangcheck. The error detection event is a good indicator of when things
began to go badly. The value supplied with the event is a 1 upon error
detection, and a 0 upon reset completion, signifying no more error
exists. NOTE: Disabling hangcheck or reset via module parameter will
cause the related events to not be seen.</dd>
<dt>I915_RESET_UEVENT - Event is generated just before an attempt to reset the</dt>
<dd>GPU. The value supplied with the event is always 1. NOTE: Disable
reset via module parameter will cause this event to not be seen.</dd>
</dl>
<dl class="type">
<dt id="c.i915_user_extension">
struct <code class="descname">i915_user_extension</code><a class="headerlink" href="#c.i915_user_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for defining a chain of extensions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_user_extension {
  __u64 next_extension;
  __u32 name;
  __u32 flags;
  __u32 rsvd[4];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">next_extension</span></code></dt>
<dd>Pointer to the next <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>, or zero if the end.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd><p class="first">Name of the extension.</p>
<p>Note that the name here is just some integer.</p>
<p class="last">Also note that the name space for this is not global for the whole
driver, but rather its scope/meaning is limited to the specific piece
of uAPI which has embedded the <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd><p class="first">MBZ</p>
<p class="last">All undefined bits must be zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt>
<dd><p class="first">MBZ</p>
<p class="last">Reserved for future use; must be zero.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Many interfaces need to grow over time. In most cases we can simply
extend the struct and have userspace pass in more data. Another option,
as demonstrated by Vulkan’s approach to providing extensions for forward
and backward compatibility, is to use a list of optional structs to
provide those extra details.</p>
<p>The key advantage to using an extension chain is that it allows us to
redefine the interface more easily than an ever growing struct of
increasing complexity, and for large parts of that interface to be
entirely optional. The downside is more pointer chasing; chasing across
the __user boundary with pointers encapsulated inside u64.</p>
<p>Example chaining:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">i915_user_extension</span> <span class="n">ext3</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">next_extension</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// end</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">...,</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">i915_user_extension</span> <span class="n">ext2</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">next_extension</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext3</span><span class="p">,</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">...,</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">i915_user_extension</span> <span class="n">ext1</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">next_extension</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext2</span><span class="p">,</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">...,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Typically the <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a> would be embedded in some uAPI
struct, and in this case we would feed it the head of the chain(i.e ext1),
which would then apply all of the above extensions.</p>
<p id="perf-events-exposed-by-i915-through-sys-bus-event-sources-drivers-i915"><strong>perf_events exposed by i915 through /sys/bus/event_sources/drivers/i915</strong></p>
<dl class="type">
<dt id="c.drm_i915_gem_mmap_offset">
struct <code class="descname">drm_i915_gem_mmap_offset</code><a class="headerlink" href="#c.drm_i915_gem_mmap_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an offset so we can mmap this buffer object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_mmap_offset {
  __u32 handle;
  __u32 pad;
  __u64 offset;
  __u64 flags;
#define I915_MMAP_OFFSET_GTT    0;
#define I915_MMAP_OFFSET_WC     1;
#define I915_MMAP_OFFSET_WB     2;
#define I915_MMAP_OFFSET_UC     3;
#define I915_MMAP_OFFSET_FIXED  4;
  __u64 extensions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt>
<dd>Handle for the object being mapped.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt>
<dd>Must be zero</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt>
<dd><p class="first">The fake offset to use for subsequent mmap call</p>
<p class="last">This is a fixed-size type for 32/64 compatibility.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd><p class="first">Flags for extended behaviour.</p>
<p>It is mandatory that one of the <cite>MMAP_OFFSET</cite> types
should be included:</p>
<ul class="simple">
<li><cite>I915_MMAP_OFFSET_GTT</cite>: Use mmap with the object bound to GTT. (Write-Combined)</li>
<li><cite>I915_MMAP_OFFSET_WC</cite>: Use Write-Combined caching.</li>
<li><cite>I915_MMAP_OFFSET_WB</cite>: Use Write-Back caching.</li>
<li><cite>I915_MMAP_OFFSET_FIXED</cite>: Use object placement to determine caching.</li>
</ul>
<p>On devices with local memory <cite>I915_MMAP_OFFSET_FIXED</cite> is the only valid
type. On devices without local memory, this caching mode is invalid.</p>
<p class="last">As caching mode when specifying <cite>I915_MMAP_OFFSET_FIXED</cite>, WC or WB will
be used, depending on the object placement on creation. WB will be used
when the object can only exist in system memory, WC otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt>
<dd><p class="first">Zero-terminated chain of extensions.</p>
<p class="last">No current extensions defined; mbz.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct is passed as argument to the <cite>DRM_IOCTL_I915_GEM_MMAP_OFFSET</cite> ioctl,
and is used to retrieve the fake offset to mmap an object specified by <code class="xref c c-type docutils literal notranslate"><span class="pre">handle</span></code>.</p>
<p>The legacy way of using <cite>DRM_IOCTL_I915_GEM_MMAP</cite> is removed on gen12+.
<cite>DRM_IOCTL_I915_GEM_MMAP_GTT</cite> is an older supported alias to this struct, but will behave
as setting the <code class="xref c c-type docutils literal notranslate"><span class="pre">extensions</span></code> to 0, and <code class="xref c c-type docutils literal notranslate"><span class="pre">flags</span></code> to <cite>I915_MMAP_OFFSET_GTT</cite>.</p>
<dl class="type">
<dt id="c.drm_i915_gem_set_domain">
struct <code class="descname">drm_i915_gem_set_domain</code><a class="headerlink" href="#c.drm_i915_gem_set_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust the objects write or read domain, in preparation for accessing the pages via some CPU domain.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_set_domain {
  __u32 handle;
  __u32 read_domains;
  __u32 write_domain;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt>
<dd>Handle for the object.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_domains</span></code></dt>
<dd>New read domains.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_domain</span></code></dt>
<dd><p class="first">New write domain.</p>
<p class="last">Note that having something in the write domain implies it’s in the
read domain, and only that read domain.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Specifying a new write or read domain will flush the object out of the
previous domain(if required), before then updating the objects domain
tracking with the new domain.</p>
<p>Note this might involve waiting for the object first if it is still active on
the GPU.</p>
<p>Supported values for <strong>read_domains</strong> and <strong>write_domain</strong>:</p>
<blockquote>
<div><ul class="simple">
<li>I915_GEM_DOMAIN_WC: Uncached write-combined domain</li>
<li>I915_GEM_DOMAIN_CPU: CPU cache domain</li>
<li>I915_GEM_DOMAIN_GTT: Mappable aperture domain</li>
</ul>
</div></blockquote>
<p>All other domains are rejected.</p>
<p>Note that for discrete, starting from DG1, this is no longer supported, and
is instead rejected. On such platforms the CPU domain is effectively static,
where we also only support a single <a class="reference internal" href="#c.drm_i915_gem_mmap_offset" title="drm_i915_gem_mmap_offset"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_mmap_offset</span></code></a> cache mode,
which can’t be set explicitly and instead depends on the object placements,
as per the below.</p>
<p>Implicit caching rules, starting from DG1:</p>
<blockquote>
<div><ul class="simple">
<li>If any of the object placements (see <a class="reference internal" href="#c.drm_i915_gem_create_ext_memory_regions" title="drm_i915_gem_create_ext_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext_memory_regions</span></code></a>)
contain I915_MEMORY_CLASS_DEVICE then the object will be allocated and
mapped as write-combined only.</li>
<li>Everything else is always allocated and mapped as write-back, with the
guarantee that everything is also coherent with the GPU.</li>
</ul>
</div></blockquote>
<p>Note that this is likely to change in the future again, where we might need
more flexibility on future devices, so making this all explicit as part of a
new <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext</span></code></a> extension is probable.</p>
<dl class="type">
<dt id="c.drm_i915_gem_caching">
struct <code class="descname">drm_i915_gem_caching</code><a class="headerlink" href="#c.drm_i915_gem_caching" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or get the caching for given object handle.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_caching {
  __u32 handle;
#define I915_CACHING_NONE               0;
#define I915_CACHING_CACHED             1;
#define I915_CACHING_DISPLAY            2;
  __u32 caching;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt>
<dd>Handle of the buffer to set/get the caching level.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caching</span></code></dt>
<dd><p class="first">The GTT caching level to apply or possible return value.</p>
<p>The supported <strong>caching</strong> values:</p>
<p>I915_CACHING_NONE:</p>
<p>GPU access is not coherent with CPU caches.  Default for machines
without an LLC. This means manual flushing might be needed, if we
want GPU access to be coherent.</p>
<p>I915_CACHING_CACHED:</p>
<p>GPU access is coherent with CPU caches and furthermore the data is
cached in last-level caches shared between CPU cores and the GPU GT.</p>
<p>I915_CACHING_DISPLAY:</p>
<p class="last">Special GPU caching mode which is coherent with the scanout engines.
Transparently falls back to I915_CACHING_NONE on platforms where no
special cache mode (like write-through or gfdt flushing) is
available. The kernel automatically sets this mode when using a
buffer as a scanout target.  Userspace can manually set this mode to
avoid a costly stall and clflush in the hotpath of drawing the first
frame.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow userspace to control the GTT caching bits for a given object when the
object is later mapped through the ppGTT(or GGTT on older platforms lacking
ppGTT support, or if the object is used for scanout). Note that this might
require unbinding the object from the GTT first, if its current caching value
doesn’t match.</p>
<p>Note that this all changes on discrete platforms, starting from DG1, the
set/get caching is no longer supported, and is now rejected.  Instead the CPU
caching attributes(WB vs WC) will become an immutable creation time property
for the object, along with the GTT caching level. For now we don’t expose any
new uAPI for this, instead on DG1 this is all implicit, although this largely
shouldn’t matter since DG1 is coherent by default(without any way of
controlling it).</p>
<p>Implicit caching rules, starting from DG1:</p>
<blockquote>
<div><ul class="simple">
<li>If any of the object placements (see <a class="reference internal" href="#c.drm_i915_gem_create_ext_memory_regions" title="drm_i915_gem_create_ext_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext_memory_regions</span></code></a>)
contain I915_MEMORY_CLASS_DEVICE then the object will be allocated and
mapped as write-combined only.</li>
<li>Everything else is always allocated and mapped as write-back, with the
guarantee that everything is also coherent with the GPU.</li>
</ul>
</div></blockquote>
<p>Note that this is likely to change in the future again, where we might need
more flexibility on future devices, so making this all explicit as part of a
new <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext</span></code></a> extension is probable.</p>
<p>Side note: Part of the reason for this is that changing the at-allocation-time CPU
caching attributes for the pages might be required(and is expensive) if we
need to then CPU map the pages later with different caching attributes. This
inconsistent caching behaviour, while supported on x86, is not universally
supported on other architectures. So for simplicity we opt for setting
everything at creation time, whilst also making it immutable, on discrete
platforms.</p>
<p id="virtual-engine-uapi"><strong>Virtual Engine uAPI</strong></p>
<p>Virtual engine is a concept where userspace is able to configure a set of
physical engines, submit a batch buffer, and let the driver execute it on any
engine from the set as it sees fit.</p>
<p>This is primarily useful on parts which have multiple instances of a same
class engine, like for example GT3+ Skylake parts with their two VCS engines.</p>
<p>For instance userspace can enumerate all engines of a certain class using the
previously described <a class="reference internal" href="#engine-discovery-uapi">Engine Discovery uAPI</a>. After that userspace can
create a GEM context with a placeholder slot for the virtual engine (using
<cite>I915_ENGINE_CLASS_INVALID</cite> and <cite>I915_ENGINE_CLASS_INVALID_NONE</cite> for class
and instance respectively) and finally using the
<cite>I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE</cite> extension place a virtual engine in
the same reserved slot.</p>
<p>Example of creating a virtual engine and submitting a batch buffer to it:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">I915_DEFINE_CONTEXT_ENGINES_LOAD_BALANCE</span><span class="p">(</span><span class="n">virtual</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE</span><span class="p">,</span>
        <span class="p">.</span><span class="n">engine_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// Place this virtual engine into engine map slot 0</span>
        <span class="p">.</span><span class="n">num_siblings</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">.</span><span class="n">engines</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="n">I915_ENGINE_CLASS_VIDEO</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
                     <span class="p">{</span> <span class="n">I915_ENGINE_CLASS_VIDEO</span><span class="p">,</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">I915_DEFINE_CONTEXT_PARAM_ENGINES</span><span class="p">(</span><span class="n">engines</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">engines</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="n">I915_ENGINE_CLASS_INVALID</span><span class="p">,</span>
                       <span class="n">I915_ENGINE_CLASS_INVALID_NONE</span> <span class="p">}</span> <span class="p">},</span>
        <span class="p">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virtual</span><span class="p">),</span> <span class="c1">// Chains after load_balance extension</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">drm_i915_gem_context_create_ext_setparam</span> <span class="n">p_engines</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">I915_CONTEXT_CREATE_EXT_SETPARAM</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">.</span><span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">param</span> <span class="o">=</span> <span class="n">I915_CONTEXT_PARAM_ENGINES</span><span class="p">,</span>
                <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engines</span><span class="p">),</span>
                <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">engines</span><span class="p">),</span>
        <span class="p">},</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">drm_i915_gem_context_create_ext</span> <span class="n">create</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS</span><span class="p">,</span>
        <span class="p">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_engines</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">ctx_id</span> <span class="o">=</span> <span class="n">gem_context_create_ext</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">create</span><span class="p">);</span>

<span class="c1">// Now we have created a GEM context with its engine map containing a</span>
<span class="c1">// single virtual engine. Submissions to this slot can go either to</span>
<span class="c1">// vcs0 or vcs1, depending on the load balancing algorithm used inside</span>
<span class="c1">// the driver. The load balancing is dynamic from one batch buffer to</span>
<span class="c1">// another and transparent to userspace.</span>

<span class="p">...</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">rsvd1</span> <span class="o">=</span> <span class="n">ctx_id</span><span class="p">;</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Submits to index 0 which is the virtual engine</span>
<span class="n">gem_execbuf</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">execbuf</span><span class="p">);</span>
</pre></div>
</div>
<dl class="type">
<dt id="c.i915_context_engines_parallel_submit">
struct <code class="descname">i915_context_engines_parallel_submit</code><a class="headerlink" href="#c.i915_context_engines_parallel_submit" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure engine for parallel submission.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_context_engines_parallel_submit {
  struct i915_user_extension base;
  __u16 engine_index;
  __u16 width;
  __u16 num_siblings;
  __u16 mbz16;
  __u64 flags;
  __u64 mbz64[3];
  struct i915_engine_class_instance engines[0];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt>
<dd>base user extension.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engine_index</span></code></dt>
<dd>slot for parallel engine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code></dt>
<dd>number of contexts per parallel engine or in other words the
number of batches in each submission</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_siblings</span></code></dt>
<dd>number of siblings per context or in other words the
number of possible placements for each submission</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mbz16</span></code></dt>
<dd>reserved for future use; must be zero</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>all undefined flags must be zero, currently not defined flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mbz64</span></code></dt>
<dd>reserved for future use; must be zero</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engines</span></code></dt>
<dd><p class="first">2-d array of engine instances to configure parallel engine</p>
<p class="last">length = width (i) * num_siblings (j)
index = j + i * num_siblings</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup a slot in the context engine map to allow multiple BBs to be submitted
in a single execbuf IOCTL. Those BBs will then be scheduled to run on the GPU
in parallel. Multiple hardware contexts are created internally in the i915 to
run these BBs. Once a slot is configured for N BBs only N BBs can be
submitted in each execbuf IOCTL and this is implicit behavior e.g. The user
doesn’t tell the execbuf IOCTL there are N BBs, the execbuf IOCTL knows how
many BBs there are based on the slot’s configuration. The N BBs are the last
N buffer objects or first N if I915_EXEC_BATCH_FIRST is set.</p>
<p>The default placement behavior is to create implicit bonds between each
context if each context maps to more than 1 physical engine (e.g. context is
a virtual engine). Also we only allow contexts of same engine class and these
contexts must be in logically contiguous order. Examples of the placement
behavior are described below. Lastly, the default is to not allow BBs to be
preempted mid-batch. Rather insert coordinated preemption points on all
hardware contexts between each set of BBs. Flags could be added in the future
to change both of these default behaviors.</p>
<p>Returns -EINVAL if hardware context placement configuration is invalid or if
the placement configuration isn’t supported on the platform / submission
interface.
Returns -ENODEV if extension isn’t supported on the platform / submission
interface.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Examples syntax:
CS[X] = generic engine of same class, logical instance X
INVALID = I915_ENGINE_CLASS_INVALID, I915_ENGINE_CLASS_INVALID_NONE

Example 1 pseudo code:
set_engines(INVALID)
set_parallel(engine_index=0, width=2, num_siblings=1,
             engines=CS[0],CS[1])

Results in the following valid placement:
CS[0], CS[1]

Example 2 pseudo code:
set_engines(INVALID)
set_parallel(engine_index=0, width=2, num_siblings=2,
             engines=CS[0],CS[2],CS[1],CS[3])

Results in the following valid placements:
CS[0], CS[1]
CS[2], CS[3]

This can be thought of as two virtual engines, each containing two
engines thereby making a 2D array. However, there are bonds tying the
entries together and placing restrictions on how they can be scheduled.
Specifically, the scheduler can choose only vertical columns from the 2D
array. That is, CS[0] is bonded to CS[1] and CS[2] to CS[3]. So if the
scheduler wants to submit to CS[0], it must also choose CS[1] and vice
versa. Same for CS[2] requires also using CS[3].
VE[0] = CS[0], CS[2]
VE[1] = CS[1], CS[3]

Example 3 pseudo code:
set_engines(INVALID)
set_parallel(engine_index=0, width=2, num_siblings=2,
             engines=CS[0],CS[1],CS[1],CS[3])

Results in the following valid and invalid placements:
CS[0], CS[1]
CS[1], CS[3] - Not logically contiguous, return -EINVAL
</pre></div>
</div>
<p id="context-engine-map-uapi"><strong>Context Engine Map uAPI</strong></p>
<p>Context engine map is a new way of addressing engines when submitting batch-
buffers, replacing the existing way of using identifiers like <cite>I915_EXEC_BLT</cite>
inside the flags field of <cite>struct drm_i915_gem_execbuffer2</cite>.</p>
<p>To use it created GEM contexts need to be configured with a list of engines
the user is intending to submit to. This is accomplished using the
<cite>I915_CONTEXT_PARAM_ENGINES</cite> parameter and <cite>struct
i915_context_param_engines</cite>.</p>
<p>For such contexts the <cite>I915_EXEC_RING_MASK</cite> field becomes an index into the
configured map.</p>
<p>Example of creating such context and submitting against it:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">I915_DEFINE_CONTEXT_PARAM_ENGINES</span><span class="p">(</span><span class="n">engines</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">engines</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="n">I915_ENGINE_CLASS_RENDER</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
                     <span class="p">{</span> <span class="n">I915_ENGINE_CLASS_COPY</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">drm_i915_gem_context_create_ext_setparam</span> <span class="n">p_engines</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">I915_CONTEXT_CREATE_EXT_SETPARAM</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">.</span><span class="n">param</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">param</span> <span class="o">=</span> <span class="n">I915_CONTEXT_PARAM_ENGINES</span><span class="p">,</span>
                <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engines</span><span class="p">),</span>
                <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">engines</span><span class="p">),</span>
        <span class="p">},</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">drm_i915_gem_context_create_ext</span> <span class="n">create</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS</span><span class="p">,</span>
        <span class="p">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_engines</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">ctx_id</span> <span class="o">=</span> <span class="n">gem_context_create_ext</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">create</span><span class="p">);</span>

<span class="c1">// We have now created a GEM context with two engines in the map:</span>
<span class="c1">// Index 0 points to rcs0 while index 1 points to bcs0. Other engines</span>
<span class="c1">// will not be accessible from this context.</span>

<span class="p">...</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">rsvd1</span> <span class="o">=</span> <span class="n">ctx_id</span><span class="p">;</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Submits to index 0, which is rcs0 for this context</span>
<span class="n">gem_execbuf</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">execbuf</span><span class="p">);</span>

<span class="p">...</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">rsvd1</span> <span class="o">=</span> <span class="n">ctx_id</span><span class="p">;</span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Submits to index 0, which is bcs0 for this context</span>
<span class="n">gem_execbuf</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">execbuf</span><span class="p">);</span>
</pre></div>
</div>
<dl class="type">
<dt id="c.drm_i915_gem_userptr">
struct <code class="descname">drm_i915_gem_userptr</code><a class="headerlink" href="#c.drm_i915_gem_userptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Create GEM object from user allocated memory.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_userptr {
  __u64 user_ptr;
  __u64 user_size;
  __u32 flags;
#define I915_USERPTR_READ_ONLY 0x1;
#define I915_USERPTR_PROBE 0x2;
#define I915_USERPTR_UNSYNCHRONIZED 0x80000000;
  __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">user_ptr</span></code></dt>
<dd><p class="first">The pointer to the allocated memory.</p>
<p class="last">Needs to be aligned to PAGE_SIZE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">user_size</span></code></dt>
<dd><p class="first">The size in bytes for the allocated memory. This will also become the
object size.</p>
<p class="last">Needs to be aligned to PAGE_SIZE, and should be at least PAGE_SIZE,
or larger.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd><p class="first">Supported flags:</p>
<p>I915_USERPTR_READ_ONLY:</p>
<p>Mark the object as readonly, this also means GPU access can only be
readonly. This is only supported on HW which supports readonly access
through the GTT. If the HW can’t support readonly access, an error is
returned.</p>
<p>I915_USERPTR_PROBE:</p>
<p>Probe the provided <strong>user_ptr</strong> range and validate that the <strong>user_ptr</strong> is
indeed pointing to normal memory and that the range is also valid.
For example if some garbage address is given to the kernel, then this
should complain.</p>
<p>Returns -EFAULT if the probe failed.</p>
<p>Note that this doesn’t populate the backing pages, and also doesn’t
guarantee that the object will remain valid when the object is
eventually used.</p>
<p>The kernel supports this feature if I915_PARAM_HAS_USERPTR_PROBE
returns a non-zero value.</p>
<p>I915_USERPTR_UNSYNCHRONIZED:</p>
<p class="last">NOT USED. Setting this flag will result in an error.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt>
<dd><p class="first">Returned handle for the object.</p>
<p class="last">Object handles are nonzero.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Userptr objects have several restrictions on what ioctls can be used with the
object handle.</p>
<dl class="type">
<dt id="c.drm_i915_query_item">
struct <code class="descname">drm_i915_query_item</code><a class="headerlink" href="#c.drm_i915_query_item" title="Permalink to this definition">¶</a></dt>
<dd><p>An individual query for the kernel to process.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_item {
  __u64 query_id;
#define DRM_I915_QUERY_TOPOLOGY_INFO    1;
#define DRM_I915_QUERY_ENGINE_INFO      2;
#define DRM_I915_QUERY_PERF_CONFIG      3;
#define DRM_I915_QUERY_MEMORY_REGIONS   4;
  __s32 length;
  __u32 flags;
#define DRM_I915_QUERY_PERF_CONFIG_LIST          1;
#define DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID 2;
#define DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID   3;
  __u64 data_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">query_id</span></code></dt>
<dd>The id for this query</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt>
<dd>When set to zero by userspace, this is filled with the size of the
data to be written at the <strong>data_ptr</strong> pointer. The kernel sets this
value to a negative value to signal an error on a particular query
item.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd><p class="first">When query_id == DRM_I915_QUERY_TOPOLOGY_INFO, must be 0.</p>
<p>When query_id == DRM_I915_QUERY_PERF_CONFIG, must be one of the
following:</p>
<blockquote class="last">
<div><ul class="simple">
<li>DRM_I915_QUERY_PERF_CONFIG_LIST</li>
<li>DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID</li>
<li>DRM_I915_QUERY_PERF_CONFIG_FOR_UUID</li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_ptr</span></code></dt>
<dd>Data will be written at the location pointed by <strong>data_ptr</strong> when the
value of <strong>length</strong> matches the length of the data to be written by the
kernel.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The behaviour is determined by the <strong>query_id</strong>. Note that exactly what
<strong>data_ptr</strong> is also depends on the specific <strong>query_id</strong>.</p>
<dl class="type">
<dt id="c.drm_i915_query">
struct <code class="descname">drm_i915_query</code><a class="headerlink" href="#c.drm_i915_query" title="Permalink to this definition">¶</a></dt>
<dd><p>Supply an array of <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_item</span></code></a> for the kernel to fill out.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query {
  __u32 num_items;
  __u32 flags;
  __u64 items_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">num_items</span></code></dt>
<dd>The number of elements in the <strong>items_ptr</strong> array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>Unused for now. Must be cleared to zero.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">items_ptr</span></code></dt>
<dd>Pointer to an array of <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_item</span></code></a>. The number of
array elements is <strong>num_items</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this is generally a two step process for each <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_i915_query_item</span></code></a> in the array:</p>
<ol class="arabic simple">
<li>Call the DRM_IOCTL_I915_QUERY, giving it our array of <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_i915_query_item</span></code></a>, with <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.length</span></code></a> set to zero. The
kernel will then fill in the size, in bytes, which tells userspace how
memory it needs to allocate for the blob(say for an array of properties).</li>
<li>Next we call DRM_IOCTL_I915_QUERY again, this time with the
<a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.data_ptr</span></code></a> equal to our newly allocated blob. Note that
the <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.length</span></code></a> should still be the same as what the
kernel previously set. At this point the kernel can fill in the blob.</li>
</ol>
<p>Note that for some query items it can make sense for userspace to just pass
in a buffer/blob equal to or larger than the required size. In this case only
a single ioctl call is needed. For some smaller query items this can work
quite well.</p>
<p id="engine-discovery-uapi"><strong>Engine Discovery uAPI</strong></p>
<p>Engine discovery uAPI is a way of enumerating physical engines present in a
GPU associated with an open i915 DRM file descriptor. This supersedes the old
way of using <cite>DRM_IOCTL_I915_GETPARAM</cite> and engine identifiers like
<cite>I915_PARAM_HAS_BLT</cite>.</p>
<p>The need for this interface came starting with Icelake and newer GPUs, which
started to establish a pattern of having multiple engines of a same class,
where not all instances were always completely functionally equivalent.</p>
<p>Entry point for this uapi is <cite>DRM_IOCTL_I915_QUERY</cite> with the
<cite>DRM_I915_QUERY_ENGINE_INFO</cite> as the queried item id.</p>
<p>Example for getting the list of engines:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">drm_i915_query_engine_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drm_i915_query_item</span> <span class="n">item</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">query_id</span> <span class="o">=</span> <span class="n">DRM_I915_QUERY_ENGINE_INFO</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">drm_i915_query</span> <span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">num_items</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">.</span><span class="n">items_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">item</span><span class="p">,</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

<span class="c1">// First query the size of the blob we need, this needs to be large</span>
<span class="c1">// enough to hold our array of engines. The kernel will fill out the</span>
<span class="c1">// item.length for us, which is the number of bytes we need.</span>
<span class="c1">//</span>
<span class="c1">// Alternatively a large buffer can be allocated straight away enabling</span>
<span class="c1">// querying in one pass, in which case item.length should contain the</span>
<span class="c1">// length of the provided buffer.</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">...</span>

<span class="n">info</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="c1">// Now that we allocated the required number of bytes, we call the ioctl</span>
<span class="c1">// again, this time with the data_ptr pointing to our newly allocated</span>
<span class="c1">// blob, which the kernel can then populate with info on all engines.</span>
<span class="n">item</span><span class="p">.</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">...</span>

<span class="c1">// We can now access each engine in the array</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_engines</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">drm_i915_engine_info</span> <span class="n">einfo</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">engines</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">u16</span> <span class="n">class</span> <span class="o">=</span> <span class="n">einfo</span><span class="p">.</span><span class="n">engine</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
        <span class="n">u16</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">einfo</span><span class="p">.</span><span class="n">engine</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span>
        <span class="p">....</span>
<span class="p">}</span>

<span class="n">free</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
</pre></div>
</div>
<p>Each of the enumerated engines, apart from being defined by its class and
instance (see <cite>struct i915_engine_class_instance</cite>), also can have flags and
capabilities defined as documented in i915_drm.h.</p>
<p>For instance video engines which support HEVC encoding will have the
<cite>I915_VIDEO_CLASS_CAPABILITY_HEVC</cite> capability bit set.</p>
<p>Engine discovery only fully comes to its own when combined with the new way
of addressing engines when submitting batch buffers using contexts with
engine maps configured.</p>
<dl class="type">
<dt id="c.drm_i915_engine_info">
struct <code class="descname">drm_i915_engine_info</code><a class="headerlink" href="#c.drm_i915_engine_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_engine_info {
  struct i915_engine_class_instance engine;
  __u32 rsvd0;
  __u64 flags;
#define I915_ENGINE_INFO_HAS_LOGICAL_INSTANCE           (1 &lt;&lt; 0);
  __u64 capabilities;
#define I915_VIDEO_CLASS_CAPABILITY_HEVC                (1 &lt;&lt; 0);
#define I915_VIDEO_AND_ENHANCE_CLASS_CAPABILITY_SFC     (1 &lt;&lt; 1);
  __u16 logical_instance;
  __u16 rsvd1[3];
  __u64 rsvd2[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">engine</span></code></dt>
<dd>Engine class and instance.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd0</span></code></dt>
<dd>Reserved field.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>Engine flags.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capabilities</span></code></dt>
<dd>Capabilities of this engine.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">logical_instance</span></code></dt>
<dd>Logical instance of engine</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd1</span></code></dt>
<dd>Reserved fields.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd2</span></code></dt>
<dd>Reserved fields.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes one engine and it’s capabilities as known to the driver.</p>
<dl class="type">
<dt id="c.drm_i915_query_engine_info">
struct <code class="descname">drm_i915_query_engine_info</code><a class="headerlink" href="#c.drm_i915_query_engine_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_engine_info {
  __u32 num_engines;
  __u32 rsvd[3];
  struct drm_i915_engine_info engines[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">num_engines</span></code></dt>
<dd>Number of <a class="reference internal" href="#c.drm_i915_engine_info" title="drm_i915_engine_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_engine_info</span></code></a> structs following.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt>
<dd>MBZ</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engines</span></code></dt>
<dd>Marker for drm_i915_engine_info structures.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Engine info query enumerates all engines known to the driver by filling in
an array of <a class="reference internal" href="#c.drm_i915_engine_info" title="drm_i915_engine_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_engine_info</span></code></a> structures.</p>
<dl class="type">
<dt id="c.drm_i915_gem_memory_class">
enum <code class="descname">drm_i915_gem_memory_class</code><a class="headerlink" href="#c.drm_i915_gem_memory_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported memory classes</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">I915_MEMORY_CLASS_SYSTEM</span></code></dt>
<dd>System memory</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_MEMORY_CLASS_DEVICE</span></code></dt>
<dd>Device local-memory</dd>
</dl>
<dl class="type">
<dt id="c.drm_i915_gem_memory_class_instance">
struct <code class="descname">drm_i915_gem_memory_class_instance</code><a class="headerlink" href="#c.drm_i915_gem_memory_class_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify particular memory region</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_memory_class_instance {
  __u16 memory_class;
  __u16 memory_instance;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">memory_class</span></code></dt>
<dd>See <a class="reference internal" href="#c.drm_i915_gem_memory_class" title="drm_i915_gem_memory_class"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_i915_gem_memory_class</span></code></a></dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory_instance</span></code></dt>
<dd>Which instance</dd>
</dl>
<dl class="type">
<dt id="c.drm_i915_memory_region_info">
struct <code class="descname">drm_i915_memory_region_info</code><a class="headerlink" href="#c.drm_i915_memory_region_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes one region as known to the driver.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_memory_region_info {
  struct drm_i915_gem_memory_class_instance region;
  __u32 rsvd0;
  __u64 probed_size;
  __u64 unallocated_size;
  __u64 rsvd1[8];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">region</span></code></dt>
<dd>The class:instance pair encoding</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd0</span></code></dt>
<dd>MBZ</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probed_size</span></code></dt>
<dd>Memory probed by the driver (-1 = unknown)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unallocated_size</span></code></dt>
<dd>Estimate of memory remaining (-1 = unknown)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd1</span></code></dt>
<dd>MBZ</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that we reserve some stuff here for potential future work. As an example
we might want expose the capabilities for a given region, which could include
things like if the region is CPU mappable/accessible, what are the supported
mapping types etc.</p>
<p>Note that to extend <a class="reference internal" href="#c.drm_i915_memory_region_info" title="drm_i915_memory_region_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_memory_region_info</span></code></a> and <a class="reference internal" href="#c.drm_i915_query_memory_regions" title="drm_i915_query_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_i915_query_memory_regions</span></code></a> in the future the plan is to do the following:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">drm_i915_memory_region_info</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">drm_i915_gem_memory_class_instance</span> <span class="n">region</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="n">__u32</span> <span class="n">rsvd0</span><span class="p">;</span>
                <span class="n">__u32</span> <span class="n">new_thing1</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="p">...</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="n">__u64</span> <span class="n">rsvd1</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
                <span class="k">struct</span> <span class="p">{</span>
                        <span class="n">__u64</span> <span class="n">new_thing2</span><span class="p">;</span>
                        <span class="n">__u64</span> <span class="n">new_thing3</span><span class="p">;</span>
                        <span class="p">...</span>
                <span class="p">};</span>
        <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>With this things should remain source compatible between versions for
userspace, even as we add new fields.</p>
<p>Note this is using both <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_item</span></code></a> and <a class="reference internal" href="#c.drm_i915_query" title="drm_i915_query"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query</span></code></a>.
For this new query we are adding the new query id DRM_I915_QUERY_MEMORY_REGIONS
at <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.query_id</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_i915_query_memory_regions">
struct <code class="descname">drm_i915_query_memory_regions</code><a class="headerlink" href="#c.drm_i915_query_memory_regions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_memory_regions {
  __u32 num_regions;
  __u32 rsvd[3];
  struct drm_i915_memory_region_info regions[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">num_regions</span></code></dt>
<dd>Number of supported regions</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt>
<dd>MBZ</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regions</span></code></dt>
<dd>Info about each supported region</dd>
</dl>
<p><strong>Description</strong></p>
<p>The region info query enumerates all regions known to the driver by filling
in an array of <a class="reference internal" href="#c.drm_i915_memory_region_info" title="drm_i915_memory_region_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_memory_region_info</span></code></a> structures.</p>
<p>Example for getting the list of supported regions:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">drm_i915_query_memory_regions</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">drm_i915_query_item</span> <span class="n">item</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">query_id</span> <span class="o">=</span> <span class="n">DRM_I915_QUERY_MEMORY_REGIONS</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">drm_i915_query</span> <span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">num_items</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">.</span><span class="n">items_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">item</span><span class="p">,</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

<span class="c1">// First query the size of the blob we need, this needs to be large</span>
<span class="c1">// enough to hold our array of regions. The kernel will fill out the</span>
<span class="c1">// item.length for us, which is the number of bytes we need.</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">...</span>

<span class="n">info</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">item</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="c1">// Now that we allocated the required number of bytes, we call the ioctl</span>
<span class="c1">// again, this time with the data_ptr pointing to our newly allocated</span>
<span class="c1">// blob, which the kernel can then populate with the all the region info.</span>
<span class="n">item</span><span class="p">.</span><span class="n">data_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">query</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">...</span>

<span class="c1">// We can now access each region in the array</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_regions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">drm_i915_memory_region_info</span> <span class="n">mr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">u16</span> <span class="n">class</span> <span class="o">=</span> <span class="n">mr</span><span class="p">.</span><span class="n">region</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
        <span class="n">u16</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">mr</span><span class="p">.</span><span class="n">region</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span>

        <span class="p">....</span>
<span class="p">}</span>

<span class="n">free</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
</pre></div>
</div>
<dl class="type">
<dt id="c.drm_i915_gem_create_ext">
struct <code class="descname">drm_i915_gem_create_ext</code><a class="headerlink" href="#c.drm_i915_gem_create_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>Existing gem_create behaviour, with added extension support using <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext {
  __u64 size;
  __u32 handle;
  __u32 flags;
#define I915_GEM_CREATE_EXT_MEMORY_REGIONS 0;
#define I915_GEM_CREATE_EXT_PROTECTED_CONTENT 1;
  __u64 extensions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd><p class="first">Requested size for the object.</p>
<p>The (page-aligned) allocated size for the object will be returned.</p>
<p>DG2 64K min page size implications:</p>
<p>On discrete platforms, starting from DG2, we have to contend with GTT
page size restrictions when dealing with I915_MEMORY_CLASS_DEVICE
objects.  Specifically the hardware only supports 64K or larger GTT
page sizes for such memory. The kernel will already ensure that all
I915_MEMORY_CLASS_DEVICE memory is allocated using 64K or larger page
sizes underneath.</p>
<p>Note that the returned size here will always reflect any required
rounding up done by the kernel, i.e 4K will now become 64K on devices
such as DG2.</p>
<p>Special DG2 GTT address alignment requirement:</p>
<p>The GTT alignment will also need to be at least 2M for such objects.</p>
<p>Note that due to how the hardware implements 64K GTT page support, we
have some further complications:</p>
<blockquote>
<div><p>1) The entire PDE (which covers a 2MB virtual address range), must
contain only 64K PTEs, i.e mixing 4K and 64K PTEs in the same
PDE is forbidden by the hardware.</p>
<p>2) We still need to support 4K PTEs for I915_MEMORY_CLASS_SYSTEM
objects.</p>
</div></blockquote>
<p class="last">To keep things simple for userland, we mandate that any GTT mappings
must be aligned to and rounded up to 2MB. The kernel will internally
pad them out to the next 2MB boundary. As this only wastes virtual
address space and avoids userland having to copy any needlessly
complicated PDE sharing scheme (coloring) and only affects DG2, this
is deemed to be a good compromise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt>
<dd><p class="first">Returned handle for the object.</p>
<p class="last">Object handles are nonzero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>MBZ</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt>
<dd><p class="first">The chain of extensions to apply to this object.</p>
<p>This will be useful in the future when we need to support several
different extensions, and we need to apply more than one when
creating the object. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
<p>If we don’t supply any extensions then we get the same old gem_create
behaviour.</p>
<p>For I915_GEM_CREATE_EXT_MEMORY_REGIONS usage see
<a class="reference internal" href="#c.drm_i915_gem_create_ext_memory_regions" title="drm_i915_gem_create_ext_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_create_ext_memory_regions</span></code></a>.</p>
<p class="last">For I915_GEM_CREATE_EXT_PROTECTED_CONTENT usage see
<a class="reference internal" href="#c.drm_i915_gem_create_ext_protected_content" title="drm_i915_gem_create_ext_protected_content"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_create_ext_protected_content</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that in the future we want to have our buffer flags here, at least for
the stuff that is immutable. Previously we would have two ioctls, one to
create the object with gem_create, and another to apply various parameters,
however this creates some ambiguity for the params which are considered
immutable. Also in general we’re phasing out the various SET/GET ioctls.</p>
<dl class="type">
<dt id="c.drm_i915_gem_create_ext_memory_regions">
struct <code class="descname">drm_i915_gem_create_ext_memory_regions</code><a class="headerlink" href="#c.drm_i915_gem_create_ext_memory_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>The I915_GEM_CREATE_EXT_MEMORY_REGIONS extension.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext_memory_regions {
  struct i915_user_extension base;
  __u32 pad;
  __u32 num_regions;
  __u64 regions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt>
<dd>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt>
<dd>MBZ</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_regions</span></code></dt>
<dd>Number of elements in the <strong>regions</strong> array.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regions</span></code></dt>
<dd><p class="first">The regions/placements array.</p>
<p class="last">An array of <a class="reference internal" href="#c.drm_i915_gem_memory_class_instance" title="drm_i915_gem_memory_class_instance"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_memory_class_instance</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the object with the desired set of placements/regions in priority
order. Each entry must be unique and supported by the device.</p>
<p>This is provided as an array of <a class="reference internal" href="#c.drm_i915_gem_memory_class_instance" title="drm_i915_gem_memory_class_instance"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_memory_class_instance</span></code></a>, or
an equivalent layout of class:instance pair encodings. See <a class="reference internal" href="#c.drm_i915_query_memory_regions" title="drm_i915_query_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_i915_query_memory_regions</span></code></a> and DRM_I915_QUERY_MEMORY_REGIONS for how to
query the supported regions for a device.</p>
<p>As an example, on discrete devices, if we wish to set the placement as
device local-memory we can do something like:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">drm_i915_gem_memory_class_instance</span> <span class="n">region_lmem</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">memory_class</span> <span class="o">=</span> <span class="n">I915_MEMORY_CLASS_DEVICE</span><span class="p">,</span>
        <span class="p">.</span><span class="n">memory_instance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">drm_i915_gem_create_ext_memory_regions</span> <span class="n">regions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">I915_GEM_CREATE_EXT_MEMORY_REGIONS</span> <span class="p">},</span>
        <span class="p">.</span><span class="n">regions</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">region_lmem</span><span class="p">,</span>
        <span class="p">.</span><span class="n">num_regions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">drm_i915_gem_create_ext</span> <span class="n">create_ext</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
        <span class="p">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regions</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">DRM_IOCTL_I915_GEM_CREATE_EXT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">create_ext</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">...</span>
</pre></div>
</div>
<p>At which point we get the object handle in <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext.handle</span></code></a>,
along with the final object size in <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext.size</span></code></a>, which
should account for any rounding up, if required.</p>
<dl class="type">
<dt id="c.drm_i915_gem_create_ext_protected_content">
struct <code class="descname">drm_i915_gem_create_ext_protected_content</code><a class="headerlink" href="#c.drm_i915_gem_create_ext_protected_content" title="Permalink to this definition">¶</a></dt>
<dd><p>The I915_OBJECT_PARAM_PROTECTED_CONTENT extension.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext_protected_content {
  struct i915_user_extension base;
  __u32 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt>
<dd>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>reserved for future usage, currently MBZ</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this extension is provided, buffer contents are expected to be protected
by PXP encryption and require decryption for scan out and processing. This
is only possible on platforms that have PXP enabled, on all other scenarios
using this extension will cause the ioctl to fail and return -ENODEV. The
flags parameter is reserved for future expansion and must currently be set
to zero.</p>
<p>The buffer contents are considered invalid after a PXP session teardown.</p>
<p>The encryption is guaranteed to be processed correctly only if the object
is submitted with a context created using the
I915_CONTEXT_PARAM_PROTECTED_CONTENT flag. This will also enable extra checks
at submission time on the validity of the objects involved.</p>
<p>Below is an example on how to create a protected object:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">drm_i915_gem_create_ext_protected_content</span> <span class="n">protected_ext</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">I915_GEM_CREATE_EXT_PROTECTED_CONTENT</span> <span class="p">},</span>
        <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">drm_i915_gem_create_ext</span> <span class="n">create_ext</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
        <span class="p">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">protected_ext</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">DRM_IOCTL_I915_GEM_CREATE_EXT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">create_ext</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">...</span>
</pre></div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-client.html" class="btn btn-neutral float-right" title="Kernel clients" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-uapi.html" class="btn btn-neutral" title="Userland interfaces" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>