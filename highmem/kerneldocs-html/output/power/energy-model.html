

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Energy Model of devices &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Power Management" href="index.html"/>
        <link rel="next" title="Freezing of tasks" href="freezing-of-tasks.html"/>
        <link rel="prev" title="Testing suspend and resume support in device drivers" href="drivers-testing.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Power Management</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="apm-acpi.html">APM or ACPI?</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic-pm-debugging.html">Debugging hibernation and suspend</a></li>
<li class="toctree-l2"><a class="reference internal" href="charger-manager.html">Charger Manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="drivers-testing.html">Testing suspend and resume support in device drivers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Energy Model of devices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core-apis">2. Core APIs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#config-options">2.1 Config options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#registration-of-performance-domains">2.2 Registration of performance domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-performance-domains">2.3 Accessing performance domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#description-details-of-this-api">2.4 Description details of this API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-driver">3. Example driver</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="freezing-of-tasks.html">Freezing of tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="opp.html">Operating Performance Points (OPP) Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm_qos_interface.html">PM Quality Of Service Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="power_supply_class.html">Linux power supply class</a></li>
<li class="toctree-l2"><a class="reference internal" href="runtime_pm.html">Runtime Power Management Framework for I/O Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="s2ram.html">How to get s2ram working</a></li>
<li class="toctree-l2"><a class="reference internal" href="suspend-and-cpuhotplug.html">Interaction of Suspend code (S3) with the CPU hotplug infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="suspend-and-interrupts.html">System Suspend and Device Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="swsusp-and-swap-files.html">Using swap files with software suspend (swsusp)</a></li>
<li class="toctree-l2"><a class="reference internal" href="swsusp-dmcrypt.html">How to use dm-crypt and swsusp together</a></li>
<li class="toctree-l2"><a class="reference internal" href="swsusp.html">Swap suspend</a></li>
<li class="toctree-l2"><a class="reference internal" href="video.html">Video issues with S3 resume</a></li>
<li class="toctree-l2"><a class="reference internal" href="tricks.html">swsusp/S3 tricks</a></li>
<li class="toctree-l2"><a class="reference internal" href="userland-swsusp.html">Documentation for userland software suspend interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="powercap/powercap.html">Power Capping Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="powercap/dtpm.html">Dynamic Thermal Power Management framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator/consumer.html">Regulator Consumer Driver Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator/design.html">Regulator API design notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator/machine.html">Regulator Machine Driver Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator/overview.html">Linux voltage and current regulator framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator/regulator.html">Regulator Driver Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Power Management</a> &raquo;</li>
        
      <li>Energy Model of devices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/power/energy-model.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="energy-model-of-devices">
<h1>Energy Model of devices<a class="headerlink" href="#energy-model-of-devices" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>1. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The Energy Model (EM) framework serves as an interface between drivers knowing
the power consumed by devices at various performance levels, and the kernel
subsystems willing to use that information to make energy-aware decisions.</p>
<p>The source of the information about the power consumed by devices can vary greatly
from one platform to another. These power costs can be estimated using
devicetree data in some cases. In others, the firmware will know better.
Alternatively, userspace might be best positioned. And so on. In order to avoid
each and every client subsystem to re-implement support for each and every
possible source of information on its own, the EM framework intervenes as an
abstraction layer which standardizes the format of power cost tables in the
kernel, hence enabling to avoid redundant work.</p>
<p>The power values might be expressed in milli-Watts or in an ‘abstract scale’.
Multiple subsystems might use the EM and it is up to the system integrator to
check that the requirements for the power value scale types are met. An example
can be found in the Energy-Aware Scheduler documentation
<a class="reference internal" href="../scheduler/sched-energy.html"><span class="doc">Energy Aware Scheduling</span></a>. For some subsystems like thermal or
powercap power values expressed in an ‘abstract scale’ might cause issues.
These subsystems are more interested in estimation of power used in the past,
thus the real milli-Watts might be needed. An example of these requirements can
be found in the Intelligent Power Allocation in
<a class="reference internal" href="../driver-api/thermal/power_allocator.html"><span class="doc">Power allocator governor tunables</span></a>.
Kernel subsystems might implement automatic detection to check whether EM
registered devices have inconsistent scale (based on EM internal flag).
Important thing to keep in mind is that when the power values are expressed in
an ‘abstract scale’ deriving real energy in milli-Joules would not be possible.</p>
<p>The figure below depicts an example of drivers (Arm-specific here, but the
approach is applicable to any architecture) providing power costs to the EM
framework, and interested clients reading the data from it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+---------------+  +-----------------+  +---------------+
| Thermal (IPA) |  | Scheduler (EAS) |  |     Other     |
+---------------+  +-----------------+  +---------------+
        |                   | em_cpu_energy()   |
        |                   | em_cpu_get()      |
        +---------+         |         +---------+
                  |         |         |
                  v         v         v
                 +---------------------+
                 |    Energy Model     |
                 |     Framework       |
                 +---------------------+
                    ^       ^       ^
                    |       |       | em_dev_register_perf_domain()
         +----------+       |       +---------+
         |                  |                 |
 +---------------+  +---------------+  +--------------+
 |  cpufreq-dt   |  |   arm_scmi    |  |    Other     |
 +---------------+  +---------------+  +--------------+
         ^                  ^                 ^
         |                  |                 |
 +--------------+   +---------------+  +--------------+
 | Device Tree  |   |   Firmware    |  |      ?       |
 +--------------+   +---------------+  +--------------+
</pre></div>
</div>
<p>In case of CPU devices the EM framework manages power cost tables per
‘performance domain’ in the system. A performance domain is a group of CPUs
whose performance is scaled together. Performance domains generally have a
1-to-1 mapping with CPUFreq policies. All CPUs in a performance domain are
required to have the same micro-architecture. CPUs in different performance
domains can have different micro-architectures.</p>
</div>
<div class="section" id="core-apis">
<h2>2. Core APIs<a class="headerlink" href="#core-apis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="config-options">
<h3>2.1 Config options<a class="headerlink" href="#config-options" title="Permalink to this headline">¶</a></h3>
<p>CONFIG_ENERGY_MODEL must be enabled to use the EM framework.</p>
</div>
<div class="section" id="registration-of-performance-domains">
<h3>2.2 Registration of performance domains<a class="headerlink" href="#registration-of-performance-domains" title="Permalink to this headline">¶</a></h3>
<div class="section" id="registration-of-advanced-em">
<h4>Registration of ‘advanced’ EM<a class="headerlink" href="#registration-of-advanced-em" title="Permalink to this headline">¶</a></h4>
<p>The ‘advanced’ EM gets it’s name due to the fact that the driver is allowed
to provide more precised power model. It’s not limited to some implemented math
formula in the framework (like it’s in ‘simple’ EM case). It can better reflect
the real power measurements performed for each performance state. Thus, this
registration method should be preferred in case considering EM static power
(leakage) is important.</p>
<p>Drivers are expected to register performance domains into the EM framework by
calling the following API:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int em_dev_register_perf_domain(struct device *dev, unsigned int nr_states,
              struct em_data_callback *cb, cpumask_t *cpus, bool milliwatts);
</pre></div>
</div>
<p>Drivers must provide a callback function returning &lt;frequency, power&gt; tuples
for each performance state. The callback function provided by the driver is free
to fetch data from any relevant location (DT, firmware, …), and by any mean
deemed necessary. Only for CPU devices, drivers must specify the CPUs of the
performance domains using cpumask. For other devices than CPUs the last
argument must be set to NULL.
The last argument ‘milliwatts’ is important to set with correct value. Kernel
subsystems which use EM might rely on this flag to check if all EM devices use
the same scale. If there are different scales, these subsystems might decide
to: return warning/error, stop working or panic.
See Section 3. for an example of driver implementing this
callback, or Section 2.4 for further documentation on this API</p>
</div>
<div class="section" id="registration-of-em-using-dt">
<h4>Registration of EM using DT<a class="headerlink" href="#registration-of-em-using-dt" title="Permalink to this headline">¶</a></h4>
<p>The  EM can also be registered using OPP framework and information in DT
“operating-points-v2”. Each OPP entry in DT can be extended with a property
“opp-microwatt” containing micro-Watts power value. This OPP DT property
allows a platform to register EM power values which are reflecting total power
(static + dynamic). These power values might be coming directly from
experiments and measurements.</p>
</div>
<div class="section" id="registration-of-simple-em">
<h4>Registration of ‘simple’ EM<a class="headerlink" href="#registration-of-simple-em" title="Permalink to this headline">¶</a></h4>
<p>The ‘simple’ EM is registered using the framework helper function
cpufreq_register_em_with_opp(). It implements a power model which is tight to
math formula:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Power = C * V^2 * f
</pre></div>
</div>
<p>The EM which is registered using this method might not reflect correctly the
physics of a real device, e.g. when static power (leakage) is important.</p>
</div>
</div>
<div class="section" id="accessing-performance-domains">
<h3>2.3 Accessing performance domains<a class="headerlink" href="#accessing-performance-domains" title="Permalink to this headline">¶</a></h3>
<p>There are two API functions which provide the access to the energy model:
<a class="reference internal" href="#c.em_cpu_get" title="em_cpu_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_cpu_get()</span></code></a> which takes CPU id as an argument and <a class="reference internal" href="#c.em_pd_get" title="em_pd_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_pd_get()</span></code></a> with device
pointer as an argument. It depends on the subsystem which interface it is
going to use, but in case of CPU devices both functions return the same
performance domain.</p>
<p>Subsystems interested in the energy model of a CPU can retrieve it using the
<a class="reference internal" href="#c.em_cpu_get" title="em_cpu_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_cpu_get()</span></code></a> API. The energy model tables are allocated once upon creation of
the performance domains, and kept in memory untouched.</p>
<p>The energy consumed by a performance domain can be estimated using the
<a class="reference internal" href="#c.em_cpu_energy" title="em_cpu_energy"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_cpu_energy()</span></code></a> API. The estimation is performed assuming that the schedutil
CPUfreq governor is in use in case of CPU device. Currently this calculation is
not provided for other type of devices.</p>
<p>More details about the above APIs can be found in <code class="docutils literal notranslate"><span class="pre">&lt;linux/energy_model.h&gt;</span></code>
or in Section 2.4</p>
</div>
<div class="section" id="description-details-of-this-api">
<h3>2.4 Description details of this API<a class="headerlink" href="#description-details-of-this-api" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.em_perf_state">
struct <code class="descname">em_perf_state</code><a class="headerlink" href="#c.em_perf_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Performance state of a performance domain</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct em_perf_state {
  unsigned long frequency;
  unsigned long power;
  unsigned long cost;
  unsigned long flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">frequency</span></code></dt>
<dd>The frequency in KHz, for consistency with CPUFreq</dd>
<dt><code class="docutils literal notranslate"><span class="pre">power</span></code></dt>
<dd>The power consumed at this level (by 1 CPU or by a registered
device). It can be a total power: static and dynamic.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cost</span></code></dt>
<dd>The cost coefficient associated with this level, used during
energy calculation. Equal to: power * max_frequency / frequency</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>see “em_perf_state flags” description below.</dd>
</dl>
<dl class="type">
<dt id="c.em_perf_domain">
struct <code class="descname">em_perf_domain</code><a class="headerlink" href="#c.em_perf_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Performance domain</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct em_perf_domain {
  struct em_perf_state *table;
  int nr_perf_states;
  unsigned long flags;
  unsigned long cpus[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">table</span></code></dt>
<dd>List of performance states, in ascending order</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_perf_states</span></code></dt>
<dd>Number of performance states</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>See “em_perf_domain flags”</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpus</span></code></dt>
<dd>Cpumask covering the CPUs of the domain. It’s here
for performance reasons to avoid potential cache
misses during energy calculations in the scheduler
and simplifies allocating/freeing that memory region.</dd>
</dl>
<p><strong>Description</strong></p>
<p>In case of CPU device, a “performance domain” represents a group of CPUs
whose performance is scaled together. All CPUs of a performance domain
must have the same micro-architecture. Performance domains often have
a 1-to-1 mapping with CPUFreq policies. In case of other devices the <strong>cpus</strong>
field is unused.</p>
<dl class="function">
<dt id="c.em_pd_get_efficient_state">
struct <a class="reference internal" href="#c.em_perf_state" title="em_perf_state">em_perf_state</a> * <code class="descname">em_pd_get_efficient_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain">em_perf_domain</a><em>&nbsp;*pd</em>, unsigned long<em>&nbsp;freq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_pd_get_efficient_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an efficient performance state from the EM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_domain</span> <span class="pre">*pd</span></code></dt>
<dd>Performance domain for which we want an efficient frequency</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">freq</span></code></dt>
<dd>Frequency to map with the EM</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is called from the scheduler code quite frequently and as a consequence
doesn’t implement any check.</p>
<p><strong>Return</strong></p>
<p>An efficient performance state, high enough to meet <strong>freq</strong>
requirement.</p>
<dl class="function">
<dt id="c.em_cpu_energy">
unsigned long <code class="descname">em_cpu_energy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain">em_perf_domain</a><em>&nbsp;*pd</em>, unsigned long<em>&nbsp;max_util</em>, unsigned long<em>&nbsp;sum_util</em>, unsigned long<em>&nbsp;allowed_cpu_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_cpu_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the energy consumed by the CPUs of a performance domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_domain</span> <span class="pre">*pd</span></code></dt>
<dd>performance domain for which energy has to be estimated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_util</span></code></dt>
<dd>highest utilization among CPUs of the domain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">sum_util</span></code></dt>
<dd>sum of the utilization of all CPUs in the domain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">allowed_cpu_cap</span></code></dt>
<dd>maximum allowed CPU capacity for the <strong>pd</strong>, which
might reflect reduced frequency (due to thermal)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be used only for CPU devices. There is no validation,
i.e. if the EM is a CPU type and has cpumask allocated. It is called from
the scheduler code quite frequently and that is why there is not checks.</p>
<p><strong>Return</strong></p>
<p>the sum of the energy consumed by the CPUs of the domain assuming
a capacity state satisfying the max utilization of the domain.</p>
<dl class="function">
<dt id="c.em_pd_nr_perf_states">
int <code class="descname">em_pd_nr_perf_states</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain">em_perf_domain</a><em>&nbsp;*pd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_pd_nr_perf_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of performance states of a perf. domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_domain</span> <span class="pre">*pd</span></code></dt>
<dd>performance domain for which this must be done</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of performance states in the performance domain table</p>
<dl class="function">
<dt id="c.em_pd_get">
struct <a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain">em_perf_domain</a> * <code class="descname">em_pd_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_pd_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the performance domain for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt>
<dd>Device to find the performance domain for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the performance domain to which <strong>dev</strong> belongs, or NULL if it doesn’t
exist.</p>
<dl class="function">
<dt id="c.em_cpu_get">
struct <a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain">em_perf_domain</a> * <code class="descname">em_cpu_get</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_cpu_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the performance domain for a CPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>CPU to find the performance domain for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the performance domain to which <strong>cpu</strong> belongs, or NULL if it doesn’t
exist.</p>
<dl class="function">
<dt id="c.em_dev_register_perf_domain">
int <code class="descname">em_dev_register_perf_domain</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em>, unsigned int<em>&nbsp;nr_states</em>, struct em_data_callback<em>&nbsp;*cb</em>, cpumask_t<em>&nbsp;*cpus</em>, bool<em>&nbsp;milliwatts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_dev_register_perf_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the Energy Model (EM) for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt>
<dd>Device for which the EM is to register</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_states</span></code></dt>
<dd>Number of performance states to register</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_data_callback</span> <span class="pre">*cb</span></code></dt>
<dd>Callback functions providing the data of the Energy Model</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpumask_t</span> <span class="pre">*cpus</span></code></dt>
<dd>Pointer to cpumask_t, which in case of a CPU device is
obligatory. It can be taken from i.e. ‘policy-&gt;cpus’. For other
type of devices this should be set to NULL.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">milliwatts</span></code></dt>
<dd>Flag indicating that the power values are in milliWatts or
in some other scale. It must be set properly.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create Energy Model tables for a performance domain using the callbacks
defined in cb.</p>
<p>The <strong>milliwatts</strong> is important to set with correct value. Some kernel
sub-systems might rely on this flag and check if all devices in the EM are
using the same scale.</p>
<p>If multiple clients register the same performance domain, all but the first
registration will be ignored.</p>
<p>Return 0 on success</p>
<dl class="function">
<dt id="c.em_dev_unregister_perf_domain">
void <code class="descname">em_dev_unregister_perf_domain</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_dev_unregister_perf_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister Energy Model (EM) for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt>
<dd>Device for which the EM is registered</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister the EM for the specified <strong>dev</strong> (but not a CPU device).</p>
</div>
</div>
<div class="section" id="example-driver">
<h2>3. Example driver<a class="headerlink" href="#example-driver" title="Permalink to this headline">¶</a></h2>
<p>The CPUFreq framework supports dedicated callback for registering
the EM for a given CPU(s) ‘policy’ object: cpufreq_driver::register_em().
That callback has to be implemented properly for a given driver,
because the framework would call it at the right time during setup.
This section provides a simple example of a CPUFreq driver registering a
performance domain in the Energy Model framework using the (fake) ‘foo’
protocol. The driver implements an est_power() function to be provided to the
EM framework:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-&gt; drivers/cpufreq/foo_cpufreq.c

01    static int est_power(unsigned long *mW, unsigned long *KHz,
02                    struct device *dev)
03    {
04            long freq, power;
05
06            /* Use the &#39;foo&#39; protocol to ceil the frequency */
07            freq = foo_get_freq_ceil(dev, *KHz);
08            if (freq &lt; 0);
09                    return freq;
10
11            /* Estimate the power cost for the dev at the relevant freq. */
12            power = foo_estimate_power(dev, freq);
13            if (power &lt; 0);
14                    return power;
15
16            /* Return the values to the EM framework */
17            *mW = power;
18            *KHz = freq;
19
20            return 0;
21    }
22
23    static void foo_cpufreq_register_em(struct cpufreq_policy *policy)
24    {
25            struct em_data_callback em_cb = EM_DATA_CB(est_power);
26            struct device *cpu_dev;
27            int nr_opp;
28
29            cpu_dev = get_cpu_device(cpumask_first(policy-&gt;cpus));
30
31            /* Find the number of OPPs for this policy */
32            nr_opp = foo_get_nr_opp(policy);
33
34            /* And register the new performance domain */
35            em_dev_register_perf_domain(cpu_dev, nr_opp, &amp;em_cb, policy-&gt;cpus,
36                                        true);
37    }
38
39    static struct cpufreq_driver foo_cpufreq_driver = {
40            .register_em = foo_cpufreq_register_em,
41    };
</pre></div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="freezing-of-tasks.html" class="btn btn-neutral float-right" title="Freezing of tasks" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drivers-testing.html" class="btn btn-neutral" title="Testing suspend and resume support in device drivers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>