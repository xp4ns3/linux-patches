

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Entry/exit handling for exceptions, interrupts, syscalls and KVM &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Core API Documentation" href="index.html"/>
        <link rel="next" title="refcount_t API compared to atomic_t" href="refcount-vs-atomic.html"/>
        <link rel="prev" title="The errseq_t datatype" href="errseq.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#low-level-entry-and-exit">Low level entry and exit</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Entry/exit handling for exceptions, interrupts, syscalls and KVM</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#non-instrumentable-code-noinstr">Non-instrumentable code - noinstr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#syscalls">Syscalls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kvm">KVM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupts-and-regular-exceptions">Interrupts and regular exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nmi-and-nmi-like-exceptions">NMI and NMI-like exceptions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
        
      <li>Entry/exit handling for exceptions, interrupts, syscalls and KVM</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/core-api/entry.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="entry-exit-handling-for-exceptions-interrupts-syscalls-and-kvm">
<h1>Entry/exit handling for exceptions, interrupts, syscalls and KVM<a class="headerlink" href="#entry-exit-handling-for-exceptions-interrupts-syscalls-and-kvm" title="Permalink to this headline">¶</a></h1>
<p>All transitions between execution domains require state updates which are
subject to strict ordering constraints. State updates are required for the
following:</p>
<blockquote>
<div><ul class="simple">
<li>Lockdep</li>
<li>RCU / Context tracking</li>
<li>Preemption counter</li>
<li>Tracing</li>
<li>Time accounting</li>
</ul>
</div></blockquote>
<p>The update order depends on the transition type and is explained below in
the transition type sections: <a class="reference internal" href="#syscalls">Syscalls</a>, <a class="reference internal" href="#kvm">KVM</a>, <a class="reference internal" href="#interrupts-and-regular-exceptions">Interrupts and regular
exceptions</a>, <a class="reference internal" href="#nmi-and-nmi-like-exceptions">NMI and NMI-like exceptions</a>.</p>
<div class="section" id="non-instrumentable-code-noinstr">
<h2>Non-instrumentable code - noinstr<a class="headerlink" href="#non-instrumentable-code-noinstr" title="Permalink to this headline">¶</a></h2>
<p>Most instrumentation facilities depend on RCU, so intrumentation is prohibited
for entry code before RCU starts watching and exit code after RCU stops
watching. In addition, many architectures must save and restore register state,
which means that (for example) a breakpoint in the breakpoint entry code would
overwrite the debug registers of the initial breakpoint.</p>
<p>Such code must be marked with the ‘noinstr’ attribute, placing that code into a
special section inaccessible to instrumentation and debug facilities. Some
functions are partially instrumentable, which is handled by marking them
noinstr and using instrumentation_begin() and instrumentation_end() to flag the
instrumentable ranges of code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">noinstr</span> <span class="kt">void</span> <span class="nf">entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">handle_entry</span><span class="p">();</span>     <span class="c1">// &lt;-- must be &#39;noinstr&#39; or &#39;__always_inline&#39;</span>
      <span class="p">...</span>

      <span class="n">instrumentation_begin</span><span class="p">();</span>
      <span class="n">handle_context</span><span class="p">();</span>   <span class="c1">// &lt;-- instrumentable code</span>
      <span class="n">instrumentation_end</span><span class="p">();</span>

      <span class="p">...</span>
      <span class="n">handle_exit</span><span class="p">();</span>      <span class="c1">// &lt;-- must be &#39;noinstr&#39; or &#39;__always_inline&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This allows verification of the ‘noinstr’ restrictions via objtool on
supported architectures.</p>
<p>Invoking non-instrumentable functions from instrumentable context has no
restrictions and is useful to protect e.g. state switching which would
cause malfunction if instrumented.</p>
<p>All non-instrumentable entry/exit code sections before and after the RCU
state transitions must run with interrupts disabled.</p>
</div>
<div class="section" id="syscalls">
<h2>Syscalls<a class="headerlink" href="#syscalls" title="Permalink to this headline">¶</a></h2>
<p>Syscall-entry code starts in assembly code and calls out into low-level C code
after establishing low-level architecture-specific state and stack frames. This
low-level C code must not be instrumented. A typical syscall handling function
invoked from low-level assembly code looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">noinstr</span> <span class="kt">void</span> <span class="nf">syscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">arch_syscall_enter</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
      <span class="n">nr</span> <span class="o">=</span> <span class="n">syscall_enter_from_user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>

      <span class="n">instrumentation_begin</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">invoke_syscall</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">nr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nr</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
              <span class="n">result_reg</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">=</span> <span class="n">__sys_ni_syscall</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
      <span class="n">instrumentation_end</span><span class="p">();</span>

      <span class="n">syscall_exit_to_user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>syscall_enter_from_user_mode() first invokes enter_from_user_mode() which
establishes state in the following order:</p>
<blockquote>
<div><ul class="simple">
<li>Lockdep</li>
<li>RCU / Context tracking</li>
<li>Tracing</li>
</ul>
</div></blockquote>
<p>and then invokes the various entry work functions like ptrace, seccomp, audit,
syscall tracing, etc. After all that is done, the instrumentable invoke_syscall
function can be invoked. The instrumentable code section then ends, after which
syscall_exit_to_user_mode() is invoked.</p>
<p>syscall_exit_to_user_mode() handles all work which needs to be done before
returning to user space like tracing, audit, signals, task work etc. After
that it invokes exit_to_user_mode() which again handles the state
transition in the reverse order:</p>
<blockquote>
<div><ul class="simple">
<li>Tracing</li>
<li>RCU / Context tracking</li>
<li>Lockdep</li>
</ul>
</div></blockquote>
<p>syscall_enter_from_user_mode() and syscall_exit_to_user_mode() are also
available as fine grained subfunctions in cases where the architecture code
has to do extra work between the various steps. In such cases it has to
ensure that enter_from_user_mode() is called first on entry and
exit_to_user_mode() is called last on exit.</p>
<p>Do not nest syscalls. Nested systcalls will cause RCU and/or context tracking
to print a warning.</p>
</div>
<div class="section" id="kvm">
<h2>KVM<a class="headerlink" href="#kvm" title="Permalink to this headline">¶</a></h2>
<p>Entering or exiting guest mode is very similar to syscalls. From the host
kernel point of view the CPU goes off into user space when entering the
guest and returns to the kernel on exit.</p>
<p>kvm_guest_enter_irqoff() is a KVM-specific variant of exit_to_user_mode()
and kvm_guest_exit_irqoff() is the KVM variant of enter_from_user_mode().
The state operations have the same ordering.</p>
<p>Task work handling is done separately for guest at the boundary of the
vcpu_run() loop via xfer_to_guest_mode_handle_work() which is a subset of
the work handled on return to user space.</p>
<p>Do not nest KVM entry/exit transitions because doing so is nonsensical.</p>
</div>
<div class="section" id="interrupts-and-regular-exceptions">
<h2>Interrupts and regular exceptions<a class="headerlink" href="#interrupts-and-regular-exceptions" title="Permalink to this headline">¶</a></h2>
<p>Interrupts entry and exit handling is slightly more complex than syscalls
and KVM transitions.</p>
<p>If an interrupt is raised while the CPU executes in user space, the entry
and exit handling is exactly the same as for syscalls.</p>
<p>If the interrupt is raised while the CPU executes in kernel space the entry and
exit handling is slightly different. RCU state is only updated when the
interrupt is raised in the context of the CPU’s idle task. Otherwise, RCU will
already be watching. Lockdep and tracing have to be updated unconditionally.</p>
<p>irqentry_enter() and irqentry_exit() provide the implementation for this.</p>
<p>The architecture-specific part looks similar to syscall handling:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">noinstr</span> <span class="kt">void</span> <span class="nf">interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">arch_interrupt_enter</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
      <span class="n">state</span> <span class="o">=</span> <span class="n">irqentry_enter</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

      <span class="n">instrumentation_begin</span><span class="p">();</span>

      <span class="n">irq_enter_rcu</span><span class="p">();</span>
      <span class="n">invoke_irq_handler</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
      <span class="n">irq_exit_rcu</span><span class="p">();</span>

      <span class="n">instrumentation_end</span><span class="p">();</span>

      <span class="n">irqentry_exit</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that the invocation of the actual interrupt handler is within a
irq_enter_rcu() and irq_exit_rcu() pair.</p>
<p>irq_enter_rcu() updates the preemption count which makes in_hardirq()
return true, handles NOHZ tick state and interrupt time accounting. This
means that up to the point where irq_enter_rcu() is invoked in_hardirq()
returns false.</p>
<p>irq_exit_rcu() handles interrupt time accounting, undoes the preemption
count update and eventually handles soft interrupts and NOHZ tick state.</p>
<p>In theory, the preemption count could be updated in irqentry_enter(). In
practice, deferring this update to irq_enter_rcu() allows the preemption-count
code to be traced, while also maintaining symmetry with irq_exit_rcu() and
irqentry_exit(), which are described in the next paragraph. The only downside
is that the early entry code up to irq_enter_rcu() must be aware that the
preemption count has not yet been updated with the HARDIRQ_OFFSET state.</p>
<p>Note that irq_exit_rcu() must remove HARDIRQ_OFFSET from the preemption count
before it handles soft interrupts, whose handlers must run in BH context rather
than irq-disabled context. In addition, irqentry_exit() might schedule, which
also requires that HARDIRQ_OFFSET has been removed from the preemption count.</p>
<p>Even though interrupt handlers are expected to run with local interrupts
disabled, interrupt nesting is common from an entry/exit perspective. For
example, softirq handling happens within an irqentry_{enter,exit}() block with
local interrupts enabled. Also, although uncommon, nothing prevents an
interrupt handler from re-enabling interrupts.</p>
<p>Interrupt entry/exit code doesn’t strictly need to handle reentrancy, since it
runs with local interrupts disabled. But NMIs can happen anytime, and a lot of
the entry code is shared between the two.</p>
</div>
<div class="section" id="nmi-and-nmi-like-exceptions">
<h2>NMI and NMI-like exceptions<a class="headerlink" href="#nmi-and-nmi-like-exceptions" title="Permalink to this headline">¶</a></h2>
<p>NMIs and NMI-like exceptions (machine checks, double faults, debug
interrupts, etc.) can hit any context and must be extra careful with
the state.</p>
<p>State changes for debug exceptions and machine-check exceptions depend on
whether these exceptions happened in user-space (breakpoints or watchpoints) or
in kernel mode (code patching). From user-space, they are treated like
interrupts, while from kernel mode they are treated like NMIs.</p>
<p>NMIs and other NMI-like exceptions handle state transitions without
distinguishing between user-mode and kernel-mode origin.</p>
<p>The state update on entry is handled in irqentry_nmi_enter() which updates
state in the following order:</p>
<blockquote>
<div><ul class="simple">
<li>Preemption counter</li>
<li>Lockdep</li>
<li>RCU / Context tracking</li>
<li>Tracing</li>
</ul>
</div></blockquote>
<p>The exit counterpart irqentry_nmi_exit() does the reverse operation in the
reverse order.</p>
<p>Note that the update of the preemption counter has to be the first
operation on enter and the last operation on exit. The reason is that both
lockdep and RCU rely on in_nmi() returning true in this case. The
preemption count modification in the NMI entry/exit case must not be
traced.</p>
<p>Architecture-specific code looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">noinstr</span> <span class="kt">void</span> <span class="nf">nmi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">arch_nmi_enter</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
      <span class="n">state</span> <span class="o">=</span> <span class="n">irqentry_nmi_enter</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

      <span class="n">instrumentation_begin</span><span class="p">();</span>
      <span class="n">nmi_handler</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
      <span class="n">instrumentation_end</span><span class="p">();</span>

      <span class="n">irqentry_nmi_exit</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and for e.g. a debug exception it can look like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">noinstr</span> <span class="kt">void</span> <span class="nf">debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">arch_nmi_enter</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

      <span class="n">debug_regs</span> <span class="o">=</span> <span class="n">save_debug_regs</span><span class="p">();</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
              <span class="n">state</span> <span class="o">=</span> <span class="n">irqentry_enter</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

              <span class="n">instrumentation_begin</span><span class="p">();</span>
              <span class="n">user_mode_debug_handler</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">debug_regs</span><span class="p">);</span>
              <span class="n">instrumentation_end</span><span class="p">();</span>

              <span class="n">irqentry_exit</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="n">state</span> <span class="o">=</span> <span class="n">irqentry_nmi_enter</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>

              <span class="n">instrumentation_begin</span><span class="p">();</span>
              <span class="n">kernel_mode_debug_handler</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">debug_regs</span><span class="p">);</span>
              <span class="n">instrumentation_end</span><span class="p">();</span>

              <span class="n">irqentry_nmi_exit</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
      <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is no combined irqentry_nmi_if_kernel() function available as the
above cannot be handled in an exception-agnostic way.</p>
<p>NMIs can happen in any context. For example, an NMI-like exception triggered
while handling an NMI. So NMI entry code has to be reentrant and state updates
need to handle nesting.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="refcount-vs-atomic.html" class="btn btn-neutral float-right" title="refcount_t API compared to atomic_t" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="errseq.html" class="btn btn-neutral" title="The errseq_t datatype" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>