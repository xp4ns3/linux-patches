

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernel Probes (Kprobes) &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Linux Tracing Technologies" href="index.html"/>
        <link rel="next" title="Kprobe-based Event Tracing" href="kprobetrace.html"/>
        <link rel="prev" title="Fprobe - Function entry/exit probe" href="fprobe.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Tracing Technologies</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ftrace-design.html">Function Tracer Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="tracepoint-analysis.html">Notes on Analysing Behaviour Using Events and Tracepoints</a></li>
<li class="toctree-l2"><a class="reference internal" href="ftrace.html">ftrace - Function Tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="ftrace-uses.html">Using ftrace to hook to functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="fprobe.html">Fprobe - Function entry/exit probe</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Kernel Probes (Kprobes)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#concepts-kprobes-and-return-probes">Concepts: Kprobes and Return Probes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#how-does-a-kprobe-work">How Does a Kprobe Work?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#changing-execution-path">Changing Execution Path</a></li>
<li class="toctree-l4"><a class="reference internal" href="#return-probes">Return Probes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-does-jump-optimization-work">How Does Jump Optimization Work?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#blacklist">Blacklist</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#architectures-supported">Architectures Supported</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuring-kprobes">Configuring Kprobes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#api-reference">API Reference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#register-kprobe">register_kprobe</a></li>
<li class="toctree-l4"><a class="reference internal" href="#register-kretprobe">register_kretprobe</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unregister-probe">unregister_*probe</a></li>
<li class="toctree-l4"><a class="reference internal" href="#register-probes">register_*probes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unregister-probes">unregister_*probes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disable-probe">disable_*probe</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enable-probe">enable_*probe</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kprobes-features-and-limitations">Kprobes Features and Limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#probe-overhead">Probe Overhead</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#optimized-probe-overhead">Optimized Probe Overhead</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#todo">TODO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kprobes-example">Kprobes Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kretprobes-example">Kretprobes Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deprecated-features">Deprecated Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-kprobes-debugfs-interface">The kprobes debugfs interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-kprobes-sysctl-interface">The kprobes sysctl interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="kprobetrace.html">Kprobe-based Event Tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="uprobetracer.html">Uprobe-tracer: Uprobe-based Event Tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="tracepoints.html">Using the Linux Kernel Tracepoints</a></li>
<li class="toctree-l2"><a class="reference internal" href="events.html">Event Tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="events-kmem.html">Subsystem Trace Points: kmem</a></li>
<li class="toctree-l2"><a class="reference internal" href="events-power.html">Subsystem Trace Points: power</a></li>
<li class="toctree-l2"><a class="reference internal" href="events-nmi.html">NMI Trace Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="events-msr.html">MSR Trace Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmiotrace.html">In-kernel memory-mapped I/O tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="histogram.html">Event Histograms</a></li>
<li class="toctree-l2"><a class="reference internal" href="histogram-design.html">Histogram Design Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="boottime-trace.html">Boot-time tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="hwlat_detector.html">Hardware Latency Detector</a></li>
<li class="toctree-l2"><a class="reference internal" href="osnoise-tracer.html">OSNOISE Tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="timerlat-tracer.html">Timerlat tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="intel_th.html">Intel(R) Trace Hub (TH)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ring-buffer-design.html">Lockless Ring Buffer Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="stm.html">System Trace Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sys-t.html">MIPI SyS-T over STP</a></li>
<li class="toctree-l2"><a class="reference internal" href="coresight/index.html">CoreSight - ARM Hardware Trace</a></li>
<li class="toctree-l2"><a class="reference internal" href="user_events.html">user_events: User-based Event Tracing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Tracing Technologies</a> &raquo;</li>
        
      <li>Kernel Probes (Kprobes)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/trace/kprobes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kernel-probes-kprobes">
<h1>Kernel Probes (Kprobes)<a class="headerlink" href="#kernel-probes-kprobes" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Jim Keniston &lt;<a class="reference external" href="mailto:jkenisto&#37;&#52;&#48;us&#46;ibm&#46;com">jkenisto<span>&#64;</span>us<span>&#46;</span>ibm<span>&#46;</span>com</a>&gt;</td>
</tr>
<tr class="field-even field"><th class="field-name">Author:</th><td class="field-body">Prasanna S Panchamukhi &lt;<a class="reference external" href="mailto:prasanna&#46;panchamukhi&#37;&#52;&#48;gmail&#46;com">prasanna<span>&#46;</span>panchamukhi<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</td>
</tr>
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Masami Hiramatsu &lt;<a class="reference external" href="mailto:mhiramat&#37;&#52;&#48;redhat&#46;com">mhiramat<span>&#64;</span>redhat<span>&#46;</span>com</a>&gt;</td>
</tr>
</tbody>
</table>
<div class="section" id="concepts-kprobes-and-return-probes">
<h2>Concepts: Kprobes and Return Probes<a class="headerlink" href="#concepts-kprobes-and-return-probes" title="Permalink to this headline">¶</a></h2>
<p>Kprobes enables you to dynamically break into any kernel routine and
collect debugging and performance information non-disruptively. You
can trap at almost any kernel code address <a class="footnote-reference" href="#id2" id="id1">[1]</a>, specifying a handler
routine to be invoked when the breakpoint is hit.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>some parts of the kernel code can not be trapped, see
<a class="reference internal" href="#kprobes-blacklist"><span class="std std-ref">Blacklist</span></a>)</td></tr>
</tbody>
</table>
<p>There are currently two types of probes: kprobes, and kretprobes
(also called return probes).  A kprobe can be inserted on virtually
any instruction in the kernel.  A return probe fires when a specified
function returns.</p>
<p>In the typical case, Kprobes-based instrumentation is packaged as
a kernel module.  The module’s init function installs (“registers”)
one or more probes, and the exit function unregisters them.  A
registration function such as register_kprobe() specifies where
the probe is to be inserted and what handler is to be called when
the probe is hit.</p>
<p>There are also <code class="docutils literal notranslate"><span class="pre">register_/unregister_*probes()</span></code> functions for batch
registration/unregistration of a group of <code class="docutils literal notranslate"><span class="pre">*probes</span></code>. These functions
can speed up unregistration process when you have to unregister
a lot of probes at once.</p>
<p>The next four subsections explain how the different types of
probes work and how jump optimization works.  They explain certain
things that you’ll need to know in order to make the best use of
Kprobes – e.g., the difference between a pre_handler and
a post_handler, and how to use the maxactive and nmissed fields of
a kretprobe.  But if you’re in a hurry to start using Kprobes, you
can skip ahead to <a class="reference internal" href="#kprobes-archs-supported"><span class="std std-ref">Architectures Supported</span></a>.</p>
<div class="section" id="how-does-a-kprobe-work">
<h3>How Does a Kprobe Work?<a class="headerlink" href="#how-does-a-kprobe-work" title="Permalink to this headline">¶</a></h3>
<p>When a kprobe is registered, Kprobes makes a copy of the probed
instruction and replaces the first byte(s) of the probed instruction
with a breakpoint instruction (e.g., int3 on i386 and x86_64).</p>
<p>When a CPU hits the breakpoint instruction, a trap occurs, the CPU’s
registers are saved, and control passes to Kprobes via the
notifier_call_chain mechanism.  Kprobes executes the “pre_handler”
associated with the kprobe, passing the handler the addresses of the
kprobe struct and the saved registers.</p>
<p>Next, Kprobes single-steps its copy of the probed instruction.
(It would be simpler to single-step the actual instruction in place,
but then Kprobes would have to temporarily remove the breakpoint
instruction.  This would open a small time window when another CPU
could sail right past the probepoint.)</p>
<p>After the instruction is single-stepped, Kprobes executes the
“post_handler,” if any, that is associated with the kprobe.
Execution then continues with the instruction following the probepoint.</p>
</div>
<div class="section" id="changing-execution-path">
<h3>Changing Execution Path<a class="headerlink" href="#changing-execution-path" title="Permalink to this headline">¶</a></h3>
<p>Since kprobes can probe into a running kernel code, it can change the
register set, including instruction pointer. This operation requires
maximum care, such as keeping the stack frame, recovering the execution
path etc. Since it operates on a running kernel and needs deep knowledge
of computer architecture and concurrent computing, you can easily shoot
your foot.</p>
<p>If you change the instruction pointer (and set up other related
registers) in pre_handler, you must return !0 so that kprobes stops
single stepping and just returns to the given address.
This also means post_handler should not be called anymore.</p>
<p>Note that this operation may be harder on some architectures which use
TOC (Table of Contents) for function call, since you have to setup a new
TOC for your function in your module, and recover the old one after
returning from it.</p>
</div>
<div class="section" id="return-probes">
<h3>Return Probes<a class="headerlink" href="#return-probes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="how-does-a-return-probe-work">
<h4>How Does a Return Probe Work?<a class="headerlink" href="#how-does-a-return-probe-work" title="Permalink to this headline">¶</a></h4>
<p>When you call register_kretprobe(), Kprobes establishes a kprobe at
the entry to the function.  When the probed function is called and this
probe is hit, Kprobes saves a copy of the return address, and replaces
the return address with the address of a “trampoline.”  The trampoline
is an arbitrary piece of code – typically just a nop instruction.
At boot time, Kprobes registers a kprobe at the trampoline.</p>
<p>When the probed function executes its return instruction, control
passes to the trampoline and that probe is hit.  Kprobes’ trampoline
handler calls the user-specified return handler associated with the
kretprobe, then sets the saved instruction pointer to the saved return
address, and that’s where execution resumes upon return from the trap.</p>
<p>While the probed function is executing, its return address is
stored in an object of type kretprobe_instance.  Before calling
register_kretprobe(), the user sets the maxactive field of the
kretprobe struct to specify how many instances of the specified
function can be probed simultaneously.  register_kretprobe()
pre-allocates the indicated number of kretprobe_instance objects.</p>
<p>For example, if the function is non-recursive and is called with a
spinlock held, maxactive = 1 should be enough.  If the function is
non-recursive and can never relinquish the CPU (e.g., via a semaphore
or preemption), NR_CPUS should be enough.  If maxactive &lt;= 0, it is
set to a default value.  If CONFIG_PREEMPT is enabled, the default
is max(10, 2*NR_CPUS).  Otherwise, the default is NR_CPUS.</p>
<p>It’s not a disaster if you set maxactive too low; you’ll just miss
some probes.  In the kretprobe struct, the nmissed field is set to
zero when the return probe is registered, and is incremented every
time the probed function is entered but there is no kretprobe_instance
object available for establishing the return probe.</p>
</div>
<div class="section" id="kretprobe-entry-handler">
<h4>Kretprobe entry-handler<a class="headerlink" href="#kretprobe-entry-handler" title="Permalink to this headline">¶</a></h4>
<p>Kretprobes also provides an optional user-specified handler which runs
on function entry. This handler is specified by setting the entry_handler
field of the kretprobe struct. Whenever the kprobe placed by kretprobe at the
function entry is hit, the user-defined entry_handler, if any, is invoked.
If the entry_handler returns 0 (success) then a corresponding return handler
is guaranteed to be called upon function return. If the entry_handler
returns a non-zero error then Kprobes leaves the return address as is, and
the kretprobe has no further effect for that particular function instance.</p>
<p>Multiple entry and return handler invocations are matched using the unique
kretprobe_instance object associated with them. Additionally, a user
may also specify per return-instance private data to be part of each
kretprobe_instance object. This is especially useful when sharing private
data between corresponding user entry and return handlers. The size of each
private data object can be specified at kretprobe registration time by
setting the data_size field of the kretprobe struct. This data can be
accessed through the data field of each kretprobe_instance object.</p>
<p>In case probed function is entered but there is no kretprobe_instance
object available, then in addition to incrementing the nmissed count,
the user entry_handler invocation is also skipped.</p>
</div>
</div>
<div class="section" id="how-does-jump-optimization-work">
<span id="kprobes-jump-optimization"></span><h3>How Does Jump Optimization Work?<a class="headerlink" href="#how-does-jump-optimization-work" title="Permalink to this headline">¶</a></h3>
<p>If your kernel is built with CONFIG_OPTPROBES=y (currently this flag
is automatically set ‘y’ on x86/x86-64, non-preemptive kernel) and
the “debug.kprobes_optimization” kernel parameter is set to 1 (see
sysctl(8)), Kprobes tries to reduce probe-hit overhead by using a jump
instruction instead of a breakpoint instruction at each probepoint.</p>
<div class="section" id="init-a-kprobe">
<h4>Init a Kprobe<a class="headerlink" href="#init-a-kprobe" title="Permalink to this headline">¶</a></h4>
<p>When a probe is registered, before attempting this optimization,
Kprobes inserts an ordinary, breakpoint-based kprobe at the specified
address. So, even if it’s not possible to optimize this particular
probepoint, there’ll be a probe there.</p>
</div>
<div class="section" id="safety-check">
<h4>Safety Check<a class="headerlink" href="#safety-check" title="Permalink to this headline">¶</a></h4>
<p>Before optimizing a probe, Kprobes performs the following safety checks:</p>
<ul class="simple">
<li>Kprobes verifies that the region that will be replaced by the jump
instruction (the “optimized region”) lies entirely within one function.
(A jump instruction is multiple bytes, and so may overlay multiple
instructions.)</li>
<li>Kprobes analyzes the entire function and verifies that there is no
jump into the optimized region.  Specifically:<ul>
<li>the function contains no indirect jump;</li>
<li>the function contains no instruction that causes an exception (since
the fixup code triggered by the exception could jump back into the
optimized region – Kprobes checks the exception tables to verify this);</li>
<li>there is no near jump to the optimized region (other than to the first
byte).</li>
</ul>
</li>
<li>For each instruction in the optimized region, Kprobes verifies that
the instruction can be executed out of line.</li>
</ul>
</div>
<div class="section" id="preparing-detour-buffer">
<h4>Preparing Detour Buffer<a class="headerlink" href="#preparing-detour-buffer" title="Permalink to this headline">¶</a></h4>
<p>Next, Kprobes prepares a “detour” buffer, which contains the following
instruction sequence:</p>
<ul class="simple">
<li>code to push the CPU’s registers (emulating a breakpoint trap)</li>
<li>a call to the trampoline code which calls user’s probe handlers.</li>
<li>code to restore registers</li>
<li>the instructions from the optimized region</li>
<li>a jump back to the original execution path.</li>
</ul>
</div>
<div class="section" id="pre-optimization">
<h4>Pre-optimization<a class="headerlink" href="#pre-optimization" title="Permalink to this headline">¶</a></h4>
<p>After preparing the detour buffer, Kprobes verifies that none of the
following situations exist:</p>
<ul class="simple">
<li>The probe has a post_handler.</li>
<li>Other instructions in the optimized region are probed.</li>
<li>The probe is disabled.</li>
</ul>
<p>In any of the above cases, Kprobes won’t start optimizing the probe.
Since these are temporary situations, Kprobes tries to start
optimizing it again if the situation is changed.</p>
<p>If the kprobe can be optimized, Kprobes enqueues the kprobe to an
optimizing list, and kicks the kprobe-optimizer workqueue to optimize
it.  If the to-be-optimized probepoint is hit before being optimized,
Kprobes returns control to the original instruction path by setting
the CPU’s instruction pointer to the copied code in the detour buffer
– thus at least avoiding the single-step.</p>
</div>
<div class="section" id="optimization">
<h4>Optimization<a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h4>
<p>The Kprobe-optimizer doesn’t insert the jump instruction immediately;
rather, it calls <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> for safety first, because it’s
possible for a CPU to be interrupted in the middle of executing the
optimized region <a class="footnote-reference" href="#id5" id="id3">[3]</a>.  As you know, <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> can ensure
that all interruptions that were active when <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>
was called are done, but only if CONFIG_PREEMPT=n.  So, this version
of kprobe optimization supports only kernels with CONFIG_PREEMPT=n <a class="footnote-reference" href="#id6" id="id4">[4]</a>.</p>
<p>After that, the Kprobe-optimizer calls stop_machine() to replace
the optimized region with a jump instruction to the detour buffer,
using text_poke_smp().</p>
</div>
<div class="section" id="unoptimization">
<h4>Unoptimization<a class="headerlink" href="#unoptimization" title="Permalink to this headline">¶</a></h4>
<p>When an optimized kprobe is unregistered, disabled, or blocked by
another kprobe, it will be unoptimized.  If this happens before
the optimization is complete, the kprobe is just dequeued from the
optimized list.  If the optimization has been done, the jump is
replaced with the original code (except for an int3 breakpoint in
the first byte) by using text_poke_smp().</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Please imagine that the 2nd instruction is interrupted and then
the optimizer replaces the 2nd instruction with the jump <em>address</em>
while the interrupt handler is running. When the interrupt
returns to original address, there is no valid instruction,
and it causes an unexpected result.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>This optimization-safety checking may be replaced with the
stop-machine method that ksplice uses for supporting a CONFIG_PREEMPT=y
kernel.</td></tr>
</tbody>
</table>
<p>NOTE for geeks:
The jump optimization changes the kprobe’s pre_handler behavior.
Without optimization, the pre_handler can change the kernel’s execution
path by changing regs-&gt;ip and returning 1.  However, when the probe
is optimized, that modification is ignored.  Thus, if you want to
tweak the kernel’s execution path, you need to suppress optimization,
using one of the following techniques:</p>
<ul class="simple">
<li>Specify an empty function for the kprobe’s post_handler.</li>
</ul>
<p>or</p>
<ul class="simple">
<li>Execute ‘sysctl -w debug.kprobes_optimization=n’</li>
</ul>
</div>
</div>
<div class="section" id="blacklist">
<span id="kprobes-blacklist"></span><h3>Blacklist<a class="headerlink" href="#blacklist" title="Permalink to this headline">¶</a></h3>
<p>Kprobes can probe most of the kernel except itself. This means
that there are some functions where kprobes cannot probe. Probing
(trapping) such functions can cause a recursive trap (e.g. double
fault) or the nested probe handler may never be called.
Kprobes manages such functions as a blacklist.
If you want to add a function into the blacklist, you just need
to (1) include linux/kprobes.h and (2) use NOKPROBE_SYMBOL() macro
to specify a blacklisted function.
Kprobes checks the given probe address against the blacklist and
rejects registering it, if the given address is in the blacklist.</p>
</div>
</div>
<div class="section" id="architectures-supported">
<span id="kprobes-archs-supported"></span><h2>Architectures Supported<a class="headerlink" href="#architectures-supported" title="Permalink to this headline">¶</a></h2>
<p>Kprobes and return probes are implemented on the following
architectures:</p>
<ul class="simple">
<li>i386 (Supports jump optimization)</li>
<li>x86_64 (AMD-64, EM64T) (Supports jump optimization)</li>
<li>ppc64</li>
<li>ia64 (Does not support probes on instruction slot1.)</li>
<li>sparc64 (Return probes not yet implemented.)</li>
<li>arm</li>
<li>ppc</li>
<li>mips</li>
<li>s390</li>
<li>parisc</li>
</ul>
</div>
<div class="section" id="configuring-kprobes">
<h2>Configuring Kprobes<a class="headerlink" href="#configuring-kprobes" title="Permalink to this headline">¶</a></h2>
<p>When configuring the kernel using make menuconfig/xconfig/oldconfig,
ensure that CONFIG_KPROBES is set to “y”. Under “General setup”, look
for “Kprobes”.</p>
<p>So that you can load and unload Kprobes-based instrumentation modules,
make sure “Loadable module support” (CONFIG_MODULES) and “Module
unloading” (CONFIG_MODULE_UNLOAD) are set to “y”.</p>
<p>Also make sure that CONFIG_KALLSYMS and perhaps even CONFIG_KALLSYMS_ALL
are set to “y”, since kallsyms_lookup_name() is used by the in-kernel
kprobe address resolution code.</p>
<p>If you need to insert a probe in the middle of a function, you may find
it useful to “Compile the kernel with debug info” (CONFIG_DEBUG_INFO),
so you can use “objdump -d -l vmlinux” to see the source-to-object
code mapping.</p>
</div>
<div class="section" id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<p>The Kprobes API includes a “register” function and an “unregister”
function for each type of probe. The API also includes “register_*probes”
and “unregister_*probes” functions for (un)registering arrays of probes.
Here are terse, mini-man-page specifications for these functions and
the associated probe handlers that you’ll write. See the files in the
samples/kprobes/ sub-directory for examples.</p>
<div class="section" id="register-kprobe">
<h3>register_kprobe<a class="headerlink" href="#register-kprobe" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/kprobes.h&gt;
int register_kprobe(struct kprobe *kp);
</pre></div>
</div>
<p>Sets a breakpoint at the address kp-&gt;addr.  When the breakpoint is hit, Kprobes
calls kp-&gt;pre_handler.  After the probed instruction is single-stepped, Kprobe
calls kp-&gt;post_handler.  Any or all handlers can be NULL. If kp-&gt;flags is set
KPROBE_FLAG_DISABLED, that kp will be registered but disabled, so, its handlers
aren’t hit until calling enable_kprobe(kp).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic">
<li><p class="first">With the introduction of the “symbol_name” field to struct kprobe,
the probepoint address resolution will now be taken care of by the kernel.
The following will now work:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kp.symbol_name = &quot;symbol_name&quot;;
</pre></div>
</div>
<p>(64-bit powerpc intricacies such as function descriptors are handled
transparently)</p>
</li>
<li><p class="first">Use the “offset” field of struct kprobe if the offset into the symbol
to install a probepoint is known. This field is used to calculate the
probepoint.</p>
</li>
<li><p class="first">Specify either the kprobe “symbol_name” OR the “addr”. If both are
specified, kprobe registration will fail with -EINVAL.</p>
</li>
<li><p class="first">With CISC architectures (such as i386 and x86_64), the kprobes code
does not validate if the kprobe.addr is at an instruction boundary.
Use “offset” with caution.</p>
</li>
</ol>
</div>
<p>register_kprobe() returns 0 on success, or a negative errno otherwise.</p>
<p>User’s pre-handler (kp-&gt;pre_handler):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/kprobes.h&gt;
#include &lt;linux/ptrace.h&gt;
int pre_handler(struct kprobe *p, struct pt_regs *regs);
</pre></div>
</div>
<p>Called with p pointing to the kprobe associated with the breakpoint,
and regs pointing to the struct containing the registers saved when
the breakpoint was hit.  Return 0 here unless you’re a Kprobes geek.</p>
<p>User’s post-handler (kp-&gt;post_handler):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/kprobes.h&gt;
#include &lt;linux/ptrace.h&gt;
void post_handler(struct kprobe *p, struct pt_regs *regs,
                  unsigned long flags);
</pre></div>
</div>
<p>p and regs are as described for the pre_handler.  flags always seems
to be zero.</p>
</div>
<div class="section" id="register-kretprobe">
<h3>register_kretprobe<a class="headerlink" href="#register-kretprobe" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/kprobes.h&gt;
int register_kretprobe(struct kretprobe *rp);
</pre></div>
</div>
<p>Establishes a return probe for the function whose address is
rp-&gt;kp.addr.  When that function returns, Kprobes calls rp-&gt;handler.
You must set rp-&gt;maxactive appropriately before you call
register_kretprobe(); see “How Does a Return Probe Work?” for details.</p>
<p>register_kretprobe() returns 0 on success, or a negative errno
otherwise.</p>
<p>User’s return-probe handler (rp-&gt;handler):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/kprobes.h&gt;
#include &lt;linux/ptrace.h&gt;
int kretprobe_handler(struct kretprobe_instance *ri,
                      struct pt_regs *regs);
</pre></div>
</div>
<p>regs is as described for kprobe.pre_handler.  ri points to the
kretprobe_instance object, of which the following fields may be
of interest:</p>
<ul class="simple">
<li>ret_addr: the return address</li>
<li>rp: points to the corresponding kretprobe object</li>
<li>task: points to the corresponding task struct</li>
<li><dl class="first docutils">
<dt>data: points to per return-instance private data; see “Kretprobe</dt>
<dd>entry-handler” for details.</dd>
</dl>
</li>
</ul>
<p>The regs_return_value(regs) macro provides a simple abstraction to
extract the return value from the appropriate register as defined by
the architecture’s ABI.</p>
<p>The handler’s return value is currently ignored.</p>
</div>
<div class="section" id="unregister-probe">
<h3>unregister_*probe<a class="headerlink" href="#unregister-probe" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/kprobes.h&gt;
void unregister_kprobe(struct kprobe *kp);
void unregister_kretprobe(struct kretprobe *rp);
</pre></div>
</div>
<p>Removes the specified probe.  The unregister function can be called
at any time after the probe has been registered.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the functions find an incorrect probe (ex. an unregistered probe),
they clear the addr field of the probe.</p>
</div>
</div>
<div class="section" id="register-probes">
<h3>register_*probes<a class="headerlink" href="#register-probes" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/kprobes.h&gt;
int register_kprobes(struct kprobe **kps, int num);
int register_kretprobes(struct kretprobe **rps, int num);
</pre></div>
</div>
<p>Registers each of the num probes in the specified array.  If any
error occurs during registration, all probes in the array, up to
the bad probe, are safely unregistered before the register_*probes
function returns.</p>
<ul class="simple">
<li>kps/rps: an array of pointers to <code class="docutils literal notranslate"><span class="pre">*probe</span></code> data structures</li>
<li>num: the number of the array entries.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You have to allocate(or define) an array of pointers and set all
of the array entries before using these functions.</p>
</div>
</div>
<div class="section" id="unregister-probes">
<h3>unregister_*probes<a class="headerlink" href="#unregister-probes" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/kprobes.h&gt;
void unregister_kprobes(struct kprobe **kps, int num);
void unregister_kretprobes(struct kretprobe **rps, int num);
</pre></div>
</div>
<p>Removes each of the num probes in the specified array at once.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the functions find some incorrect probes (ex. unregistered
probes) in the specified array, they clear the addr field of those
incorrect probes. However, other probes in the array are
unregistered correctly.</p>
</div>
</div>
<div class="section" id="disable-probe">
<h3>disable_*probe<a class="headerlink" href="#disable-probe" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/kprobes.h&gt;
int disable_kprobe(struct kprobe *kp);
int disable_kretprobe(struct kretprobe *rp);
</pre></div>
</div>
<p>Temporarily disables the specified <code class="docutils literal notranslate"><span class="pre">*probe</span></code>. You can enable it again by using
enable_*probe(). You must specify the probe which has been registered.</p>
</div>
<div class="section" id="enable-probe">
<h3>enable_*probe<a class="headerlink" href="#enable-probe" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/kprobes.h&gt;
int enable_kprobe(struct kprobe *kp);
int enable_kretprobe(struct kretprobe *rp);
</pre></div>
</div>
<p>Enables <code class="docutils literal notranslate"><span class="pre">*probe</span></code> which has been disabled by disable_*probe(). You must specify
the probe which has been registered.</p>
</div>
</div>
<div class="section" id="kprobes-features-and-limitations">
<h2>Kprobes Features and Limitations<a class="headerlink" href="#kprobes-features-and-limitations" title="Permalink to this headline">¶</a></h2>
<p>Kprobes allows multiple probes at the same address. Also,
a probepoint for which there is a post_handler cannot be optimized.
So if you install a kprobe with a post_handler, at an optimized
probepoint, the probepoint will be unoptimized automatically.</p>
<p>In general, you can install a probe anywhere in the kernel.
In particular, you can probe interrupt handlers.  Known exceptions
are discussed in this section.</p>
<p>The register_*probe functions will return -EINVAL if you attempt
to install a probe in the code that implements Kprobes (mostly
kernel/kprobes.c and <code class="docutils literal notranslate"><span class="pre">arch/*/kernel/kprobes.c</span></code>, but also functions such
as do_page_fault and notifier_call_chain).</p>
<p>If you install a probe in an inline-able function, Kprobes makes
no attempt to chase down all inline instances of the function and
install probes there.  gcc may inline a function without being asked,
so keep this in mind if you’re not seeing the probe hits you expect.</p>
<p>A probe handler can modify the environment of the probed function
– e.g., by modifying kernel data structures, or by modifying the
contents of the pt_regs struct (which are restored to the registers
upon return from the breakpoint).  So Kprobes can be used, for example,
to install a bug fix or to inject faults for testing.  Kprobes, of
course, has no way to distinguish the deliberately injected faults
from the accidental ones.  Don’t drink and probe.</p>
<p>Kprobes makes no attempt to prevent probe handlers from stepping on
each other – e.g., probing <a class="reference internal" href="../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> and then calling <a class="reference internal" href="../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> from a
probe handler.  If a probe handler hits a probe, that second probe’s
handlers won’t be run in that instance, and the kprobe.nmissed member
of the second probe will be incremented.</p>
<p>As of Linux v2.6.15-rc1, multiple handlers (or multiple instances of
the same handler) may run concurrently on different CPUs.</p>
<p>Kprobes does not use mutexes or allocate memory except during
registration and unregistration.</p>
<p>Probe handlers are run with preemption disabled or interrupt disabled,
which depends on the architecture and optimization state.  (e.g.,
kretprobe handlers and optimized kprobe handlers run without interrupt
disabled on x86/x86-64).  In any case, your handler should not yield
the CPU (e.g., by attempting to acquire a semaphore, or waiting I/O).</p>
<p>Since a return probe is implemented by replacing the return
address with the trampoline’s address, stack backtraces and calls
to __builtin_return_address() will typically yield the trampoline’s
address instead of the real return address for kretprobed functions.
(As far as we can tell, __builtin_return_address() is used only
for instrumentation and error reporting.)</p>
<p>If the number of times a function is called does not match the number
of times it returns, registering a return probe on that function may
produce undesirable results. In such a case, a line:
kretprobe BUG!: Processing kretprobe d000000000041aa8 &#64; c00000000004f48c
gets printed. With this information, one will be able to correlate the
exact instance of the kretprobe that caused the problem. We have the
do_exit() case covered. do_execve() and do_fork() are not an issue.
We’re unaware of other specific cases where this could be a problem.</p>
<p>If, upon entry to or exit from a function, the CPU is running on
a stack other than that of the current task, registering a return
probe on that function may produce undesirable results.  For this
reason, Kprobes doesn’t support return probes (or kprobes)
on the x86_64 version of __switch_to(); the registration functions
return -EINVAL.</p>
<p>On x86/x86-64, since the Jump Optimization of Kprobes modifies
instructions widely, there are some limitations to optimization. To
explain it, we introduce some terminology. Imagine a 3-instruction
sequence consisting of a two 2-byte instructions and one 3-byte
instruction.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        IA
        |
[-2][-1][0][1][2][3][4][5][6][7]
        [ins1][ins2][  ins3 ]
        [&lt;-     DCR       -&gt;]
        [&lt;- JTPR -&gt;]

ins1: 1st Instruction
ins2: 2nd Instruction
ins3: 3rd Instruction
IA:  Insertion Address
JTPR: Jump Target Prohibition Region
DCR: Detoured Code Region
</pre></div>
</div>
<p>The instructions in DCR are copied to the out-of-line buffer
of the kprobe, because the bytes in DCR are replaced by
a 5-byte jump instruction. So there are several limitations.</p>
<ol class="loweralpha simple">
<li>The instructions in DCR must be relocatable.</li>
<li>The instructions in DCR must not include a call instruction.</li>
<li>JTPR must not be targeted by any jump or call instruction.</li>
<li>DCR must not straddle the border between functions.</li>
</ol>
<p>Anyway, these limitations are checked by the in-kernel instruction
decoder, so you don’t need to worry about that.</p>
</div>
<div class="section" id="probe-overhead">
<h2>Probe Overhead<a class="headerlink" href="#probe-overhead" title="Permalink to this headline">¶</a></h2>
<p>On a typical CPU in use in 2005, a kprobe hit takes 0.5 to 1.0
microseconds to process.  Specifically, a benchmark that hits the same
probepoint repeatedly, firing a simple handler each time, reports 1-2
million hits per second, depending on the architecture.  A return-probe
hit typically takes 50-75% longer than a kprobe hit.
When you have a return probe set on a function, adding a kprobe at
the entry to that function adds essentially no overhead.</p>
<p>Here are sample overhead figures (in usec) for different architectures:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>k = kprobe; r = return probe; kr = kprobe + return probe
on same function

i386: Intel Pentium M, 1495 MHz, 2957.31 bogomips
k = 0.57 usec; r = 0.92; kr = 0.99

x86_64: AMD Opteron 246, 1994 MHz, 3971.48 bogomips
k = 0.49 usec; r = 0.80; kr = 0.82

ppc64: POWER5 (gr), 1656 MHz (SMT disabled, 1 virtual CPU per physical CPU)
k = 0.77 usec; r = 1.26; kr = 1.45
</pre></div>
</div>
<div class="section" id="optimized-probe-overhead">
<h3>Optimized Probe Overhead<a class="headerlink" href="#optimized-probe-overhead" title="Permalink to this headline">¶</a></h3>
<p>Typically, an optimized kprobe hit takes 0.07 to 0.1 microseconds to
process. Here are sample overhead figures (in usec) for x86 architectures:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>k = unoptimized kprobe, b = boosted (single-step skipped), o = optimized kprobe,
r = unoptimized kretprobe, rb = boosted kretprobe, ro = optimized kretprobe.

i386: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips
k = 0.80 usec; b = 0.33; o = 0.05; r = 1.10; rb = 0.61; ro = 0.33

x86-64: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips
k = 0.99 usec; b = 0.43; o = 0.06; r = 1.24; rb = 0.68; ro = 0.30
</pre></div>
</div>
</div>
</div>
<div class="section" id="todo">
<h2>TODO<a class="headerlink" href="#todo" title="Permalink to this headline">¶</a></h2>
<ol class="loweralpha simple">
<li>SystemTap (<a class="reference external" href="http://sourceware.org/systemtap">http://sourceware.org/systemtap</a>): Provides a simplified
programming interface for probe-based instrumentation.  Try it out.</li>
<li>Kernel return probes for sparc64.</li>
<li>Support for other architectures.</li>
<li>User-space probes.</li>
<li>Watchpoint probes (which fire on data references).</li>
</ol>
</div>
<div class="section" id="kprobes-example">
<h2>Kprobes Example<a class="headerlink" href="#kprobes-example" title="Permalink to this headline">¶</a></h2>
<p>See samples/kprobes/kprobe_example.c</p>
</div>
<div class="section" id="kretprobes-example">
<h2>Kretprobes Example<a class="headerlink" href="#kretprobes-example" title="Permalink to this headline">¶</a></h2>
<p>See samples/kprobes/kretprobe_example.c</p>
</div>
<div class="section" id="deprecated-features">
<h2>Deprecated Features<a class="headerlink" href="#deprecated-features" title="Permalink to this headline">¶</a></h2>
<p>Jprobes is now a deprecated feature. People who are depending on it should
migrate to other tracing features or use older kernels. Please consider to
migrate your tool to one of the following options:</p>
<ul>
<li><p class="first">Use trace-event to trace target function with arguments.</p>
<p>trace-event is a low-overhead (and almost no visible overhead if it
is off) statically defined event interface. You can define new events
and trace it via ftrace or any other tracing tools.</p>
<p>See the following urls:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://lwn.net/Articles/379903/">https://lwn.net/Articles/379903/</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/381064/">https://lwn.net/Articles/381064/</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/383362/">https://lwn.net/Articles/383362/</a></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Use ftrace dynamic events (kprobe event) with perf-probe.</p>
<p>If you build your kernel with debug info (CONFIG_DEBUG_INFO=y), you can
find which register/stack is assigned to which local variable or arguments
by using perf-probe and set up new event to trace it.</p>
<p>See following documents:</p>
<ul class="simple">
<li><a class="reference internal" href="kprobetrace.html"><span class="doc">Kprobe-based Event Tracing</span></a></li>
<li><a class="reference internal" href="events.html"><span class="doc">Event Tracing</span></a></li>
<li>tools/perf/Documentation/perf-probe.txt</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="the-kprobes-debugfs-interface">
<h2>The kprobes debugfs interface<a class="headerlink" href="#the-kprobes-debugfs-interface" title="Permalink to this headline">¶</a></h2>
<p>With recent kernels (&gt; 2.6.20) the list of registered kprobes is visible
under the /sys/kernel/debug/kprobes/ directory (assuming debugfs is mounted at //sys/kernel/debug).</p>
<p>/sys/kernel/debug/kprobes/list: Lists all registered probes on the system:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>c015d71a  k  vfs_read+0x0
c03dedc5  r  tcp_v4_rcv+0x0
</pre></div>
</div>
<p>The first column provides the kernel address where the probe is inserted.
The second column identifies the type of probe (k - kprobe and r - kretprobe)
while the third column specifies the symbol+offset of the probe.
If the probed function belongs to a module, the module name is also
specified. Following columns show probe status. If the probe is on
a virtual address that is no longer valid (module init sections, module
virtual addresses that correspond to modules that’ve been unloaded),
such probes are marked with [GONE]. If the probe is temporarily disabled,
such probes are marked with [DISABLED]. If the probe is optimized, it is
marked with [OPTIMIZED]. If the probe is ftrace-based, it is marked with
[FTRACE].</p>
<p>/sys/kernel/debug/kprobes/enabled: Turn kprobes ON/OFF forcibly.</p>
<p>Provides a knob to globally and forcibly turn registered kprobes ON or OFF.
By default, all kprobes are enabled. By echoing “0” to this file, all
registered probes will be disarmed, till such time a “1” is echoed to this
file. Note that this knob just disarms and arms all kprobes and doesn’t
change each probe’s disabling state. This means that disabled kprobes (marked
[DISABLED]) will be not enabled if you turn ON all kprobes by this knob.</p>
</div>
<div class="section" id="the-kprobes-sysctl-interface">
<h2>The kprobes sysctl interface<a class="headerlink" href="#the-kprobes-sysctl-interface" title="Permalink to this headline">¶</a></h2>
<p>/proc/sys/debug/kprobes-optimization: Turn kprobes optimization ON/OFF.</p>
<p>When CONFIG_OPTPROBES=y, this sysctl interface appears and it provides
a knob to globally and forcibly turn jump optimization (see section
<a class="reference internal" href="#kprobes-jump-optimization"><span class="std std-ref">How Does Jump Optimization Work?</span></a>) ON or OFF. By default, jump optimization
is allowed (ON). If you echo “0” to this file or set
“debug.kprobes_optimization” to 0 via sysctl, all optimized probes will be
unoptimized, and any new probes registered after that will not be optimized.</p>
<p>Note that this knob <em>changes</em> the optimized state. This means that optimized
probes (marked [OPTIMIZED]) will be unoptimized ([OPTIMIZED] tag will be
removed). If the knob is turned on, they will be optimized again.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>For additional information on Kprobes, refer to the following URLs:</p>
<ul class="simple">
<li><a class="reference external" href="https://lwn.net/Articles/132196/">https://lwn.net/Articles/132196/</a></li>
<li><a class="reference external" href="https://www.kernel.org/doc/ols/2006/ols2006v2-pages-109-124.pdf">https://www.kernel.org/doc/ols/2006/ols2006v2-pages-109-124.pdf</a></li>
</ul>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="kprobetrace.html" class="btn btn-neutral float-right" title="Kprobe-based Event Tracing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="fprobe.html" class="btn btn-neutral" title="Fprobe - Function entry/exit probe" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>