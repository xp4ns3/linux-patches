

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernel Electric-Fence (KFENCE) &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Development tools for the kernel" href="index.html"/>
        <link rel="next" title="Debugging kernel and modules via gdb" href="gdb-kernel-debugging.html"/>
        <link rel="prev" title="The Kernel Concurrency Sanitizer (KCSAN)" href="kcsan.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Development tools for the kernel</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="checkpatch.html">Checkpatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="coccinelle.html">Coccinelle</a></li>
<li class="toctree-l2"><a class="reference internal" href="sparse.html">Sparse</a></li>
<li class="toctree-l2"><a class="reference internal" href="kcov.html">kcov: code coverage for fuzzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="gcov.html">Using gcov with the Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="kasan.html">The Kernel Address Sanitizer (KASAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ubsan.html">The Undefined Behavior Sanitizer - UBSAN</a></li>
<li class="toctree-l2"><a class="reference internal" href="kmemleak.html">Kernel Memory Leak Detector</a></li>
<li class="toctree-l2"><a class="reference internal" href="kcsan.html">The Kernel Concurrency Sanitizer (KCSAN)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Kernel Electric-Fence (KFENCE)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#usage">Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tuning-performance">Tuning performance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-reports">Error reports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debugfs-interface">DebugFS interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-details">Implementation Details</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interface">Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#related-tools">Related Tools</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gdb-kernel-debugging.html">Debugging kernel and modules via gdb</a></li>
<li class="toctree-l2"><a class="reference internal" href="kgdb.html">Using kgdb, kdb and the kernel debugger internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="kselftest.html">Linux Kernel Selftests</a></li>
<li class="toctree-l2"><a class="reference internal" href="kunit/index.html">KUnit - Linux Kernel Unit Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="ktap.html">The Kernel Test Anything Protocol (KTAP), version 1</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Development tools for the kernel</a> &raquo;</li>
        
      <li>Kernel Electric-Fence (KFENCE)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/dev-tools/kfence.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kernel-electric-fence-kfence">
<h1>Kernel Electric-Fence (KFENCE)<a class="headerlink" href="#kernel-electric-fence-kfence" title="Permalink to this headline">¶</a></h1>
<p>Kernel Electric-Fence (KFENCE) is a low-overhead sampling-based memory safety
error detector. KFENCE detects heap out-of-bounds access, use-after-free, and
invalid-free errors.</p>
<p>KFENCE is designed to be enabled in production kernels, and has near zero
performance overhead. Compared to KASAN, KFENCE trades performance for
precision. The main motivation behind KFENCE’s design, is that with enough
total uptime KFENCE will detect bugs in code paths not typically exercised by
non-production test workloads. One way to quickly achieve a large enough total
uptime is when the tool is deployed across a large fleet of machines.</p>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>To enable KFENCE, configure the kernel with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_KFENCE=y
</pre></div>
</div>
<p>To build a kernel with KFENCE support, but disabled by default (to enable, set
<code class="docutils literal notranslate"><span class="pre">kfence.sample_interval</span></code> to non-zero value), configure the kernel with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CONFIG_KFENCE=y
CONFIG_KFENCE_SAMPLE_INTERVAL=0
</pre></div>
</div>
<p>KFENCE provides several other configuration options to customize behaviour (see
the respective help text in <code class="docutils literal notranslate"><span class="pre">lib/Kconfig.kfence</span></code> for more info).</p>
<div class="section" id="tuning-performance">
<h3>Tuning performance<a class="headerlink" href="#tuning-performance" title="Permalink to this headline">¶</a></h3>
<p>The most important parameter is KFENCE’s sample interval, which can be set via
the kernel boot parameter <code class="docutils literal notranslate"><span class="pre">kfence.sample_interval</span></code> in milliseconds. The
sample interval determines the frequency with which heap allocations will be
guarded by KFENCE. The default is configurable via the Kconfig option
<code class="docutils literal notranslate"><span class="pre">CONFIG_KFENCE_SAMPLE_INTERVAL</span></code>. Setting <code class="docutils literal notranslate"><span class="pre">kfence.sample_interval=0</span></code>
disables KFENCE.</p>
<p>The sample interval controls a timer that sets up KFENCE allocations. By
default, to keep the real sample interval predictable, the normal timer also
causes CPU wake-ups when the system is completely idle. This may be undesirable
on power-constrained systems. The boot parameter <code class="docutils literal notranslate"><span class="pre">kfence.deferrable=1</span></code>
instead switches to a “deferrable” timer which does not force CPU wake-ups on
idle systems, at the risk of unpredictable sample intervals. The default is
configurable via the Kconfig option <code class="docutils literal notranslate"><span class="pre">CONFIG_KFENCE_DEFERRABLE</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The KUnit test suite is very likely to fail when using a deferrable timer
since it currently causes very unpredictable sample intervals.</p>
</div>
<p>The KFENCE memory pool is of fixed size, and if the pool is exhausted, no
further KFENCE allocations occur. With <code class="docutils literal notranslate"><span class="pre">CONFIG_KFENCE_NUM_OBJECTS</span></code> (default
255), the number of available guarded objects can be controlled. Each object
requires 2 pages, one for the object itself and the other one used as a guard
page; object pages are interleaved with guard pages, and every object page is
therefore surrounded by two guard pages.</p>
<p>The total memory dedicated to the KFENCE memory pool can be computed as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>( #objects + 1 ) * 2 * PAGE_SIZE
</pre></div>
</div>
<p>Using the default config, and assuming a page size of 4 KiB, results in
dedicating 2 MiB to the KFENCE memory pool.</p>
<p>Note: On architectures that support huge pages, KFENCE will ensure that the
pool is using pages of size <code class="docutils literal notranslate"><span class="pre">PAGE_SIZE</span></code>. This will result in additional page
tables being allocated.</p>
</div>
<div class="section" id="error-reports">
<h3>Error reports<a class="headerlink" href="#error-reports" title="Permalink to this headline">¶</a></h3>
<p>A typical out-of-bounds access looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================================
BUG: KFENCE: out-of-bounds read in test_out_of_bounds_read+0xa6/0x234

Out-of-bounds read at 0xffff8c3f2e291fff (1B left of kfence-#72):
 test_out_of_bounds_read+0xa6/0x234
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

kfence-#72: 0xffff8c3f2e292000-0xffff8c3f2e29201f, size=32, cache=kmalloc-32

allocated by task 484 on cpu 0 at 32.919330s:
 test_alloc+0xfe/0x738
 test_out_of_bounds_read+0x9b/0x234
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

CPU: 0 PID: 484 Comm: kunit_try_catch Not tainted 5.13.0-rc3+ #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
==================================================================
</pre></div>
</div>
<p>The header of the report provides a short summary of the function involved in
the access. It is followed by more detailed information about the access and
its origin. Note that, real kernel addresses are only shown when using the
kernel command line option <code class="docutils literal notranslate"><span class="pre">no_hash_pointers</span></code>.</p>
<p>Use-after-free accesses are reported as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================================
BUG: KFENCE: use-after-free read in test_use_after_free_read+0xb3/0x143

Use-after-free read at 0xffff8c3f2e2a0000 (in kfence-#79):
 test_use_after_free_read+0xb3/0x143
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

kfence-#79: 0xffff8c3f2e2a0000-0xffff8c3f2e2a001f, size=32, cache=kmalloc-32

allocated by task 488 on cpu 2 at 33.871326s:
 test_alloc+0xfe/0x738
 test_use_after_free_read+0x76/0x143
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

freed by task 488 on cpu 2 at 33.871358s:
 test_use_after_free_read+0xa8/0x143
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

CPU: 2 PID: 488 Comm: kunit_try_catch Tainted: G    B             5.13.0-rc3+ #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
==================================================================
</pre></div>
</div>
<p>KFENCE also reports on invalid frees, such as double-frees:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================================
BUG: KFENCE: invalid free in test_double_free+0xdc/0x171

Invalid free of 0xffff8c3f2e2a4000 (in kfence-#81):
 test_double_free+0xdc/0x171
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

kfence-#81: 0xffff8c3f2e2a4000-0xffff8c3f2e2a401f, size=32, cache=kmalloc-32

allocated by task 490 on cpu 1 at 34.175321s:
 test_alloc+0xfe/0x738
 test_double_free+0x76/0x171
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

freed by task 490 on cpu 1 at 34.175348s:
 test_double_free+0xa8/0x171
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

CPU: 1 PID: 490 Comm: kunit_try_catch Tainted: G    B             5.13.0-rc3+ #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
==================================================================
</pre></div>
</div>
<p>KFENCE also uses pattern-based redzones on the other side of an object’s guard
page, to detect out-of-bounds writes on the unprotected side of the object.
These are reported on frees:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================================
BUG: KFENCE: memory corruption in test_kmalloc_aligned_oob_write+0xef/0x184

Corrupted memory at 0xffff8c3f2e33aff9 [ 0xac . . . . . . ] (in kfence-#156):
 test_kmalloc_aligned_oob_write+0xef/0x184
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

kfence-#156: 0xffff8c3f2e33afb0-0xffff8c3f2e33aff8, size=73, cache=kmalloc-96

allocated by task 502 on cpu 7 at 42.159302s:
 test_alloc+0xfe/0x738
 test_kmalloc_aligned_oob_write+0x57/0x184
 kunit_try_run_case+0x61/0xa0
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x176/0x1b0
 ret_from_fork+0x22/0x30

CPU: 7 PID: 502 Comm: kunit_try_catch Tainted: G    B             5.13.0-rc3+ #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
==================================================================
</pre></div>
</div>
<p>For such errors, the address where the corruption occurred as well as the
invalidly written bytes (offset from the address) are shown; in this
representation, ‘.’ denote untouched bytes. In the example above <code class="docutils literal notranslate"><span class="pre">0xac</span></code> is
the value written to the invalid address at offset 0, and the remaining ‘.’
denote that no following bytes have been touched. Note that, real values are
only shown if the kernel was booted with <code class="docutils literal notranslate"><span class="pre">no_hash_pointers</span></code>; to avoid
information disclosure otherwise, ‘!’ is used instead to denote invalidly
written bytes.</p>
<p>And finally, KFENCE may also report on invalid accesses to any protected page
where it was not possible to determine an associated object, e.g. if adjacent
object pages had not yet been allocated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>==================================================================
BUG: KFENCE: invalid read in test_invalid_access+0x26/0xe0

Invalid read at 0xffffffffb670b00a:
 test_invalid_access+0x26/0xe0
 kunit_try_run_case+0x51/0x85
 kunit_generic_run_threadfn_adapter+0x16/0x30
 kthread+0x137/0x160
 ret_from_fork+0x22/0x30

CPU: 4 PID: 124 Comm: kunit_try_catch Tainted: G        W         5.8.0-rc6+ #7
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1 04/01/2014
==================================================================
</pre></div>
</div>
</div>
<div class="section" id="debugfs-interface">
<h3>DebugFS interface<a class="headerlink" href="#debugfs-interface" title="Permalink to this headline">¶</a></h3>
<p>Some debugging information is exposed via debugfs:</p>
<ul class="simple">
<li>The file <code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/kfence/stats</span></code> provides runtime statistics.</li>
<li>The file <code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/kfence/objects</span></code> provides a list of objects
allocated via KFENCE, including those already freed but protected.</li>
</ul>
</div>
</div>
<div class="section" id="implementation-details">
<h2>Implementation Details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>Guarded allocations are set up based on the sample interval. After expiration
of the sample interval, the next allocation through the main allocator (SLAB or
SLUB) returns a guarded allocation from the KFENCE object pool (allocation
sizes up to PAGE_SIZE are supported). At this point, the timer is reset, and
the next allocation is set up after the expiration of the interval.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">CONFIG_KFENCE_STATIC_KEYS=y</span></code>, KFENCE allocations are “gated”
through the main allocator’s fast-path by relying on static branches via the
static keys infrastructure. The static branch is toggled to redirect the
allocation to KFENCE. Depending on sample interval, target workloads, and
system architecture, this may perform better than the simple dynamic branch.
Careful benchmarking is recommended.</p>
<p>KFENCE objects each reside on a dedicated page, at either the left or right
page boundaries selected at random. The pages to the left and right of the
object page are “guard pages”, whose attributes are changed to a protected
state, and cause page faults on any attempted access. Such page faults are then
intercepted by KFENCE, which handles the fault gracefully by reporting an
out-of-bounds access, and marking the page as accessible so that the faulting
code can (wrongly) continue executing (set <code class="docutils literal notranslate"><span class="pre">panic_on_warn</span></code> to panic instead).</p>
<p>To detect out-of-bounds writes to memory within the object’s page itself,
KFENCE also uses pattern-based redzones. For each object page, a redzone is set
up for all non-object memory. For typical alignments, the redzone is only
required on the unguarded side of an object. Because KFENCE must honor the
cache’s requested alignment, special alignments may result in unprotected gaps
on either side of an object, all of which are redzoned.</p>
<p>The following figure illustrates the page layout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>---+-----------+-----------+-----------+-----------+-----------+---
   | xxxxxxxxx | O :       | xxxxxxxxx |       : O | xxxxxxxxx |
   | xxxxxxxxx | B :       | xxxxxxxxx |       : B | xxxxxxxxx |
   | x GUARD x | J : RED-  | x GUARD x | RED-  : J | x GUARD x |
   | xxxxxxxxx | E :  ZONE | xxxxxxxxx |  ZONE : E | xxxxxxxxx |
   | xxxxxxxxx | C :       | xxxxxxxxx |       : C | xxxxxxxxx |
   | xxxxxxxxx | T :       | xxxxxxxxx |       : T | xxxxxxxxx |
---+-----------+-----------+-----------+-----------+-----------+---
</pre></div>
</div>
<p>Upon deallocation of a KFENCE object, the object’s page is again protected and
the object is marked as freed. Any further access to the object causes a fault
and KFENCE reports a use-after-free access. Freed objects are inserted at the
tail of KFENCE’s freelist, so that the least recently freed objects are reused
first, and the chances of detecting use-after-frees of recently freed objects
is increased.</p>
<p>If pool utilization reaches 75% (default) or above, to reduce the risk of the
pool eventually being fully occupied by allocated objects yet ensure diverse
coverage of allocations, KFENCE limits currently covered allocations of the
same source from further filling up the pool. The “source” of an allocation is
based on its partial allocation stack trace. A side-effect is that this also
limits frequent long-lived allocations (e.g. pagecache) of the same source
filling up the pool permanently, which is the most common risk for the pool
becoming full and the sampled allocation rate dropping to zero. The threshold
at which to start limiting currently covered allocations can be configured via
the boot parameter <code class="docutils literal notranslate"><span class="pre">kfence.skip_covered_thresh</span></code> (pool usage%).</p>
</div>
<div class="section" id="interface">
<h2>Interface<a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h2>
<p>The following describes the functions which are used by allocators as well as
page handling code to set up and deal with KFENCE allocations.</p>
<dl class="function">
<dt id="c.is_kfence_address">
bool <code class="descname">is_kfence_address</code><span class="sig-paren">(</span>const void<em>&nbsp;*addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_kfence_address" title="Permalink to this definition">¶</a></dt>
<dd><p>check if an address belongs to KFENCE pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt>
<dd>address to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>true or false depending on whether the address is within the KFENCE
object range.</p>
<p><strong>Description</strong></p>
<p>KFENCE objects live in a separate page range and are not to be intermixed
with regular heap objects (e.g. KFENCE objects must never be added to the
allocator freelists). Failing to do so may and will result in heap
corruptions, therefore <a class="reference internal" href="#c.is_kfence_address" title="is_kfence_address"><code class="xref c c-func docutils literal notranslate"><span class="pre">is_kfence_address()</span></code></a> must be used to check whether
an object requires specific handling.</p>
<p><strong>Note</strong></p>
<p>This function may be used in fast-paths, and is performance critical.
Future changes should take this into account; for instance, we want to avoid
introducing another load and therefore need to keep KFENCE_POOL_SIZE a
constant (until immediate patching support is added to the kernel).</p>
<dl class="function">
<dt id="c.kfence_shutdown_cache">
void <code class="descname">kfence_shutdown_cache</code><span class="sig-paren">(</span>struct kmem_cache<em>&nbsp;*s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_shutdown_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>handle shutdown_cache() for KFENCE objects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*s</span></code></dt>
<dd>cache being shut down</dd>
</dl>
<p><strong>Description</strong></p>
<p>Before shutting down a cache, one must ensure there are no remaining objects
allocated from it. Because KFENCE objects are not referenced from the cache
directly, we need to check them here.</p>
<p>Note that shutdown_cache() is internal to SL*B, and kmem_cache_destroy() does
not return if allocated objects still exist: it prints an error message and
simply aborts destruction of a cache, leaking memory.</p>
<p>If the only such objects are KFENCE objects, we will not leak the entire
cache, but instead try to provide more useful debug info by making allocated
objects “zombie allocations”. Objects may then still be used or freed (which
is handled gracefully), but usage will result in showing KFENCE error reports
which include stack traces to the user of the object, the original allocation
site, and caller to shutdown_cache().</p>
<dl class="function">
<dt id="c.kfence_alloc">
void * <code class="descname">kfence_alloc</code><span class="sig-paren">(</span>struct kmem_cache<em>&nbsp;*s</em>, size_t<em>&nbsp;size</em>, <a class="reference internal" href="../core-api/mm-api.html#c.gfp_t" title="gfp_t">gfp_t</a><em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a KFENCE object with a low probability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*s</span></code></dt>
<dd>struct kmem_cache with object requirements</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>exact size of the object to allocate (can be less than <strong>s-&gt;size</strong>
e.g. for kmalloc caches)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>GFP flags</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li>NULL     - must proceed with allocating as usual,</li>
<li>non-NULL - pointer to a KFENCE object.</li>
</ul>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.kfence_alloc" title="kfence_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfence_alloc()</span></code></a> should be inserted into the heap allocation fast path,
allowing it to transparently return KFENCE-allocated objects with a low
probability using a static branch (the probability is controlled by the
kfence.sample_interval boot parameter).</p>
<dl class="function">
<dt id="c.kfence_ksize">
size_t <code class="descname">kfence_ksize</code><span class="sig-paren">(</span>const void<em>&nbsp;*addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_ksize" title="Permalink to this definition">¶</a></dt>
<dd><p>get actual amount of memory allocated for a KFENCE object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt>
<dd>pointer to a heap object</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li>0     - not a KFENCE object, must call <a class="reference internal" href="../core-api/mm-api.html#c.__ksize" title="__ksize"><code class="xref c c-func docutils literal notranslate"><span class="pre">__ksize()</span></code></a> instead,</li>
<li>non-0 - this many bytes can be accessed without causing a memory error.</li>
</ul>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.kfence_ksize" title="kfence_ksize"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfence_ksize()</span></code></a> returns the number of bytes requested for a KFENCE object at
allocation time. This number may be less than the object size of the
corresponding struct kmem_cache.</p>
<dl class="function">
<dt id="c.kfence_object_start">
void * <code class="descname">kfence_object_start</code><span class="sig-paren">(</span>const void<em>&nbsp;*addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_object_start" title="Permalink to this definition">¶</a></dt>
<dd><p>find the beginning of a KFENCE object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*addr</span></code></dt>
<dd>address within a KFENCE-allocated object</dd>
</dl>
<p><strong>Return</strong></p>
<p>address of the beginning of the object.</p>
<p><strong>Description</strong></p>
<p>SL[AU]B-allocated objects are laid out within a page one by one, so it is
easy to calculate the beginning of an object given a pointer inside it and
the object size. The same is not true for KFENCE, which places a single
object at either end of the page. This helper function is used to find the
beginning of a KFENCE-allocated object.</p>
<dl class="function">
<dt id="c.__kfence_free">
void <code class="descname">__kfence_free</code><span class="sig-paren">(</span>void<em>&nbsp;*addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__kfence_free" title="Permalink to this definition">¶</a></dt>
<dd><p>release a KFENCE heap object to KFENCE pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt>
<dd>object to be freed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Requires: is_kfence_address(addr)</p>
<p>Release a KFENCE object and mark it as freed.</p>
<dl class="function">
<dt id="c.kfence_free">
bool <code class="descname">kfence_free</code><span class="sig-paren">(</span>void<em>&nbsp;*addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_free" title="Permalink to this definition">¶</a></dt>
<dd><p>try to release an arbitrary heap object to KFENCE pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*addr</span></code></dt>
<dd>object to be freed</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li>false - object doesn’t belong to KFENCE pool and was ignored,</li>
<li>true  - object was released to KFENCE pool.</li>
</ul>
<p><strong>Description</strong></p>
<p>Release a KFENCE object and mark it as freed. May be called on any object,
even non-KFENCE objects, to simplify integration of the hooks into the
allocator’s free codepath. The allocator must check the return value to
determine if it was a KFENCE object or not.</p>
<dl class="function">
<dt id="c.kfence_handle_page_fault">
bool <code class="descname">kfence_handle_page_fault</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;addr</em>, bool<em>&nbsp;is_write</em>, struct pt_regs<em>&nbsp;*regs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfence_handle_page_fault" title="Permalink to this definition">¶</a></dt>
<dd><p>perform page fault handling for KFENCE pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>faulting address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_write</span></code></dt>
<dd>is access a write</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_regs</span> <span class="pre">*regs</span></code></dt>
<dd>current struct pt_regs (can be NULL, but shows full stack trace)</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li>false - address outside KFENCE pool,</li>
<li>true  - page fault handled by KFENCE, no additional handling required.</li>
</ul>
<p><strong>Description</strong></p>
<p>A page fault inside KFENCE pool indicates a memory error, such as an
out-of-bounds access, a use-after-free or an invalid memory access. In these
cases KFENCE prints an error message and marks the offending page as
present, so that the kernel can proceed.</p>
</div>
<div class="section" id="related-tools">
<h2>Related Tools<a class="headerlink" href="#related-tools" title="Permalink to this headline">¶</a></h2>
<p>In userspace, a similar approach is taken by <a class="reference external" href="http://llvm.org/docs/GwpAsan.html">GWP-ASan</a>. GWP-ASan also relies on guard pages and
a sampling strategy to detect memory unsafety bugs at scale. KFENCE’s design is
directly influenced by GWP-ASan, and can be seen as its kernel sibling. Another
similar but non-sampling approach, that also inspired the name “KFENCE”, can be
found in the userspace <a class="reference external" href="https://linux.die.net/man/3/efence">Electric Fence Malloc Debugger</a>.</p>
<p>In the kernel, several tools exist to debug memory access errors, and in
particular KASAN can detect all bug classes that KFENCE can detect. While KASAN
is more precise, relying on compiler instrumentation, this comes at a
performance cost.</p>
<p>It is worth highlighting that KASAN and KFENCE are complementary, with
different target environments. For instance, KASAN is the better debugging-aid,
where test cases or reproducers exists: due to the lower chance to detect the
error, it would require more effort using KFENCE to debug. Deployments at scale
that cannot afford to enable KASAN, however, would benefit from using KFENCE to
discover bugs due to code paths not exercised by test cases or fuzzers.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gdb-kernel-debugging.html" class="btn btn-neutral float-right" title="Debugging kernel and modules via gdb" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="kcsan.html" class="btn btn-neutral" title="The Kernel Concurrency Sanitizer (KCSAN)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>