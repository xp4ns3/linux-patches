

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ORANGEFS &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Filesystems in the Linux kernel" href="index.html"/>
        <link rel="next" title="Overlay Filesystem" href="overlayfs.html"/>
        <link rel="prev" title="Optimized MPEG Filesystem (OMFS)" href="omfs.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Filesystems in the Linux kernel</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-vfs-documentation">Core VFS documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#filesystem-support-layers">Filesystem support layers</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#filesystems">Filesystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="9p.html">v9fs: Plan 9 Resource Sharing for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="adfs.html">Acorn Disc Filing System - ADFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="affs.html">Overview of Amiga Filesystems</a></li>
<li class="toctree-l3"><a class="reference internal" href="afs.html">kAFS: AFS FILESYSTEM</a></li>
<li class="toctree-l3"><a class="reference internal" href="autofs.html">autofs - how it works</a></li>
<li class="toctree-l3"><a class="reference internal" href="autofs-mount-control.html">Miscellaneous Device control operations for the autofs kernel module</a></li>
<li class="toctree-l3"><a class="reference internal" href="befs.html">BeOS filesystem for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="bfs.html">BFS Filesystem for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="btrfs.html">BTRFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="cifs/index.html">CIFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="ceph.html">Ceph Distributed File System</a></li>
<li class="toctree-l3"><a class="reference internal" href="coda.html">Coda Kernel-Venus Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="configfs.html">Configfs - Userspace-driven Kernel Object Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="cramfs.html">Cramfs - cram a filesystem onto a small ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="dax.html">Direct Access for files</a></li>
<li class="toctree-l3"><a class="reference internal" href="debugfs.html">DebugFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="dlmfs.html">DLMFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="ecryptfs.html">eCryptfs: A stacked cryptographic filesystem for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="efivarfs.html">efivarfs - a (U)EFI variable filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="erofs.html">Enhanced Read-Only File System - EROFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="ext2.html">The Second Extended Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ext3.html">Ext3 Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ext4/index.html">ext4 Data Structures and Algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="f2fs.html">WHAT IS Flash-Friendly File System (F2FS)?</a></li>
<li class="toctree-l3"><a class="reference internal" href="gfs2.html">Global File System 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="gfs2-uevents.html">uevents and GFS2</a></li>
<li class="toctree-l3"><a class="reference internal" href="gfs2-glocks.html">Glock internal locking rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="hfs.html">Macintosh HFS Filesystem for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="hfsplus.html">Macintosh HFSPlus Filesystem for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="hpfs.html">Read/Write HPFS 2.09</a></li>
<li class="toctree-l3"><a class="reference internal" href="fuse.html">FUSE</a></li>
<li class="toctree-l3"><a class="reference internal" href="fuse-io.html">Fuse I/O Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="inotify.html">Inotify - A Powerful yet Simple File Change Notification System</a></li>
<li class="toctree-l3"><a class="reference internal" href="isofs.html">ISO9660 Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="nilfs2.html">NILFS2</a></li>
<li class="toctree-l3"><a class="reference internal" href="nfs/index.html">NFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="ntfs.html">The Linux NTFS filesystem driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="ntfs3.html">NTFS3</a></li>
<li class="toctree-l3"><a class="reference internal" href="ocfs2.html">OCFS2 filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ocfs2-online-filecheck.html">OCFS2 file system - online file check</a></li>
<li class="toctree-l3"><a class="reference internal" href="omfs.html">Optimized MPEG Filesystem (OMFS)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">ORANGEFS</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mailing-list-archives">Mailing List Archives</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mailing-list-submissions">Mailing List Submissions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#documentation">Documentation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-orangefs-on-a-single-server">Running ORANGEFS On a Single Server</a></li>
<li class="toctree-l4"><a class="reference internal" href="#userspace-filesystem-source">Userspace Filesystem Source</a></li>
<li class="toctree-l4"><a class="reference internal" href="#building-orangefs-on-a-single-server">Building ORANGEFS on a Single Server</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-xfstests">Running xfstests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#options">Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debugging">Debugging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#protocol-between-kernel-module-and-userspace">Protocol between Kernel Module and Userspace</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="overlayfs.html">Overlay Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="proc.html">The /proc Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="qnx6.html">The QNX6 Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ramfs-rootfs-initramfs.html">Ramfs, rootfs and initramfs</a></li>
<li class="toctree-l3"><a class="reference internal" href="relay.html">relay interface (formerly relayfs)</a></li>
<li class="toctree-l3"><a class="reference internal" href="romfs.html">ROMFS - ROM File System</a></li>
<li class="toctree-l3"><a class="reference internal" href="spufs/index.html">SPU Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="squashfs.html">Squashfs 4.0 Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="sysfs.html">sysfs - _The_ filesystem for exporting kernel objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="sysv-fs.html">SystemV Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="tmpfs.html">Tmpfs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ubifs.html">UBI File System</a></li>
<li class="toctree-l3"><a class="reference internal" href="ubifs-authentication.html">UBIFS Authentication Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="udf.html">UDF file system</a></li>
<li class="toctree-l3"><a class="reference internal" href="virtiofs.html">virtiofs: virtio-fs host&lt;-&gt;guest shared file system</a></li>
<li class="toctree-l3"><a class="reference internal" href="vfat.html">VFAT</a></li>
<li class="toctree-l3"><a class="reference internal" href="xfs-delayed-logging-design.html">XFS Delayed Logging Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="xfs-self-describing-metadata.html">XFS Self Describing Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="zonefs.html">ZoneFS - Zone filesystem for Zoned block devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Filesystems in the Linux kernel</a> &raquo;</li>
        
      <li>ORANGEFS</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/orangefs.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="orangefs">
<h1>ORANGEFS<a class="headerlink" href="#orangefs" title="Permalink to this headline">¶</a></h1>
<p>OrangeFS is an LGPL userspace scale-out parallel storage system. It is ideal
for large storage problems faced by HPC, BigData, Streaming Video,
Genomics, Bioinformatics.</p>
<p>Orangefs, originally called PVFS, was first developed in 1993 by
Walt Ligon and Eric Blumer as a parallel file system for Parallel
Virtual Machine (PVM) as part of a NASA grant to study the I/O patterns
of parallel programs.</p>
<p>Orangefs features include:</p>
<blockquote>
<div><ul class="simple">
<li>Distributes file data among multiple file servers</li>
<li>Supports simultaneous access by multiple clients</li>
<li>Stores file data and metadata on servers using local file system
and access methods</li>
<li>Userspace implementation is easy to install and maintain</li>
<li>Direct MPI support</li>
<li>Stateless</li>
</ul>
</div></blockquote>
<div class="section" id="mailing-list-archives">
<h2>Mailing List Archives<a class="headerlink" href="#mailing-list-archives" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://lists.orangefs.org/pipermail/devel_lists.orangefs.org/">http://lists.orangefs.org/pipermail/devel_lists.orangefs.org/</a></p>
</div>
<div class="section" id="mailing-list-submissions">
<h2>Mailing List Submissions<a class="headerlink" href="#mailing-list-submissions" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="mailto:devel&#37;&#52;&#48;lists&#46;orangefs&#46;org">devel<span>&#64;</span>lists<span>&#46;</span>orangefs<span>&#46;</span>org</a></p>
</div>
<div class="section" id="documentation">
<h2>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://www.orangefs.org/documentation/">http://www.orangefs.org/documentation/</a></p>
</div>
<div class="section" id="running-orangefs-on-a-single-server">
<h2>Running ORANGEFS On a Single Server<a class="headerlink" href="#running-orangefs-on-a-single-server" title="Permalink to this headline">¶</a></h2>
<p>OrangeFS is usually run in large installations with multiple servers and
clients, but a complete filesystem can be run on a single machine for
development and testing.</p>
<p>On Fedora, install orangefs and orangefs-server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dnf -y install orangefs orangefs-server
</pre></div>
</div>
<p>There is an example server configuration file in
/etc/orangefs/orangefs.conf.  Change localhost to your hostname if
necessary.</p>
<p>To generate a filesystem to run xfstests against, see below.</p>
<p>There is an example client configuration file in /etc/pvfs2tab.  It is a
single line.  Uncomment it and change the hostname if necessary.  This
controls clients which use libpvfs2.  This does not control the
pvfs2-client-core.</p>
<p>Create the filesystem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pvfs2-server -f /etc/orangefs/orangefs.conf
</pre></div>
</div>
<p>Start the server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>systemctl start orangefs-server
</pre></div>
</div>
<p>Test the server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pvfs2-ping -m /pvfsmnt
</pre></div>
</div>
<p>Start the client.  The module must be compiled in or loaded before this
point:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>systemctl start orangefs-client
</pre></div>
</div>
<p>Mount the filesystem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount -t pvfs2 tcp://localhost:3334/orangefs /pvfsmnt
</pre></div>
</div>
</div>
<div class="section" id="userspace-filesystem-source">
<h2>Userspace Filesystem Source<a class="headerlink" href="#userspace-filesystem-source" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://www.orangefs.org/download">http://www.orangefs.org/download</a></p>
<p>Orangefs versions prior to 2.9.3 would not be compatible with the
upstream version of the kernel client.</p>
</div>
<div class="section" id="building-orangefs-on-a-single-server">
<h2>Building ORANGEFS on a Single Server<a class="headerlink" href="#building-orangefs-on-a-single-server" title="Permalink to this headline">¶</a></h2>
<p>Where OrangeFS cannot be installed from distribution packages, it may be
built from source.</p>
<p>You can omit –prefix if you don’t care that things are sprinkled around
in /usr/local.  As of version 2.9.6, OrangeFS uses Berkeley DB by
default, we will probably be changing the default to LMDB soon.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./configure --prefix=/opt/ofs --with-db-backend=lmdb --disable-usrint

make

make install
</pre></div>
</div>
<p>Create an orangefs config file by running pvfs2-genconfig and
specifying a target config file. Pvfs2-genconfig will prompt you
through. Generally it works fine to take the defaults, but you
should use your server’s hostname, rather than “localhost” when
it comes to that question:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/ofs/bin/pvfs2-genconfig /etc/pvfs2.conf
</pre></div>
</div>
<p>Create an /etc/pvfs2tab file (localhost is fine):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo tcp://localhost:3334/orangefs /pvfsmnt pvfs2 defaults,noauto 0 0 &gt; \
    /etc/pvfs2tab
</pre></div>
</div>
<p>Create the mount point you specified in the tab file if needed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mkdir /pvfsmnt
</pre></div>
</div>
<p>Bootstrap the server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/ofs/sbin/pvfs2-server -f /etc/pvfs2.conf
</pre></div>
</div>
<p>Start the server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/ofs/sbin/pvfs2-server /etc/pvfs2.conf
</pre></div>
</div>
<p>Now the server should be running. Pvfs2-ls is a simple
test to verify that the server is running:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/ofs/bin/pvfs2-ls /pvfsmnt
</pre></div>
</div>
<p>If stuff seems to be working, load the kernel module and
turn on the client core:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/opt/ofs/sbin/pvfs2-client -p /opt/ofs/sbin/pvfs2-client-core
</pre></div>
</div>
<p>Mount your filesystem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount -t pvfs2 tcp://`hostname`:3334/orangefs /pvfsmnt
</pre></div>
</div>
</div>
<div class="section" id="running-xfstests">
<h2>Running xfstests<a class="headerlink" href="#running-xfstests" title="Permalink to this headline">¶</a></h2>
<p>It is useful to use a scratch filesystem with xfstests.  This can be
done with only one server.</p>
<p>Make a second copy of the FileSystem section in the server configuration
file, which is /etc/orangefs/orangefs.conf.  Change the Name to scratch.
Change the ID to something other than the ID of the first FileSystem
section (2 is usually a good choice).</p>
<p>Then there are two FileSystem sections: orangefs and scratch.</p>
<p>This change should be made before creating the filesystem.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pvfs2-server -f /etc/orangefs/orangefs.conf
</pre></div>
</div>
<p>To run xfstests, create /etc/xfsqa.config:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TEST_DIR=/orangefs
TEST_DEV=tcp://localhost:3334/orangefs
SCRATCH_MNT=/scratch
SCRATCH_DEV=tcp://localhost:3334/scratch
</pre></div>
</div>
<p>Then xfstests can be run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>./check -pvfs2
</pre></div>
</div>
</div>
<div class="section" id="options">
<h2>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h2>
<p>The following mount options are accepted:</p>
<blockquote>
<div><dl class="docutils">
<dt>acl</dt>
<dd>Allow the use of Access Control Lists on files and directories.</dd>
<dt>intr</dt>
<dd>Some operations between the kernel client and the user space
filesystem can be interruptible, such as changes in debug levels
and the setting of tunable parameters.</dd>
<dt>local_lock</dt>
<dd>Enable posix locking from the perspective of “this” kernel. The
default file_operations lock action is to return ENOSYS. Posix
locking kicks in if the filesystem is mounted with -o local_lock.
Distributed locking is being worked on for the future.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="debugging">
<h2>Debugging<a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h2>
<p>If you want the debug (GOSSIP) statements in a particular
source file (inode.c for example) go to syslog:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo inode &gt; /sys/kernel/debug/orangefs/kernel-debug
</pre></div>
</div>
<p>No debugging (the default):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo none &gt; /sys/kernel/debug/orangefs/kernel-debug
</pre></div>
</div>
<p>Debugging from several source files:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo inode,dir &gt; /sys/kernel/debug/orangefs/kernel-debug
</pre></div>
</div>
<p>All debugging:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo all &gt; /sys/kernel/debug/orangefs/kernel-debug
</pre></div>
</div>
<p>Get a list of all debugging keywords:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat /sys/kernel/debug/orangefs/debug-help
</pre></div>
</div>
</div>
<div class="section" id="protocol-between-kernel-module-and-userspace">
<h2>Protocol between Kernel Module and Userspace<a class="headerlink" href="#protocol-between-kernel-module-and-userspace" title="Permalink to this headline">¶</a></h2>
<p>Orangefs is a user space filesystem and an associated kernel module.
We’ll just refer to the user space part of Orangefs as “userspace”
from here on out. Orangefs descends from PVFS, and userspace code
still uses PVFS for function and variable names. Userspace typedefs
many of the important structures. Function and variable names in
the kernel module have been transitioned to “orangefs”, and The Linux
Coding Style avoids typedefs, so kernel module structures that
correspond to userspace structures are not typedefed.</p>
<p>The kernel module implements a pseudo device that userspace
can read from and write to. Userspace can also manipulate the
kernel module through the pseudo device with ioctl.</p>
<div class="section" id="the-bufmap">
<h3>The Bufmap<a class="headerlink" href="#the-bufmap" title="Permalink to this headline">¶</a></h3>
<p>At startup userspace allocates two page-size-aligned (posix_memalign)
mlocked memory buffers, one is used for IO and one is used for readdir
operations. The IO buffer is 41943040 bytes and the readdir buffer is
4194304 bytes. Each buffer contains logical chunks, or partitions, and
a pointer to each buffer is added to its own PVFS_dev_map_desc structure
which also describes its total size, as well as the size and number of
the partitions.</p>
<p>A pointer to the IO buffer’s PVFS_dev_map_desc structure is sent to a
mapping routine in the kernel module with an ioctl. The structure is
copied from user space to kernel space with copy_from_user and is used
to initialize the kernel module’s “bufmap” (struct orangefs_bufmap), which
then contains:</p>
<blockquote>
<div><ul>
<li><p class="first">refcnt
- a reference counter</p>
</li>
<li><p class="first">desc_size - PVFS2_BUFMAP_DEFAULT_DESC_SIZE (4194304) - the IO buffer’s
partition size, which represents the filesystem’s block size and
is used for s_blocksize in super blocks.</p>
</li>
<li><p class="first">desc_count - PVFS2_BUFMAP_DEFAULT_DESC_COUNT (10) - the number of
partitions in the IO buffer.</p>
</li>
<li><p class="first">desc_shift - log2(desc_size), used for s_blocksize_bits in super blocks.</p>
</li>
<li><p class="first">total_size - the total size of the IO buffer.</p>
</li>
<li><p class="first">page_count - the number of 4096 byte pages in the IO buffer.</p>
</li>
<li><p class="first">page_array - a pointer to <code class="docutils literal notranslate"><span class="pre">page_count</span> <span class="pre">*</span> <span class="pre">(sizeof(struct</span> <span class="pre">page*))</span></code> bytes
of kcalloced memory. This memory is used as an array of pointers
to each of the pages in the IO buffer through a call to get_user_pages.</p>
</li>
<li><p class="first">desc_array - a pointer to <code class="docutils literal notranslate"><span class="pre">desc_count</span> <span class="pre">*</span> <span class="pre">(sizeof(struct</span> <span class="pre">orangefs_bufmap_desc))</span></code>
bytes of kcalloced memory. This memory is further intialized:</p>
<blockquote>
<div><p>user_desc is the kernel’s copy of the IO buffer’s ORANGEFS_dev_map_desc
structure. user_desc-&gt;ptr points to the IO buffer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pages_per_desc = bufmap-&gt;desc_size / PAGE_SIZE
offset = 0

bufmap-&gt;desc_array[0].page_array = &amp;bufmap-&gt;page_array[offset]
bufmap-&gt;desc_array[0].array_count = pages_per_desc = 1024
bufmap-&gt;desc_array[0].uaddr = (user_desc-&gt;ptr) + (0 * 1024 * 4096)
offset += 1024
                   .
                   .
                   .
bufmap-&gt;desc_array[9].page_array = &amp;bufmap-&gt;page_array[offset]
bufmap-&gt;desc_array[9].array_count = pages_per_desc = 1024
bufmap-&gt;desc_array[9].uaddr = (user_desc-&gt;ptr) +
                                       (9 * 1024 * 4096)
offset += 1024
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">buffer_index_array - a desc_count sized array of ints, used to
indicate which of the IO buffer’s partitions are available to use.</p>
</li>
<li><p class="first">buffer_index_lock - a spinlock to protect buffer_index_array during update.</p>
</li>
<li><p class="first">readdir_index_array - a five (ORANGEFS_READDIR_DEFAULT_DESC_COUNT) element
int array used to indicate which of the readdir buffer’s partitions are
available to use.</p>
</li>
<li><p class="first">readdir_index_lock - a spinlock to protect readdir_index_array during
update.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="operations">
<h3>Operations<a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h3>
<p>The kernel module builds an “op” (struct orangefs_kernel_op_s) when it
needs to communicate with userspace. Part of the op contains the “upcall”
which expresses the request to userspace. Part of the op eventually
contains the “downcall” which expresses the results of the request.</p>
<p>The slab allocator is used to keep a cache of op structures handy.</p>
<p>At init time the kernel module defines and initializes a request list
and an in_progress hash table to keep track of all the ops that are
in flight at any given time.</p>
<p>Ops are stateful:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>unknown</dt>
<dd><ul class="first last">
<li>op was just initialized</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>waiting</dt>
<dd><ul class="first last">
<li>op is on request_list (upward bound)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>inprogr</dt>
<dd><ul class="first last">
<li>op is in progress (waiting for downcall)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>serviced</dt>
<dd><ul class="first last">
<li>op has matching downcall; ok</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>purged</dt>
<dd><ul class="first last">
<li>op has to start a timer since client-core
exited uncleanly before servicing op</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>given up</dt>
<dd><ul class="first last">
<li>submitter has given up waiting for it</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>When some arbitrary userspace program needs to perform a
filesystem operation on Orangefs (readdir, I/O, create, whatever)
an op structure is initialized and tagged with a distinguishing ID
number. The upcall part of the op is filled out, and the op is
passed to the “service_operation” function.</p>
<p>Service_operation changes the op’s state to “waiting”, puts
it on the request list, and signals the Orangefs file_operations.poll
function through a wait queue. Userspace is polling the pseudo-device
and thus becomes aware of the upcall request that needs to be read.</p>
<p>When the Orangefs file_operations.read function is triggered, the
request list is searched for an op that seems ready-to-process.
The op is removed from the request list. The tag from the op and
the filled-out upcall struct are copy_to_user’ed back to userspace.</p>
<p>If any of these (and some additional protocol) copy_to_users fail,
the op’s state is set to “waiting” and the op is added back to
the request list. Otherwise, the op’s state is changed to “in progress”,
and the op is hashed on its tag and put onto the end of a list in the
in_progress hash table at the index the tag hashed to.</p>
<p>When userspace has assembled the response to the upcall, it
writes the response, which includes the distinguishing tag, back to
the pseudo device in a series of io_vecs. This triggers the Orangefs
file_operations.write_iter function to find the op with the associated
tag and remove it from the in_progress hash table. As long as the op’s
state is not “canceled” or “given up”, its state is set to “serviced”.
The file_operations.write_iter function returns to the waiting vfs,
and back to service_operation through wait_for_matching_downcall.</p>
<p>Service operation returns to its caller with the op’s downcall
part (the response to the upcall) filled out.</p>
<p>The “client-core” is the bridge between the kernel module and
userspace. The client-core is a daemon. The client-core has an
associated watchdog daemon. If the client-core is ever signaled
to die, the watchdog daemon restarts the client-core. Even though
the client-core is restarted “right away”, there is a period of
time during such an event that the client-core is dead. A dead client-core
can’t be triggered by the Orangefs file_operations.poll function.
Ops that pass through service_operation during a “dead spell” can timeout
on the wait queue and one attempt is made to recycle them. Obviously,
if the client-core stays dead too long, the arbitrary userspace processes
trying to use Orangefs will be negatively affected. Waiting ops
that can’t be serviced will be removed from the request list and
have their states set to “given up”. In-progress ops that can’t
be serviced will be removed from the in_progress hash table and
have their states set to “given up”.</p>
<p>Readdir and I/O ops are atypical with respect to their payloads.</p>
<blockquote>
<div><ul class="simple">
<li>readdir ops use the smaller of the two pre-allocated pre-partitioned
memory buffers. The readdir buffer is only available to userspace.
The kernel module obtains an index to a free partition before launching
a readdir op. Userspace deposits the results into the indexed partition
and then writes them to back to the pvfs device.</li>
<li>io (read and write) ops use the larger of the two pre-allocated
pre-partitioned memory buffers. The IO buffer is accessible from
both userspace and the kernel module. The kernel module obtains an
index to a free partition before launching an io op. The kernel module
deposits write data into the indexed partition, to be consumed
directly by userspace. Userspace deposits the results of read
requests into the indexed partition, to be consumed directly
by the kernel module.</li>
</ul>
</div></blockquote>
<p>Responses to kernel requests are all packaged in pvfs2_downcall_t
structs. Besides a few other members, pvfs2_downcall_t contains a
union of structs, each of which is associated with a particular
response type.</p>
<p>The several members outside of the union are:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int32_t</span> <span class="pre">type</span></code></dt>
<dd><ul class="first last simple">
<li>type of operation.</li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int32_t</span> <span class="pre">status</span></code></dt>
<dd><ul class="first last simple">
<li>return code for the operation.</li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int64_t</span> <span class="pre">trailer_size</span></code></dt>
<dd><ul class="first last simple">
<li>0 unless readdir operation.</li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*trailer_buf</span></code></dt>
<dd><ul class="first last simple">
<li>initialized to NULL, used during readdir operations.</li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>The appropriate member inside the union is filled out for any
particular response.</p>
<blockquote>
<div><dl class="docutils">
<dt>PVFS2_VFS_OP_FILE_IO</dt>
<dd>fill a pvfs2_io_response_t</dd>
<dt>PVFS2_VFS_OP_LOOKUP</dt>
<dd>fill a PVFS_object_kref</dd>
<dt>PVFS2_VFS_OP_CREATE</dt>
<dd>fill a PVFS_object_kref</dd>
<dt>PVFS2_VFS_OP_SYMLINK</dt>
<dd>fill a PVFS_object_kref</dd>
<dt>PVFS2_VFS_OP_GETATTR</dt>
<dd>fill in a PVFS_sys_attr_s (tons of stuff the kernel doesn’t need)
fill in a string with the link target when the object is a symlink.</dd>
<dt>PVFS2_VFS_OP_MKDIR</dt>
<dd>fill a PVFS_object_kref</dd>
<dt>PVFS2_VFS_OP_STATFS</dt>
<dd>fill a pvfs2_statfs_response_t with useless info &lt;g&gt;. It is hard for
us to know, in a timely fashion, these statistics about our
distributed network filesystem.</dd>
<dt>PVFS2_VFS_OP_FS_MOUNT</dt>
<dd>fill a pvfs2_fs_mount_response_t which is just like a PVFS_object_kref
except its members are in a different order and “__pad1” is replaced
with “id”.</dd>
<dt>PVFS2_VFS_OP_GETXATTR</dt>
<dd>fill a pvfs2_getxattr_response_t</dd>
<dt>PVFS2_VFS_OP_LISTXATTR</dt>
<dd>fill a pvfs2_listxattr_response_t</dd>
<dt>PVFS2_VFS_OP_PARAM</dt>
<dd>fill a pvfs2_param_response_t</dd>
<dt>PVFS2_VFS_OP_PERF_COUNT</dt>
<dd>fill a pvfs2_perf_count_response_t</dd>
<dt>PVFS2_VFS_OP_FSKEY</dt>
<dd>file a pvfs2_fs_key_response_t</dd>
<dt>PVFS2_VFS_OP_READDIR</dt>
<dd>jamb everything needed to represent a pvfs2_readdir_response_t into
the readdir buffer descriptor specified in the upcall.</dd>
</dl>
</div></blockquote>
<p>Userspace uses writev() on /dev/pvfs2-req to pass responses to the requests
made by the kernel side.</p>
<p>A buffer_list containing:</p>
<blockquote>
<div><ul class="simple">
<li>a pointer to the prepared response to the request from the
kernel (struct pvfs2_downcall_t).</li>
<li>and also, in the case of a readdir request, a pointer to a
buffer containing descriptors for the objects in the target
directory.</li>
</ul>
</div></blockquote>
<p>… is sent to the function (PINT_dev_write_list) which performs
the writev.</p>
<p>PINT_dev_write_list has a local iovec array: struct iovec io_array[10];</p>
<p>The first four elements of io_array are initialized like this for all
responses:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>io_array[0].iov_base = address of local variable &quot;proto_ver&quot; (int32_t)
io_array[0].iov_len = sizeof(int32_t)

io_array[1].iov_base = address of global variable &quot;pdev_magic&quot; (int32_t)
io_array[1].iov_len = sizeof(int32_t)

io_array[2].iov_base = address of parameter &quot;tag&quot; (PVFS_id_gen_t)
io_array[2].iov_len = sizeof(int64_t)

io_array[3].iov_base = address of out_downcall member (pvfs2_downcall_t)
                       of global variable vfs_request (vfs_request_t)
io_array[3].iov_len = sizeof(pvfs2_downcall_t)
</pre></div>
</div>
<p>Readdir responses initialize the fifth element io_array like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>io_array[4].iov_base = contents of member trailer_buf (char *)
                       from out_downcall member of global variable
                       vfs_request
io_array[4].iov_len = contents of member trailer_size (PVFS_size)
                      from out_downcall member of global variable
                      vfs_request
</pre></div>
</div>
<p>Orangefs exploits the dcache in order to avoid sending redundant
requests to userspace. We keep object inode attributes up-to-date with
orangefs_inode_getattr. Orangefs_inode_getattr uses two arguments to
help it decide whether or not to update an inode: “new” and “bypass”.
Orangefs keeps private data in an object’s inode that includes a short
timeout value, getattr_time, which allows any iteration of
orangefs_inode_getattr to know how long it has been since the inode was
updated. When the object is not new (new == 0) and the bypass flag is not
set (bypass == 0) orangefs_inode_getattr returns without updating the inode
if getattr_time has not timed out. Getattr_time is updated each time the
inode is updated.</p>
<p>Creation of a new object (file, dir, sym-link) includes the evaluation of
its pathname, resulting in a negative directory entry for the object.
A new inode is allocated and associated with the dentry, turning it from
a negative dentry into a “productive full member of society”. Orangefs
obtains the new inode from Linux with <a class="reference internal" href="api-summary.html#c.new_inode" title="new_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">new_inode()</span></code></a> and associates
the inode with the dentry by sending the pair back to Linux with
<a class="reference internal" href="api-summary.html#c.d_instantiate" title="d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_instantiate()</span></code></a>.</p>
<p>The evaluation of a pathname for an object resolves to its corresponding
dentry. If there is no corresponding dentry, one is created for it in
the dcache. Whenever a dentry is modified or verified Orangefs stores a
short timeout value in the dentry’s d_time, and the dentry will be trusted
for that amount of time. Orangefs is a network filesystem, and objects
can potentially change out-of-band with any particular Orangefs kernel module
instance, so trusting a dentry is risky. The alternative to trusting
dentries is to always obtain the needed information from userspace - at
least a trip to the client-core, maybe to the servers. Obtaining information
from a dentry is cheap, obtaining it from userspace is relatively expensive,
hence the motivation to use the dentry when possible.</p>
<p>The timeout values d_time and getattr_time are jiffy based, and the
code is designed to avoid the jiffy-wrap problem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;In general, if the clock may have wrapped around more than once, there
is no way to tell how much time has elapsed. However, if the times t1
and t2 are known to be fairly close, we can reliably compute the
difference in a way that takes into account the possibility that the
clock may have wrapped between times.&quot;
</pre></div>
</div>
<p>from course notes by instructor Andy Wang</p>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="overlayfs.html" class="btn btn-neutral float-right" title="Overlay Filesystem" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="omfs.html" class="btn btn-neutral" title="Optimized MPEG Filesystem (OMFS)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>