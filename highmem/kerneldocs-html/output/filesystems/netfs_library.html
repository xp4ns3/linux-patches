

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Network Filesystem Helper Library &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Filesystems in the Linux kernel" href="index.html"/>
        <link rel="next" title="v9fs: Plan 9 Resource Sharing for Linux" href="9p.html"/>
        <link rel="prev" title="fs-verity: read-only file-based authenticity protection" href="fsverity.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Filesystems in the Linux kernel</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-vfs-documentation">Core VFS documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#filesystem-support-layers">Filesystem support layers</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="journalling.html">The Linux Journalling API</a></li>
<li class="toctree-l3"><a class="reference internal" href="fscrypt.html">Filesystem-level encryption (fscrypt)</a></li>
<li class="toctree-l3"><a class="reference internal" href="fsverity.html">fs-verity: read-only file-based authenticity protection</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Network Filesystem Helper Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#per-inode-context">Per-Inode Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffered-read-helpers">Buffered Read Helpers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-function-reference">API Function Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#filesystems">Filesystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Filesystems in the Linux kernel</a> &raquo;</li>
        
      <li>Network Filesystem Helper Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/netfs_library.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="network-filesystem-helper-library">
<h1>Network Filesystem Helper Library<a class="headerlink" href="#network-filesystem-helper-library" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The network filesystem helper library is a set of functions designed to aid a
network filesystem in implementing VM/VFS operations.  For the moment, that
just includes turning various VM buffered read operations into requests to read
from the server.  The helper library, however, can also interpose other
services, such as local caching or local data encryption.</p>
<p>Note that the library module doesn’t link against local caching directly, so
access must be provided by the netfs.</p>
</div>
<div class="section" id="per-inode-context">
<h2>Per-Inode Context<a class="headerlink" href="#per-inode-context" title="Permalink to this headline">¶</a></h2>
<p>The network filesystem helper library needs a place to store a bit of state for
its use on each netfs inode it is helping to manage.  To this end, a context
structure is defined:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_i_context {
        const struct netfs_request_ops *ops;
        struct fscache_cookie   *cache;
};
</pre></div>
</div>
<p>A network filesystem that wants to use netfs lib must place one of these
directly after the VFS <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span></code> it allocates, usually as part of its
own struct.  This can be done in a way similar to the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_inode {
        struct {
                /* These must be contiguous */
                struct inode            vfs_inode;
                struct netfs_i_context  netfs_ctx;
        };
        ...
};
</pre></div>
</div>
<p>This allows netfslib to find its state by simple offset from the inode pointer,
thereby allowing the netfslib helper functions to be pointed to directly by the
VFS/VM operation tables.</p>
<p>The structure contains the following fields:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">ops</span></code></p>
<p>The set of operations provided by the network filesystem to netfslib.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">cache</span></code></p>
<p>Local caching cookie, or NULL if no caching is enabled.  This field does not
exist if fscache is disabled.</p>
</li>
</ul>
</div></blockquote>
<div class="section" id="inode-context-helper-functions">
<h3>Inode Context Helper Functions<a class="headerlink" href="#inode-context-helper-functions" title="Permalink to this headline">¶</a></h3>
<p>To help deal with the per-inode context, a number helper functions are
provided.  Firstly, a function to perform basic initialisation on a context and
set the operations table pointer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void netfs_i_context_init(struct inode *inode,
                          const struct netfs_request_ops *ops);
</pre></div>
</div>
<p>then two functions to cast between the VFS inode structure and the netfs
context:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_i_context *netfs_i_context(struct inode *inode);
struct inode *netfs_inode(struct netfs_i_context *ctx);
</pre></div>
</div>
<p>and finally, a function to get the cache cookie pointer from the context
attached to an inode (or NULL if fscache is disabled):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fscache_cookie *netfs_i_cookie(struct inode *inode);
</pre></div>
</div>
</div>
</div>
<div class="section" id="buffered-read-helpers">
<h2>Buffered Read Helpers<a class="headerlink" href="#buffered-read-helpers" title="Permalink to this headline">¶</a></h2>
<p>The library provides a set of read helpers that handle the -&gt;readpage(),
-&gt;readahead() and much of the -&gt;write_begin() VM operations and translate them
into a common call framework.</p>
<p>The following services are provided:</p>
<blockquote>
<div><ul class="simple">
<li>Handle folios that span multiple pages.</li>
<li>Insulate the netfs from VM interface changes.</li>
<li>Allow the netfs to arbitrarily split reads up into pieces, even ones that
don’t match folio sizes or folio alignments and that may cross folios.</li>
<li>Allow the netfs to expand a readahead request in both directions to meet its
needs.</li>
<li>Allow the netfs to partially fulfil a read, which will then be resubmitted.</li>
<li>Handle local caching, allowing cached data and server-read data to be
interleaved for a single request.</li>
<li>Handle clearing of bufferage that aren’t on the server.</li>
<li>Handle retrying of reads that failed, switching reads from the cache to the
server as necessary.</li>
<li>In the future, this is a place that other services can be performed, such as
local encryption of data to be stored remotely or in the cache.</li>
</ul>
</div></blockquote>
<p>From the network filesystem, the helpers require a table of operations.  This
includes a mandatory method to issue a read operation along with a number of
optional methods.</p>
<div class="section" id="read-helper-functions">
<h3>Read Helper Functions<a class="headerlink" href="#read-helper-functions" title="Permalink to this headline">¶</a></h3>
<p>Three read helpers are provided:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void netfs_readahead(struct readahead_control *ractl);
int netfs_readpage(struct file *file,
                   struct page *page);
int netfs_write_begin(struct file *file,
                      struct address_space *mapping,
                      loff_t pos,
                      unsigned int len,
                      unsigned int flags,
                      struct folio **_folio,
                      void **_fsdata);
</pre></div>
</div>
<p>Each corresponds to a VM address space operation.  These operations use the
state in the per-inode context.</p>
<p>For -&gt;readahead() and -&gt;readpage(), the network filesystem just point directly
at the corresponding read helper; whereas for -&gt;write_begin(), it may be a
little more complicated as the network filesystem might want to flush
conflicting writes or track dirty data and needs to put the acquired folio if
an error occurs after calling the helper.</p>
<p>The helpers manage the read request, calling back into the network filesystem
through the suppplied table of operations.  Waits will be performed as
necessary before returning for helpers that are meant to be synchronous.</p>
<p>If an error occurs and netfs_priv is non-NULL, ops-&gt;cleanup() will be called to
deal with it.  If some parts of the request are in progress when an error
occurs, the request will get partially completed if sufficient data is read.</p>
<p>Additionally, there is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* void netfs_subreq_terminated(struct netfs_io_subrequest *subreq,
                               ssize_t transferred_or_error,
                               bool was_async);
</pre></div>
</div>
<p>which should be called to complete a read subrequest.  This is given the number
of bytes transferred or a negative error code, plus a flag indicating whether
the operation was asynchronous (ie. whether the follow-on processing can be
done in the current context, given this may involve sleeping).</p>
</div>
<div class="section" id="read-helper-structures">
<h3>Read Helper Structures<a class="headerlink" href="#read-helper-structures" title="Permalink to this headline">¶</a></h3>
<p>The read helpers make use of a couple of structures to maintain the state of
the read.  The first is a structure that manages a read request as a whole:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_io_request {
        struct inode            *inode;
        struct address_space    *mapping;
        struct netfs_cache_resources cache_resources;
        void                    *netfs_priv;
        loff_t                  start;
        size_t                  len;
        loff_t                  i_size;
        const struct netfs_request_ops *netfs_ops;
        unsigned int            debug_id;
        ...
};
</pre></div>
</div>
<p>The above fields are the ones the netfs can use.  They are:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">inode</span></code></p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">mapping</span></code></p>
<p>The inode and the address space of the file being read from.  The mapping
may or may not point to inode-&gt;i_data.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">cache_resources</span></code></p>
<p>Resources for the local cache to use, if present.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">netfs_priv</span></code></p>
<p>The network filesystem’s private data.  The value for this can be passed in
to the helper functions or set during the request.  The -&gt;cleanup() op will
be called if this is non-NULL at the end.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">start</span></code></p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">len</span></code></p>
<p>The file position of the start of the read request and the length.  These
may be altered by the -&gt;expand_readahead() op.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">i_size</span></code></p>
<p>The size of the file at the start of the request.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">netfs_ops</span></code></p>
<p>A pointer to the operation table.  The value for this is passed into the
helper functions.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">debug_id</span></code></p>
<p>A number allocated to this operation that can be displayed in trace lines
for reference.</p>
</li>
</ul>
</div></blockquote>
<p>The second structure is used to manage individual slices of the overall read
request:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_io_subrequest {
        struct netfs_io_request *rreq;
        loff_t                  start;
        size_t                  len;
        size_t                  transferred;
        unsigned long           flags;
        unsigned short          debug_index;
        ...
};
</pre></div>
</div>
<p>Each subrequest is expected to access a single source, though the helpers will
handle falling back from one source type to another.  The members are:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">rreq</span></code></p>
<p>A pointer to the read request.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">start</span></code></p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">len</span></code></p>
<p>The file position of the start of this slice of the read request and the
length.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">transferred</span></code></p>
<p>The amount of data transferred so far of the length of this slice.  The
network filesystem or cache should start the operation this far into the
slice.  If a short read occurs, the helpers will call again, having updated
this to reflect the amount read so far.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">flags</span></code></p>
<p>Flags pertaining to the read.  There are two of interest to the filesystem
or cache:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_CLEAR_TAIL</span></code></p>
<p>This can be set to indicate that the remainder of the slice, from
transferred to len, should be cleared.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">NETFS_SREQ_SEEK_DATA_READ</span></code></p>
<p>This is a hint to the cache that it might want to try skipping ahead to
the next data (ie. using SEEK_DATA).</p>
</li>
</ul>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">debug_index</span></code></p>
<p>A number allocated to this slice that can be displayed in trace lines for
reference.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="read-helper-operations">
<h3>Read Helper Operations<a class="headerlink" href="#read-helper-operations" title="Permalink to this headline">¶</a></h3>
<p>The network filesystem must provide the read helpers with a table of operations
through which it can issue requests and negotiate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_request_ops {
        void (*init_request)(struct netfs_io_request *rreq, struct file *file);
        int (*begin_cache_operation)(struct netfs_io_request *rreq);
        void (*expand_readahead)(struct netfs_io_request *rreq);
        bool (*clamp_length)(struct netfs_io_subrequest *subreq);
        void (*issue_read)(struct netfs_io_subrequest *subreq);
        bool (*is_still_valid)(struct netfs_io_request *rreq);
        int (*check_write_begin)(struct file *file, loff_t pos, unsigned len,
                                 struct folio *folio, void **_fsdata);
        void (*done)(struct netfs_io_request *rreq);
        void (*cleanup)(struct address_space *mapping, void *netfs_priv);
};
</pre></div>
</div>
<p>The operations are as follows:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">init_request()</span></code></p>
<p>[Optional] This is called to initialise the request structure.  It is given
the file for reference and can modify the -&gt;netfs_priv value.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">begin_cache_operation()</span></code></p>
<p>[Optional] This is called to ask the network filesystem to call into the
cache (if present) to initialise the caching state for this read.  The netfs
library module cannot access the cache directly, so the cache should call
something like <a class="reference internal" href="caching/netfs-api.html#c.fscache_begin_read_operation" title="fscache_begin_read_operation"><code class="xref c c-func docutils literal notranslate"><span class="pre">fscache_begin_read_operation()</span></code></a> to do this.</p>
<p>The cache gets to store its state in -&gt;cache_resources and must set a table
of operations of its own there (though of a different type).</p>
<p>This should return 0 on success and an error code otherwise.  If an error is
reported, the operation may proceed anyway, just without local caching (only
out of memory and interruption errors cause failure here).</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">expand_readahead()</span></code></p>
<p>[Optional] This is called to allow the filesystem to expand the size of a
readahead read request.  The filesystem gets to expand the request in both
directions, though it’s not permitted to reduce it as the numbers may
represent an allocation already made.  If local caching is enabled, it gets
to expand the request first.</p>
<p>Expansion is communicated by changing -&gt;start and -&gt;len in the request
structure.  Note that if any change is made, -&gt;len must be increased by at
least as much as -&gt;start is reduced.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">clamp_length()</span></code></p>
<p>[Optional] This is called to allow the filesystem to reduce the size of a
subrequest.  The filesystem can use this, for example, to chop up a request
that has to be split across multiple servers or to put multiple reads in
flight.</p>
<p>This should return 0 on success and an error code on error.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">issue_read()</span></code></p>
<p>[Required] The helpers use this to dispatch a subrequest to the server for
reading.  In the subrequest, -&gt;start, -&gt;len and -&gt;transferred indicate what
data should be read from the server.</p>
<p>There is no return value; the <a class="reference internal" href="#c.netfs_subreq_terminated" title="netfs_subreq_terminated"><code class="xref c c-func docutils literal notranslate"><span class="pre">netfs_subreq_terminated()</span></code></a> function should be
called to indicate whether or not the operation succeeded and how much data
it transferred.  The filesystem also should not deal with setting folios
uptodate, unlocking them or dropping their refs - the helpers need to deal
with this as they have to coordinate with copying to the local cache.</p>
<p>Note that the helpers have the folios locked, but not pinned.  It is
possible to use the ITER_XARRAY iov iterator to refer to the range of the
inode that is being operated upon without the need to allocate large bvec
tables.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">is_still_valid()</span></code></p>
<p>[Optional] This is called to find out if the data just read from the local
cache is still valid.  It should return true if it is still valid and false
if not.  If it’s not still valid, it will be reread from the server.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">check_write_begin()</span></code></p>
<p>[Optional] This is called from the <a class="reference internal" href="#c.netfs_write_begin" title="netfs_write_begin"><code class="xref c c-func docutils literal notranslate"><span class="pre">netfs_write_begin()</span></code></a> helper once it has
allocated/grabbed the folio to be modified to allow the filesystem to flush
conflicting state before allowing it to be modified.</p>
<p>It should return 0 if everything is now fine, -EAGAIN if the folio should be
regrabbed and any other error code to abort the operation.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">done</span></code></p>
<p>[Optional] This is called after the folios in the request have all been
unlocked (and marked uptodate if applicable).</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">cleanup</span></code></p>
<p>[Optional] This is called as the request is being deallocated so that the
filesystem can clean up -&gt;netfs_priv.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="read-helper-procedure">
<h3>Read Helper Procedure<a class="headerlink" href="#read-helper-procedure" title="Permalink to this headline">¶</a></h3>
<p>The read helpers work by the following general procedure:</p>
<blockquote>
<div><ul class="simple">
<li>Set up the request.</li>
<li>For readahead, allow the local cache and then the network filesystem to
propose expansions to the read request.  This is then proposed to the VM.
If the VM cannot fully perform the expansion, a partially expanded read will
be performed, though this may not get written to the cache in its entirety.</li>
<li>Loop around slicing chunks off of the request to form subrequests:<ul>
<li>If a local cache is present, it gets to do the slicing, otherwise the
helpers just try to generate maximal slices.</li>
<li>The network filesystem gets to clamp the size of each slice if it is to be
the source.  This allows rsize and chunking to be implemented.</li>
<li>The helpers issue a read from the cache or a read from the server or just
clears the slice as appropriate.</li>
<li>The next slice begins at the end of the last one.</li>
<li>As slices finish being read, they terminate.</li>
</ul>
</li>
<li>When all the subrequests have terminated, the subrequests are assessed and
any that are short or have failed are reissued:<ul>
<li>Failed cache requests are issued against the server instead.</li>
<li>Failed server requests just fail.</li>
<li>Short reads against either source will be reissued against that source
provided they have transferred some more data:<ul>
<li>The cache may need to skip holes that it can’t do DIO from.</li>
<li>If NETFS_SREQ_CLEAR_TAIL was set, a short read will be cleared to the
end of the slice instead of reissuing.</li>
</ul>
</li>
</ul>
</li>
<li>Once the data is read, the folios that have been fully read/cleared:<ul>
<li>Will be marked uptodate.</li>
<li>If a cache is present, will be marked with PG_fscache.</li>
<li>Unlocked</li>
</ul>
</li>
<li>Any folios that need writing to the cache will then have DIO writes issued.</li>
<li>Synchronous operations will wait for reading to be complete.</li>
<li>Writes to the cache will proceed asynchronously and the folios will have the
PG_fscache mark removed when that completes.</li>
<li>The request structures will be cleaned up when everything has completed.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="read-helper-cache-api">
<h3>Read Helper Cache API<a class="headerlink" href="#read-helper-cache-api" title="Permalink to this headline">¶</a></h3>
<p>When implementing a local cache to be used by the read helpers, two things are
required: some way for the network filesystem to initialise the caching for a
read request and a table of operations for the helpers to call.</p>
<p>The network filesystem’s -&gt;begin_cache_operation() method is called to set up a
cache and this must call into the cache to do the work.  If using fscache, for
example, the cache would call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fscache_begin_read_operation(struct netfs_io_request *rreq,
                                 struct fscache_cookie *cookie);
</pre></div>
</div>
<p>passing in the request pointer and the cookie corresponding to the file.</p>
<p>The netfs_io_request object contains a place for the cache to hang its
state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_cache_resources {
        const struct netfs_cache_ops    *ops;
        void                            *cache_priv;
        void                            *cache_priv2;
};
</pre></div>
</div>
<p>This contains an operations table pointer and two private pointers.  The
operation table looks like the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct netfs_cache_ops {
        void (*end_operation)(struct netfs_cache_resources *cres);

        void (*expand_readahead)(struct netfs_cache_resources *cres,
                                 loff_t *_start, size_t *_len, loff_t i_size);

        enum netfs_io_source (*prepare_read)(struct netfs_io_subrequest *subreq,
                                               loff_t i_size);

        int (*read)(struct netfs_cache_resources *cres,
                    loff_t start_pos,
                    struct iov_iter *iter,
                    bool seek_data,
                    netfs_io_terminated_t term_func,
                    void *term_func_priv);

        int (*prepare_write)(struct netfs_cache_resources *cres,
                             loff_t *_start, size_t *_len, loff_t i_size,
                             bool no_space_allocated_yet);

        int (*write)(struct netfs_cache_resources *cres,
                     loff_t start_pos,
                     struct iov_iter *iter,
                     netfs_io_terminated_t term_func,
                     void *term_func_priv);

        int (*query_occupancy)(struct netfs_cache_resources *cres,
                               loff_t start, size_t len, size_t granularity,
                               loff_t *_data_start, size_t *_data_len);
};
</pre></div>
</div>
<p>With a termination handler function pointer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef void (*netfs_io_terminated_t)(void *priv,
                                      ssize_t transferred_or_error,
                                      bool was_async);
</pre></div>
</div>
<p>The methods defined in the table are:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">end_operation()</span></code></p>
<p>[Required] Called to clean up the resources at the end of the read request.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">expand_readahead()</span></code></p>
<p>[Optional] Called at the beginning of a <a class="reference internal" href="#c.netfs_readahead" title="netfs_readahead"><code class="xref c c-func docutils literal notranslate"><span class="pre">netfs_readahead()</span></code></a> operation to allow
the cache to expand a request in either direction.  This allows the cache to
size the request appropriately for the cache granularity.</p>
<p>The function is passed poiners to the start and length in its parameters,
plus the size of the file for reference, and adjusts the start and length
appropriately.  It should return one of:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">NETFS_FILL_WITH_ZEROES</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">NETFS_DOWNLOAD_FROM_SERVER</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">NETFS_READ_FROM_CACHE</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">NETFS_INVALID_READ</span></code></li>
</ul>
<p>to indicate whether the slice should just be cleared or whether it should be
downloaded from the server or read from the cache - or whether slicing
should be given up at the current point.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">prepare_read()</span></code></p>
<p>[Required] Called to configure the next slice of a request.  -&gt;start and
-&gt;len in the subrequest indicate where and how big the next slice can be;
the cache gets to reduce the length to match its granularity requirements.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">read()</span></code></p>
<p>[Required] Called to read from the cache.  The start file offset is given
along with an iterator to read to, which gives the length also.  It can be
given a hint requesting that it seek forward from that start position for
data.</p>
<p>Also provided is a pointer to a termination handler function and private
data to pass to that function.  The termination function should be called
with the number of bytes transferred or an error code, plus a flag
indicating whether the termination is definitely happening in the caller’s
context.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">prepare_write()</span></code></p>
<p>[Required] Called to prepare a write to the cache to take place.  This
involves checking to see whether the cache has sufficient space to honour
the write.  <code class="docutils literal notranslate"><span class="pre">*_start</span></code> and <code class="docutils literal notranslate"><span class="pre">*_len</span></code> indicate the region to be written; the
region can be shrunk or it can be expanded to a page boundary either way as
necessary to align for direct I/O.  i_size holds the size of the object and
is provided for reference.  no_space_allocated_yet is set to true if the
caller is certain that no data has been written to that region - for example
if it tried to do a read from there already.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">write()</span></code></p>
<p>[Required] Called to write to the cache.  The start file offset is given
along with an iterator to write from, which gives the length also.</p>
<p>Also provided is a pointer to a termination handler function and private
data to pass to that function.  The termination function should be called
with the number of bytes transferred or an error code, plus a flag
indicating whether the termination is definitely happening in the caller’s
context.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">query_occupancy()</span></code></p>
<p>[Required] Called to find out where the next piece of data is within a
particular region of the cache.  The start and length of the region to be
queried are passed in, along with the granularity to which the answer needs
to be aligned.  The function passes back the start and length of the data,
if any, available within that region.  Note that there may be a hole at the
front.</p>
<p>It returns 0 if some data was found, -ENODATA if there was no usable data
within the region or -ENOBUFS if there is no caching on this file.</p>
</li>
</ul>
</div></blockquote>
<p>Note that these methods are passed a pointer to the cache resource structure,
not the read request structure as they could be used in other situations where
there isn’t a read request structure as well, such as writing dirty data to the
cache.</p>
</div>
</div>
<div class="section" id="api-function-reference">
<h2>API Function Reference<a class="headerlink" href="#api-function-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.folio_start_fscache">
void <code class="descname">folio_start_fscache</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em>&nbsp;*folio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_start_fscache" title="Permalink to this definition">¶</a></dt>
<dd><p>Start an fscache write on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt>
<dd>The folio.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function before writing a folio to a local cache.  Starting a
second write before the first one finishes is not allowed.</p>
<dl class="function">
<dt id="c.folio_end_fscache">
void <code class="descname">folio_end_fscache</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em>&nbsp;*folio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_end_fscache" title="Permalink to this definition">¶</a></dt>
<dd><p>End an fscache write on a folio.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt>
<dd>The folio.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function after the folio has been written to the local cache.
This will wake any sleepers waiting on this folio.</p>
<dl class="function">
<dt id="c.folio_wait_fscache">
void <code class="descname">folio_wait_fscache</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em>&nbsp;*folio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_fscache" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for an fscache write on this folio to end.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt>
<dd>The folio.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this folio is currently being written to a local cache, wait for
the write to finish.  Another write may start after this one finishes,
unless the caller holds the folio lock.</p>
<dl class="function">
<dt id="c.folio_wait_fscache_killable">
int <code class="descname">folio_wait_fscache_killable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em>&nbsp;*folio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.folio_wait_fscache_killable" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for an fscache write on this folio to end.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">*folio</span></code></dt>
<dd>The folio.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this folio is currently being written to a local cache, wait
for the write to finish or for a fatal signal to be received.
Another write may start after this one finishes, unless the caller
holds the folio lock.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li>0 if successful.</li>
<li>-EINTR if a fatal signal was encountered.</li>
</ul>
<dl class="function">
<dt id="c.netfs_i_context">
struct <a class="reference internal" href="#c.netfs_i_context" title="netfs_i_context">netfs_i_context</a> * <code class="descname">netfs_i_context</code><span class="sig-paren">(</span>struct inode<em>&nbsp;*inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_i_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the netfs inode context from the inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt>
<dd>The inode to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the netfs lib inode context from the network filesystem’s inode.  The
context struct is expected to directly follow on from the VFS inode struct.</p>
<dl class="function">
<dt id="c.netfs_inode">
struct inode * <code class="descname">netfs_inode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.netfs_i_context" title="netfs_i_context">netfs_i_context</a><em>&nbsp;*ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the netfs inode from the inode context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_i_context</span> <span class="pre">*ctx</span></code></dt>
<dd>The context to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the netfs inode from the netfs library’s inode context.  The VFS inode
is expected to directly precede the context struct.</p>
<dl class="function">
<dt id="c.netfs_i_context_init">
void <code class="descname">netfs_i_context_init</code><span class="sig-paren">(</span>struct inode<em>&nbsp;*inode</em>, const struct netfs_request_ops<em>&nbsp;*ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_i_context_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise a netfs lib context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt>
<dd>The inode with which the context is associated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">netfs_request_ops</span> <span class="pre">*ops</span></code></dt>
<dd>The netfs’s operations list</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialise the netfs library context struct.  This is expected to follow on
directly from the VFS inode struct.</p>
<dl class="function">
<dt id="c.netfs_resize_file">
void <code class="descname">netfs_resize_file</code><span class="sig-paren">(</span>struct inode<em>&nbsp;*inode</em>, loff_t<em>&nbsp;new_i_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_resize_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Note that a file got resized</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt>
<dd>The inode being resized</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">new_i_size</span></code></dt>
<dd>The new file size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the netfs lib that a file got resized so that it can adjust its state.</p>
<dl class="function">
<dt id="c.netfs_i_cookie">
struct fscache_cookie * <code class="descname">netfs_i_cookie</code><span class="sig-paren">(</span>struct inode<em>&nbsp;*inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_i_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the cache cookie from the inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt>
<dd>The inode to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the caching cookie (if enabled) from the network filesystem’s inode.</p>
<dl class="function">
<dt id="c.netfs_readahead">
void <code class="descname">netfs_readahead</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/mm-api.html#c.readahead_control" title="readahead_control">readahead_control</a><em>&nbsp;*ractl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_readahead" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to manage a read request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">readahead_control</span> <span class="pre">*ractl</span></code></dt>
<dd>The description of the readahead request</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fulfil a readahead request by drawing data from the cache if possible, or
the netfs if not.  Space beyond the EOF is zero-filled.  Multiple I/O
requests from different sources will get munged together.  If necessary, the
readahead window can be expanded in either direction to a more convenient
alighment for RPC efficiency or to make storage in the cache feasible.</p>
<p>The calling netfs must initialise a netfs context contiguous to the vfs
inode before calling this.</p>
<p>This is usable whether or not caching is enabled.</p>
<dl class="function">
<dt id="c.netfs_readpage">
int <code class="descname">netfs_readpage</code><span class="sig-paren">(</span>struct file<em>&nbsp;*file</em>, struct page<em>&nbsp;*subpage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_readpage" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to manage a readpage request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt>
<dd>The file to read from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*subpage</span></code></dt>
<dd>A subpage of the folio to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fulfil a readpage request by drawing data from the cache if possible, or the
netfs if not.  Space beyond the EOF is zero-filled.  Multiple I/O requests
from different sources will get munged together.</p>
<p>The calling netfs must initialise a netfs context contiguous to the vfs
inode before calling this.</p>
<p>This is usable whether or not caching is enabled.</p>
<dl class="function">
<dt id="c.netfs_write_begin">
int <code class="descname">netfs_write_begin</code><span class="sig-paren">(</span>struct file<em>&nbsp;*file</em>, struct <a class="reference internal" href="api-summary.html#c.address_space" title="address_space">address_space</a><em>&nbsp;*mapping</em>, loff_t<em>&nbsp;pos</em>, unsigned int<em>&nbsp;len</em>, unsigned int<em>&nbsp;aop_flags</em>, struct <a class="reference internal" href="../core-api/mm-api.html#c.folio" title="folio">folio</a><em>&nbsp;**_folio</em>, void<em>&nbsp;**_fsdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_write_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to prepare for writing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt>
<dd>The file to read from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*mapping</span></code></dt>
<dd>The mapping to read from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>File position at which the write will begin</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>The length of the write (may extend beyond the end of the folio chosen)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">aop_flags</span></code></dt>
<dd>AOP_* flags</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">folio</span> <span class="pre">**_folio</span></code></dt>
<dd>Where to put the resultant folio</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**_fsdata</span></code></dt>
<dd>Place for the netfs to store a cookie</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pre-read data for a write-begin request by drawing data from the cache if
possible, or the netfs if not.  Space beyond the EOF is zero-filled.
Multiple I/O requests from different sources will get munged together.  If
necessary, the readahead window can be expanded in either direction to a
more convenient alighment for RPC efficiency or to make storage in the cache
feasible.</p>
<p>The calling netfs must provide a table of operations, only one of which,
issue_op, is mandatory.</p>
<p>The check_write_begin() operation can be provided to check for and flush
conflicting writes once the folio is grabbed and locked.  It is passed a
pointer to the fsdata cookie that gets returned to the VM to be passed to
write_end.  It is permitted to sleep.  It should return 0 if the request
should go ahead; unlock the folio and return -EAGAIN to cause the folio to
be regot; or return an error.</p>
<p>The calling netfs must initialise a netfs context contiguous to the vfs
inode before calling this.</p>
<p>This is usable whether or not caching is enabled.</p>
<dl class="function">
<dt id="c.netfs_subreq_terminated">
void <code class="descname">netfs_subreq_terminated</code><span class="sig-paren">(</span>struct netfs_io_subrequest<em>&nbsp;*subreq</em>, ssize_t<em>&nbsp;transferred_or_error</em>, bool<em>&nbsp;was_async</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netfs_subreq_terminated" title="Permalink to this definition">¶</a></dt>
<dd><p>Note the termination of an I/O operation.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netfs_io_subrequest</span> <span class="pre">*subreq</span></code></dt>
<dd>The I/O request that has terminated.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">transferred_or_error</span></code></dt>
<dd>The amount of data transferred or an error code.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">was_async</span></code></dt>
<dd>The termination was asynchronous</dd>
</dl>
<p><strong>Description</strong></p>
<p>This tells the read helper that a contributory I/O operation has terminated,
one way or another, and that it should integrate the results.</p>
<p>The caller indicates in <strong>transferred_or_error</strong> the outcome of the operation,
supplying a positive value to indicate the number of bytes transferred, 0 to
indicate a failure to transfer anything that should be retried or a negative
error code.  The helper will look after reissuing I/O operations as
appropriate and writing downloaded data to the cache.</p>
<p>If <strong>was_async</strong> is true, the caller might be running in softirq or interrupt
context and we can’t sleep.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="9p.html" class="btn btn-neutral float-right" title="v9fs: Plan 9 Resource Sharing for Linux" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="fsverity.html" class="btn btn-neutral" title="fs-verity: read-only file-based authenticity protection" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>