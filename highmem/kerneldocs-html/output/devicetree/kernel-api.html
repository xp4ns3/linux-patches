

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DeviceTree Kernel API &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Open Firmware and Devicetree" href="index.html"/>
        <link rel="next" title="Devicetree Changesets" href="changesets.html"/>
        <link rel="prev" title="Open Firmware Devicetree Unittest" href="of_unittest.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Open Firmware and Devicetree</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#kernel-devicetree-usage">Kernel Devicetree Usage</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="usage-model.html">Linux and the Devicetree</a></li>
<li class="toctree-l3"><a class="reference internal" href="of_unittest.html">Open Firmware Devicetree Unittest</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">DeviceTree Kernel API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#core-functions">Core functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-model-functions">Driver model functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overlay-and-dynamic-dt-functions">Overlay and Dynamic DT functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#devicetree-overlays">Devicetree Overlays</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#devicetree-bindings">Devicetree Bindings</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Open Firmware and Devicetree</a> &raquo;</li>
        
      <li>DeviceTree Kernel API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/devicetree/kernel-api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="devicetree-kernel-api">
<span id="devicetree"></span><h1>DeviceTree Kernel API<a class="headerlink" href="#devicetree-kernel-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="core-functions">
<h2>Core functions<a class="headerlink" href="#core-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.of_find_all_nodes">
struct device_node * <code class="descname">of_find_all_nodes</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*prev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_all_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get next node in global list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*prev</span></code></dt>
<dd>Previous node or NULL to start iteration
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> will be called on it</dd>
</dl>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_get_cpu_node">
struct device_node * <code class="descname">of_get_cpu_node</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, unsigned int<em>&nbsp;*thread</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_cpu_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device node associated with the given logical CPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>CPU number(logical index) for which device node is required</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*thread</span></code></dt>
<dd>if not NULL, local thread number within the physical core is
returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>The main purpose of this function is to retrieve the device node for the
given logical CPU index. It should be used to initialize the of_node in
cpu device. Once of_node in cpu device is populated, all the further
references can use that instead.</p>
<p>CPU logical to physical index mapping is architecture specific and is built
before booting secondary cores. This function uses arch_match_cpu_phys_id
which can be overridden by architecture specific implementation.</p>
<p><strong>Return</strong></p>
<p>A node pointer for the logical cpu with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done. Returns NULL if not found.</p>
<dl class="function">
<dt id="c.of_cpu_node_to_id">
int <code class="descname">of_cpu_node_to_id</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*cpu_node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_cpu_node_to_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the logical CPU number for a given device_node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*cpu_node</span></code></dt>
<dd>Pointer to the device_node for CPU.</dd>
</dl>
<p><strong>Return</strong></p>
<p>The logical CPU number of the given CPU device_node or -ENODEV if the
CPU is not found.</p>
<dl class="function">
<dt id="c.of_get_cpu_state_node">
struct device_node * <code class="descname">of_get_cpu_state_node</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*cpu_node</em>, int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_cpu_state_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get CPU’s idle state node at the given index</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*cpu_node</span></code></dt>
<dd>The device node for the CPU</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>The index in the list of the idle states</dd>
</dl>
<p><strong>Description</strong></p>
<p>Two generic methods can be used to describe a CPU’s idle states, either via
a flattened description through the “cpu-idle-states” binding or via the
hierarchical layout, using the “power-domains” and the “domain-idle-states”
bindings. This function check for both and returns the idle state node for
the requested index.</p>
<p><strong>Return</strong></p>
<p>An idle state node if found at <strong>index</strong>. The refcount is incremented
for it, so call <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done. Returns NULL if not found.</p>
<dl class="function">
<dt id="c.of_machine_is_compatible">
int <code class="descname">of_machine_is_compatible</code><span class="sig-paren">(</span>const char<em>&nbsp;*compat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_machine_is_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Test root of device tree for a given compatible value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*compat</span></code></dt>
<dd>compatible string to look for in root node’s compatible property.</dd>
</dl>
<p><strong>Return</strong></p>
<p>A positive integer if the root node has the given value in its
compatible property.</p>
<dl class="function">
<dt id="c.of_device_is_available">
bool <code class="descname">of_device_is_available</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_device_is_available" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a device is available for use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*device</span></code></dt>
<dd>Node to check for availability</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>True if the status property is absent or set to “okay” or “ok”,</dt>
<dd>false otherwise</dd>
</dl>
<dl class="function">
<dt id="c.of_device_is_big_endian">
bool <code class="descname">of_device_is_big_endian</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_device_is_big_endian" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a device has BE registers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*device</span></code></dt>
<dd>Node to check for endianness</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>True if the device has a “big-endian” property, or if the kernel</dt>
<dd><p class="first">was compiled for BE <em>and</em> the device has a “native-endian” property.
Returns false otherwise.</p>
<p class="last">Callers would nominally use ioread32be/iowrite32be if
<a class="reference internal" href="#c.of_device_is_big_endian" title="of_device_is_big_endian"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_device_is_big_endian()</span></code></a> == true, or readl/writel otherwise.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.of_get_parent">
struct device_node * <code class="descname">of_get_parent</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a node’s parent if any</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>Node to get parent</dd>
</dl>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_get_next_parent">
struct device_node * <code class="descname">of_get_next_parent</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_next_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate to a node’s parent</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>Node to get parent of</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is like <a class="reference internal" href="#c.of_get_parent" title="of_get_parent"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_get_parent()</span></code></a> except that it drops the
refcount on the passed node, making it suitable for iterating
through a node’s parents.</p>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_get_next_child">
struct device_node * <code class="descname">of_get_next_child</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*node</em>, struct device_node<em>&nbsp;*prev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_next_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate a node childs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>parent node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*prev</span></code></dt>
<dd>previous child of the parent node, or NULL to get first</dd>
</dl>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on
it when done. Returns NULL when prev is the last child. Decrements the
refcount of prev.</p>
<dl class="function">
<dt id="c.of_get_next_available_child">
struct device_node * <code class="descname">of_get_next_available_child</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*node</em>, struct device_node<em>&nbsp;*prev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_next_available_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the next available child node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>parent node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*prev</span></code></dt>
<dd>previous child of the parent node, or NULL to get first</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is like <a class="reference internal" href="#c.of_get_next_child" title="of_get_next_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_get_next_child()</span></code></a>, except that it
automatically skips any disabled nodes (i.e. status = “disabled”).</p>
<dl class="function">
<dt id="c.of_get_next_cpu_node">
struct device_node * <code class="descname">of_get_next_cpu_node</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*prev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_next_cpu_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate on cpu nodes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*prev</span></code></dt>
<dd>previous child of the /cpus node, or NULL to get first</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unusable CPUs (those with the status property set to “fail” or “fail-…”)
will be skipped.</p>
<p><strong>Return</strong></p>
<p>A cpu node pointer with refcount incremented, use <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a>
on it when done. Returns NULL when prev is the last child. Decrements
the refcount of prev.</p>
<dl class="function">
<dt id="c.of_get_compatible_child">
struct device_node * <code class="descname">of_get_compatible_child</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*parent</em>, const char<em>&nbsp;*compatible</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_compatible_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Find compatible child node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*parent</span></code></dt>
<dd>parent node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*compatible</span></code></dt>
<dd>compatible string</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lookup child node whose compatible property contains the given compatible
string.</p>
<p><strong>Return</strong></p>
<p>a node pointer with refcount incremented, use <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it
when done; or NULL if not found.</p>
<dl class="function">
<dt id="c.of_get_child_by_name">
struct device_node * <code class="descname">of_get_child_by_name</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*node</em>, const char<em>&nbsp;*name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_child_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the child node by name for a given parent</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>parent node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt>
<dd>child name to look for.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks for child node for given matching name</p>
<p><strong>Return</strong></p>
<p>A node pointer if found, with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.
Returns NULL if node is not found.</p>
<dl class="function">
<dt id="c.of_find_node_opts_by_path">
struct device_node * <code class="descname">of_find_node_opts_by_path</code><span class="sig-paren">(</span>const char<em>&nbsp;*path</em>, const char<em>&nbsp;**opts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_node_opts_by_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a node matching a full OF path</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*path</span></code></dt>
<dd>Either the full path to match, or if the path does not
start with ‘/’, the name of a property of the /aliases
node (an alias).  In the case of an alias, the node
matching the alias’ value will be returned.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">**opts</span></code></dt>
<dd>Address of a pointer into which to store the start of
an options string appended to the end of the path with
a ‘:’ separator.</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Valid paths:</dt>
<dd><ul class="first last simple">
<li>/foo/bar  Full path</li>
<li>foo       Valid alias</li>
<li>foo/bar   Valid alias + relative path</li>
</ul>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_find_node_by_name">
struct device_node * <code class="descname">of_find_node_by_name</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*from</em>, const char<em>&nbsp;*name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_node_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a node by its “name” property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*from</span></code></dt>
<dd>The node to start searching from or NULL; the node
you pass will not be searched, only the next one
will. Typically, you pass what the previous call
returned. <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> will be called on <strong>from</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt>
<dd>The name string to match against</dd>
</dl>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_find_node_by_type">
struct device_node * <code class="descname">of_find_node_by_type</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*from</em>, const char<em>&nbsp;*type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_node_by_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a node by its “device_type” property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*from</span></code></dt>
<dd>The node to start searching from, or NULL to start searching
the entire device tree. The node you pass will not be
searched, only the next one will; typically, you pass
what the previous call returned. <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> will be
called on from for you.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*type</span></code></dt>
<dd>The type string to match against</dd>
</dl>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_find_compatible_node">
struct device_node * <code class="descname">of_find_compatible_node</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*from</em>, const char<em>&nbsp;*type</em>, const char<em>&nbsp;*compatible</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_compatible_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a node based on type and one of the tokens in its “compatible” property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*from</span></code></dt>
<dd>The node to start searching from or NULL, the node
you pass will not be searched, only the next one
will; typically, you pass what the previous call
returned. <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> will be called on it</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*type</span></code></dt>
<dd>The type string to match “device_type” or NULL to ignore</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*compatible</span></code></dt>
<dd>The string to match to one of the tokens in the device
“compatible” list.</dd>
</dl>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_find_node_with_property">
struct device_node * <code class="descname">of_find_node_with_property</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*from</em>, const char<em>&nbsp;*prop_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_node_with_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a node which has a property with the given name.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*from</span></code></dt>
<dd>The node to start searching from or NULL, the node
you pass will not be searched, only the next one
will; typically, you pass what the previous call
returned. <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> will be called on it</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*prop_name</span></code></dt>
<dd>The name of the property to look for.</dd>
</dl>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_match_node">
const struct of_device_id * <code class="descname">of_match_node</code><span class="sig-paren">(</span>const struct of_device_id<em>&nbsp;*matches</em>, const struct device_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_match_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell if a device_node has a matching of_match structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">of_device_id</span> <span class="pre">*matches</span></code></dt>
<dd>array of of device match structures to search in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>the of device structure to match against</dd>
</dl>
<p><strong>Description</strong></p>
<p>Low level utility function used by device matching.</p>
<dl class="function">
<dt id="c.of_find_matching_node_and_match">
struct device_node * <code class="descname">of_find_matching_node_and_match</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*from</em>, const struct of_device_id<em>&nbsp;*matches</em>, const struct of_device_id<em>&nbsp;**match</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_matching_node_and_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a node based on an of_device_id match table.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*from</span></code></dt>
<dd>The node to start searching from or NULL, the node
you pass will not be searched, only the next one
will; typically, you pass what the previous call
returned. <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> will be called on it</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">of_device_id</span> <span class="pre">*matches</span></code></dt>
<dd>array of of device match structures to search in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">of_device_id</span> <span class="pre">**match</span></code></dt>
<dd>Updated to point at the matches entry which matched</dd>
</dl>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_modalias_node">
int <code class="descname">of_modalias_node</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*node</em>, char<em>&nbsp;*modalias</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_modalias_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookup appropriate modalias for a device node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>pointer to a device tree node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*modalias</span></code></dt>
<dd>Pointer to buffer that modalias value will be copied into</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>Length of modalias value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Based on the value of the compatible property, this routine will attempt
to choose an appropriate modalias value for a particular device tree node.
It does this by stripping the manufacturer prefix (as delimited by a ‘,’)
from the first entry in the compatible list property.</p>
<p><strong>Return</strong></p>
<p>This routine returns 0 on success, &lt;0 on failure.</p>
<dl class="function">
<dt id="c.of_find_node_by_phandle">
struct device_node * <code class="descname">of_find_node_by_phandle</code><span class="sig-paren">(</span>phandle<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_node_by_phandle" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a node given a phandle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">phandle</span> <span class="pre">handle</span></code></dt>
<dd>phandle of the node to find</dd>
</dl>
<p><strong>Return</strong></p>
<p>A node pointer with refcount incremented, use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_parse_phandle_with_args_map">
int <code class="descname">of_parse_phandle_with_args_map</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*list_name</em>, const char<em>&nbsp;*stem_name</em>, int<em>&nbsp;index</em>, struct of_phandle_args<em>&nbsp;*out_args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_parse_phandle_with_args_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a node pointed by phandle in a list and remap it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>pointer to a device tree node containing a list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*list_name</span></code></dt>
<dd>property name that contains a list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*stem_name</span></code></dt>
<dd>stem of property names that specify phandles’ arguments count</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of a phandle to parse out</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_phandle_args</span> <span class="pre">*out_args</span></code></dt>
<dd>optional pointer to output arguments structure (will be filled)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is useful to parse lists of phandles and their arguments.
Returns 0 on success and fills out_args, on error returns appropriate errno
value. The difference between this function and <a class="reference internal" href="#c.of_parse_phandle_with_args" title="of_parse_phandle_with_args"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_parse_phandle_with_args()</span></code></a>
is that this API remaps a phandle if the node the phandle points to has
a &lt;<strong>stem_name</strong>&gt;-map property.</p>
<p>Caller is responsible to call <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on the returned out_args-&gt;np
pointer.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>phandle1: node1 {
    #list-cells = &lt;2&gt;;
};

phandle2: node2 {
    #list-cells = &lt;1&gt;;
};

phandle3: node3 {
    #list-cells = &lt;1&gt;;
    list-map = &lt;0 &amp;phandle2 3&gt;,
               &lt;1 &amp;phandle2 2&gt;,
               &lt;2 &amp;phandle1 5 1&gt;;
    list-map-mask = &lt;0x3&gt;;
};

node4 {
    list = &lt;&amp;phandle1 1 2 &amp;phandle3 0&gt;;
};
</pre></div>
</div>
<p>To get a device_node of the <code class="docutils literal notranslate"><span class="pre">node2</span></code> node you may call this:
of_parse_phandle_with_args(node4, “list”, “list”, 1, <code class="xref c c-type docutils literal notranslate"><span class="pre">args</span></code>);</p>
<dl class="function">
<dt id="c.of_count_phandle_with_args">
int <code class="descname">of_count_phandle_with_args</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*list_name</em>, const char<em>&nbsp;*cells_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_count_phandle_with_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the number of phandles references in a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>pointer to a device tree node containing a list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*list_name</span></code></dt>
<dd>property name that contains a list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*cells_name</span></code></dt>
<dd>property name that specifies phandles’ arguments count</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of phandle + argument tuples within a property. It
is a typical pattern to encode a list of phandle and variable
arguments into a single property. The number of arguments is encoded
by a property in the phandle-target node. For example, a gpios
property would contain a list of GPIO specifies consisting of a
phandle and 1 or more arguments. The number of arguments are
determined by the #gpio-cells property in the node pointed to by the
phandle.</p>
<dl class="function">
<dt id="c.of_add_property">
int <code class="descname">of_add_property</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*np</em>, struct property<em>&nbsp;*prop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_add_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a property to a node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>Caller’s Device Node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">property</span> <span class="pre">*prop</span></code></dt>
<dd>Property to add</dd>
</dl>
<dl class="function">
<dt id="c.of_remove_property">
int <code class="descname">of_remove_property</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*np</em>, struct property<em>&nbsp;*prop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_remove_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a property from a node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>Caller’s Device Node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">property</span> <span class="pre">*prop</span></code></dt>
<dd>Property to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that we don’t actually remove it, since we have given out
who-knows-how-many pointers to the data using get-property.
Instead we just move the property to the “dead properties”
list, so it won’t be found any more.</p>
<dl class="function">
<dt id="c.of_alias_get_id">
int <code class="descname">of_alias_get_id</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*stem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_alias_get_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get alias id for the given device_node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>Pointer to the given device_node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*stem</span></code></dt>
<dd>Alias stem of the given device_node</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function travels the lookup table to get the alias id for the given
device_node and alias stem.</p>
<p><strong>Return</strong></p>
<p>The alias id if found.</p>
<dl class="function">
<dt id="c.of_alias_get_highest_id">
int <code class="descname">of_alias_get_highest_id</code><span class="sig-paren">(</span>const char<em>&nbsp;*stem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_alias_get_highest_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get highest alias id for the given stem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*stem</span></code></dt>
<dd>Alias stem to be examined</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function travels the lookup table to get the highest alias id for the
given alias stem.  It returns the alias id if found.</p>
<dl class="function">
<dt id="c.of_console_check">
bool <code class="descname">of_console_check</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*dn</em>, char<em>&nbsp;*name</em>, int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_console_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Test and setup console for DT setup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*dn</span></code></dt>
<dd>Pointer to device node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*name</span></code></dt>
<dd>Name to use for preferred console without index. ex. “ttyS”</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>Index to use for preferred console.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the given device node matches the stdout-path property in the
/chosen node. If it does then register it as the preferred console.</p>
<p><strong>Return</strong></p>
<p>TRUE if console successfully setup. Otherwise return FALSE.</p>
<dl class="function">
<dt id="c.of_map_id">
int <code class="descname">of_map_id</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*np</em>, u32<em>&nbsp;id</em>, const char<em>&nbsp;*map_name</em>, const char<em>&nbsp;*map_mask_name</em>, struct device_node<em>&nbsp;**target</em>, u32<em>&nbsp;*id_out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_map_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate an ID through a downstream mapping.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>root complex device node.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">id</span></code></dt>
<dd>device ID to map.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*map_name</span></code></dt>
<dd>property name of the map to use.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*map_mask_name</span></code></dt>
<dd>optional property name of the mask to use.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">**target</span></code></dt>
<dd>optional pointer to a target device node.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*id_out</span></code></dt>
<dd>optional pointer to receive the translated ID.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a device ID, look up the appropriate implementation-defined
platform ID and/or the target device which receives transactions on that
ID, as per the “iommu-map” and “msi-map” bindings. Either of <strong>target</strong> or
<strong>id_out</strong> may be NULL if only the other is required. If <strong>target</strong> points to
a non-NULL device node pointer, only entries targeting that node will be
matched; if it points to a NULL value, it will receive the device node of
the first matching target phandle, with a reference held.</p>
<p><strong>Return</strong></p>
<p>0 on success or a standard error code on failure.</p>
<dl class="function">
<dt id="c.of_parse_phandle">
struct device_node * <code class="descname">of_parse_phandle</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*phandle_name</em>, int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_parse_phandle" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve a phandle property to a device_node pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>Pointer to device node holding phandle property</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*phandle_name</span></code></dt>
<dd>Name of property holding a phandle value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>For properties holding a table of phandles, this is the index into
the table</dd>
</dl>
<p><strong>Return</strong></p>
<p>The device_node pointer with refcount incremented.  Use
<a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_parse_phandle_with_args">
int <code class="descname">of_parse_phandle_with_args</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*list_name</em>, const char<em>&nbsp;*cells_name</em>, int<em>&nbsp;index</em>, struct of_phandle_args<em>&nbsp;*out_args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_parse_phandle_with_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a node pointed by phandle in a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>pointer to a device tree node containing a list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*list_name</span></code></dt>
<dd>property name that contains a list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*cells_name</span></code></dt>
<dd>property name that specifies phandles’ arguments count</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of a phandle to parse out</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_phandle_args</span> <span class="pre">*out_args</span></code></dt>
<dd>optional pointer to output arguments structure (will be filled)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is useful to parse lists of phandles and their arguments.
Returns 0 on success and fills out_args, on error returns appropriate
errno value.</p>
<p>Caller is responsible to call <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on the returned out_args-&gt;np
pointer.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>phandle1: node1 {
    #list-cells = &lt;2&gt;;
};

phandle2: node2 {
    #list-cells = &lt;1&gt;;
};

node3 {
    list = &lt;&amp;phandle1 1 2 &amp;phandle2 3&gt;;
};
</pre></div>
</div>
<p>To get a device_node of the <code class="docutils literal notranslate"><span class="pre">node2</span></code> node you may call this:
of_parse_phandle_with_args(node3, “list”, “#list-cells”, 1, <code class="xref c c-type docutils literal notranslate"><span class="pre">args</span></code>);</p>
<dl class="function">
<dt id="c.of_parse_phandle_with_fixed_args">
int <code class="descname">of_parse_phandle_with_fixed_args</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*list_name</em>, int<em>&nbsp;cell_count</em>, int<em>&nbsp;index</em>, struct of_phandle_args<em>&nbsp;*out_args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_parse_phandle_with_fixed_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a node pointed by phandle in a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>pointer to a device tree node containing a list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*list_name</span></code></dt>
<dd>property name that contains a list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cell_count</span></code></dt>
<dd>number of argument cells following the phandle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of a phandle to parse out</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_phandle_args</span> <span class="pre">*out_args</span></code></dt>
<dd>optional pointer to output arguments structure (will be filled)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is useful to parse lists of phandles and their arguments.
Returns 0 on success and fills out_args, on error returns appropriate
errno value.</p>
<p>Caller is responsible to call <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on the returned out_args-&gt;np
pointer.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>phandle1: node1 {
};

phandle2: node2 {
};

node3 {
    list = &lt;&amp;phandle1 0 2 &amp;phandle2 2 3&gt;;
};
</pre></div>
</div>
<p>To get a device_node of the <code class="docutils literal notranslate"><span class="pre">node2</span></code> node you may call this:
of_parse_phandle_with_fixed_args(node3, “list”, 2, 1, <code class="xref c c-type docutils literal notranslate"><span class="pre">args</span></code>);</p>
<dl class="function">
<dt id="c.of_property_count_u8_elems">
int <code class="descname">of_property_count_u8_elems</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_count_u8_elems" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of u8 elements in a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and count the number of u8 elements
in it.</p>
<p><strong>Return</strong></p>
<p>The number of elements on sucess, -EINVAL if the property does
not exist or its length does not match a multiple of u8 and -ENODATA if the
property does not have a value.</p>
<dl class="function">
<dt id="c.of_property_count_u16_elems">
int <code class="descname">of_property_count_u16_elems</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_count_u16_elems" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of u16 elements in a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and count the number of u16 elements
in it.</p>
<p><strong>Return</strong></p>
<p>The number of elements on sucess, -EINVAL if the property does
not exist or its length does not match a multiple of u16 and -ENODATA if the
property does not have a value.</p>
<dl class="function">
<dt id="c.of_property_count_u32_elems">
int <code class="descname">of_property_count_u32_elems</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_count_u32_elems" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of u32 elements in a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and count the number of u32 elements
in it.</p>
<p><strong>Return</strong></p>
<p>The number of elements on sucess, -EINVAL if the property does
not exist or its length does not match a multiple of u32 and -ENODATA if the
property does not have a value.</p>
<dl class="function">
<dt id="c.of_property_count_u64_elems">
int <code class="descname">of_property_count_u64_elems</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_count_u64_elems" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of u64 elements in a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and count the number of u64 elements
in it.</p>
<p><strong>Return</strong></p>
<p>The number of elements on sucess, -EINVAL if the property does
not exist or its length does not match a multiple of u64 and -ENODATA if the
property does not have a value.</p>
<dl class="function">
<dt id="c.of_property_read_string_array">
int <code class="descname">of_property_read_string_array</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, const char<em>&nbsp;**out_strs</em>, size_t<em>&nbsp;sz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_string_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an array of strings from a multiple strings property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">**out_strs</span></code></dt>
<dd>output array of string pointers.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz</span></code></dt>
<dd>number of array elements to read.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device tree node and retrieve a list of
terminated string values (pointer to data, not a copy) in that property.</p>
<p><strong>Return</strong></p>
<p>If <strong>out_strs</strong> is NULL, the number of strings in the property is returned.</p>
<dl class="function">
<dt id="c.of_property_count_strings">
int <code class="descname">of_property_count_strings</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_count_strings" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and return the number of strings from a multiple strings property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device tree node and retrieve the number of null
terminated string contain in it.</p>
<p><strong>Return</strong></p>
<p>The number of strings on success, -EINVAL if the property does not
exist, -ENODATA if property does not have a value, and -EILSEQ if the string
is not null-terminated within the length of the property data.</p>
<dl class="function">
<dt id="c.of_property_read_string_index">
int <code class="descname">of_property_read_string_index</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, int<em>&nbsp;index</em>, const char<em>&nbsp;**output</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_string_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read a string from a multiple strings property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of the string in the list of strings</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">**output</span></code></dt>
<dd>pointer to null terminated return string, modified only if
return value is 0.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device tree node and retrieve a null
terminated string value (pointer to data, not a copy) in the list of strings
contained in that property.</p>
<p>The out_string pointer is modified only if a valid string can be decoded.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if the property does not exist, -ENODATA if
property does not have a value, and -EILSEQ if the string is not
null-terminated within the length of the property data.</p>
<dl class="function">
<dt id="c.of_property_read_bool">
bool <code class="descname">of_property_read_bool</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node.</p>
<p><strong>Return</strong></p>
<p>true if the property exists false otherwise.</p>
<dl class="function">
<dt id="c.of_property_read_u8_array">
int <code class="descname">of_property_read_u8_array</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u8<em>&nbsp;*out_values</em>, size_t<em>&nbsp;sz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_u8_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read an array of u8 from a property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*out_values</span></code></dt>
<dd>pointer to return value, modified only if return value is 0.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz</span></code></dt>
<dd>number of array elements to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read 8-bit value(s) from
it.</p>
<dl class="docutils">
<dt>dts entry of array should be like:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">=</span> <span class="pre">/bits/</span> <span class="pre">8</span> <span class="pre">&lt;0x50</span> <span class="pre">0x60</span> <span class="pre">0x70&gt;;</span></code></dd>
</dl>
<p>The out_values is modified only if a valid u8 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if the property does not exist,
-ENODATA if property does not have a value, and -EOVERFLOW if the
property data isn’t large enough.</p>
<dl class="function">
<dt id="c.of_property_read_u16_array">
int <code class="descname">of_property_read_u16_array</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u16<em>&nbsp;*out_values</em>, size_t<em>&nbsp;sz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_u16_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read an array of u16 from a property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*out_values</span></code></dt>
<dd>pointer to return value, modified only if return value is 0.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz</span></code></dt>
<dd>number of array elements to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read 16-bit value(s) from
it.</p>
<dl class="docutils">
<dt>dts entry of array should be like:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">=</span> <span class="pre">/bits/</span> <span class="pre">16</span> <span class="pre">&lt;0x5000</span> <span class="pre">0x6000</span> <span class="pre">0x7000&gt;;</span></code></dd>
</dl>
<p>The out_values is modified only if a valid u16 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if the property does not exist,
-ENODATA if property does not have a value, and -EOVERFLOW if the
property data isn’t large enough.</p>
<dl class="function">
<dt id="c.of_property_read_u32_array">
int <code class="descname">of_property_read_u32_array</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u32<em>&nbsp;*out_values</em>, size_t<em>&nbsp;sz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_u32_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read an array of 32 bit integers from a property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*out_values</span></code></dt>
<dd>pointer to return value, modified only if return value is 0.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz</span></code></dt>
<dd>number of array elements to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read 32-bit value(s) from
it.</p>
<p>The out_values is modified only if a valid u32 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if the property does not exist,
-ENODATA if property does not have a value, and -EOVERFLOW if the
property data isn’t large enough.</p>
<dl class="function">
<dt id="c.of_property_read_u64_array">
int <code class="descname">of_property_read_u64_array</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u64<em>&nbsp;*out_values</em>, size_t<em>&nbsp;sz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_u64_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read an array of 64 bit integers from a property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*out_values</span></code></dt>
<dd>pointer to return value, modified only if return value is 0.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz</span></code></dt>
<dd>number of array elements to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read 64-bit value(s) from
it.</p>
<p>The out_values is modified only if a valid u64 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if the property does not exist,
-ENODATA if property does not have a value, and -EOVERFLOW if the
property data isn’t large enough.</p>
<dl class="type">
<dt id="c.of_changeset_entry">
struct <code class="descname">of_changeset_entry</code><a class="headerlink" href="#c.of_changeset_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds a changeset entry</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct of_changeset_entry {
  struct list_head node;
  unsigned long action;
  struct device_node *np;
  struct property *prop;
  struct property *old_prop;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt>
<dd>list_head for the log list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">action</span></code></dt>
<dd>notifier action</dd>
<dt><code class="docutils literal notranslate"><span class="pre">np</span></code></dt>
<dd>pointer to the device node affected</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop</span></code></dt>
<dd>pointer to the property affected</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_prop</span></code></dt>
<dd>hold a pointer to the original property</dd>
</dl>
<p><strong>Description</strong></p>
<p>Every modification of the device tree during a changeset
is held in a list of of_changeset_entry structures.
That way we can recover from a partial application, or we can
revert the changeset</p>
<dl class="type">
<dt id="c.of_changeset">
struct <code class="descname">of_changeset</code><a class="headerlink" href="#c.of_changeset" title="Permalink to this definition">¶</a></dt>
<dd><p>changeset tracker structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct of_changeset {
  struct list_head entries;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">entries</span></code></dt>
<dd>list_head for the changeset entries</dd>
</dl>
<p><strong>Description</strong></p>
<p>changesets are a convenient way to apply bulk changes to the
live tree. In case of an error, changes are rolled-back.
changesets live on after initial application, and if not
destroyed after use, they can be reverted in one single call.</p>
<dl class="function">
<dt id="c.of_device_is_system_power_controller">
bool <code class="descname">of_device_is_system_power_controller</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_device_is_system_power_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells if system-power-controller is found for device_node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>Pointer to the given device_node</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if present false otherwise</p>
<dl class="function">
<dt id="c.of_graph_is_present">
bool <code class="descname">of_graph_is_present</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_graph_is_present" title="Permalink to this definition">¶</a></dt>
<dd><p>check graph’s presence</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>pointer to device_node containing graph port</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if <strong>node</strong> has a port or ports (with a port) sub-node,
false otherwise.</p>
<dl class="function">
<dt id="c.of_property_count_elems_of_size">
int <code class="descname">of_property_count_elems_of_size</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, int<em>&nbsp;elem_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_count_elems_of_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of elements in a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">elem_size</span></code></dt>
<dd>size of the individual element</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and count the number of elements of
size elem_size in it.</p>
<p><strong>Return</strong></p>
<p>The number of elements on sucess, -EINVAL if the property does not
exist or its length does not match a multiple of elem_size and -ENODATA if
the property does not have a value.</p>
<dl class="function">
<dt id="c.of_property_read_u32_index">
int <code class="descname">of_property_read_u32_index</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u32<em>&nbsp;index</em>, u32<em>&nbsp;*out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_u32_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read a u32 from a multi-value property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">index</span></code></dt>
<dd>index of the u32 in the list of values</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*out_value</span></code></dt>
<dd>pointer to return value, modified only if no error.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read nth 32-bit value from
it.</p>
<p>The out_value is modified only if a valid u32 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if the property does not exist,
-ENODATA if property does not have a value, and -EOVERFLOW if the
property data isn’t large enough.</p>
<dl class="function">
<dt id="c.of_property_read_u64_index">
int <code class="descname">of_property_read_u64_index</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u32<em>&nbsp;index</em>, u64<em>&nbsp;*out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_u64_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read a u64 from a multi-value property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">index</span></code></dt>
<dd>index of the u64 in the list of values</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*out_value</span></code></dt>
<dd>pointer to return value, modified only if no error.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read nth 64-bit value from
it.</p>
<p>The out_value is modified only if a valid u64 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if the property does not exist,
-ENODATA if property does not have a value, and -EOVERFLOW if the
property data isn’t large enough.</p>
<dl class="function">
<dt id="c.of_property_read_variable_u8_array">
int <code class="descname">of_property_read_variable_u8_array</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u8<em>&nbsp;*out_values</em>, size_t<em>&nbsp;sz_min</em>, size_t<em>&nbsp;sz_max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_variable_u8_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read an array of u8 from a property, with bounds on the minimum and maximum array size.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*out_values</span></code></dt>
<dd>pointer to found values.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz_min</span></code></dt>
<dd>minimum number of array elements to read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz_max</span></code></dt>
<dd>maximum number of array elements to read, if zero there is no
upper limit on the number of elements in the dts entry but only
sz_min will be read.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read 8-bit value(s) from
it.</p>
<dl class="docutils">
<dt>dts entry of array should be like:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">=</span> <span class="pre">/bits/</span> <span class="pre">8</span> <span class="pre">&lt;0x50</span> <span class="pre">0x60</span> <span class="pre">0x70&gt;;</span></code></dd>
</dl>
<p>The out_values is modified only if a valid u8 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>The number of elements read on success, -EINVAL if the property
does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
if the property data is smaller than sz_min or longer than sz_max.</p>
<dl class="function">
<dt id="c.of_property_read_variable_u16_array">
int <code class="descname">of_property_read_variable_u16_array</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u16<em>&nbsp;*out_values</em>, size_t<em>&nbsp;sz_min</em>, size_t<em>&nbsp;sz_max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_variable_u16_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read an array of u16 from a property, with bounds on the minimum and maximum array size.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*out_values</span></code></dt>
<dd>pointer to found values.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz_min</span></code></dt>
<dd>minimum number of array elements to read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz_max</span></code></dt>
<dd>maximum number of array elements to read, if zero there is no
upper limit on the number of elements in the dts entry but only
sz_min will be read.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read 16-bit value(s) from
it.</p>
<dl class="docutils">
<dt>dts entry of array should be like:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">=</span> <span class="pre">/bits/</span> <span class="pre">16</span> <span class="pre">&lt;0x5000</span> <span class="pre">0x6000</span> <span class="pre">0x7000&gt;;</span></code></dd>
</dl>
<p>The out_values is modified only if a valid u16 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>The number of elements read on success, -EINVAL if the property
does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
if the property data is smaller than sz_min or longer than sz_max.</p>
<dl class="function">
<dt id="c.of_property_read_variable_u32_array">
int <code class="descname">of_property_read_variable_u32_array</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u32<em>&nbsp;*out_values</em>, size_t<em>&nbsp;sz_min</em>, size_t<em>&nbsp;sz_max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_variable_u32_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read an array of 32 bit integers from a property, with bounds on the minimum and maximum array size.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*out_values</span></code></dt>
<dd>pointer to return found values.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz_min</span></code></dt>
<dd>minimum number of array elements to read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz_max</span></code></dt>
<dd>maximum number of array elements to read, if zero there is no
upper limit on the number of elements in the dts entry but only
sz_min will be read.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read 32-bit value(s) from
it.</p>
<p>The out_values is modified only if a valid u32 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>The number of elements read on success, -EINVAL if the property
does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
if the property data is smaller than sz_min or longer than sz_max.</p>
<dl class="function">
<dt id="c.of_property_read_u64">
int <code class="descname">of_property_read_u64</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u64<em>&nbsp;*out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read a 64 bit integer from a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*out_value</span></code></dt>
<dd>pointer to return value, modified only if return value is 0.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read a 64-bit value from
it.</p>
<p>The out_value is modified only if a valid u64 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if the property does not exist,
-ENODATA if property does not have a value, and -EOVERFLOW if the
property data isn’t large enough.</p>
<dl class="function">
<dt id="c.of_property_read_variable_u64_array">
int <code class="descname">of_property_read_variable_u64_array</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, u64<em>&nbsp;*out_values</em>, size_t<em>&nbsp;sz_min</em>, size_t<em>&nbsp;sz_max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_variable_u64_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read an array of 64 bit integers from a property, with bounds on the minimum and maximum array size.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*out_values</span></code></dt>
<dd>pointer to found values.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz_min</span></code></dt>
<dd>minimum number of array elements to read</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz_max</span></code></dt>
<dd>maximum number of array elements to read, if zero there is no
upper limit on the number of elements in the dts entry but only
sz_min will be read.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device node and read 64-bit value(s) from
it.</p>
<p>The out_values is modified only if a valid u64 value can be decoded.</p>
<p><strong>Return</strong></p>
<p>The number of elements read on success, -EINVAL if the property
does not exist, -ENODATA if property does not have a value, and -EOVERFLOW
if the property data is smaller than sz_min or longer than sz_max.</p>
<dl class="function">
<dt id="c.of_property_read_string">
int <code class="descname">of_property_read_string</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, const char<em>&nbsp;**out_string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and read a string from a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">**out_string</span></code></dt>
<dd>pointer to null terminated return string, modified only if
return value is 0.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a property in a device tree node and retrieve a null
terminated string value (pointer to data, not a copy).</p>
<p>The out_string pointer is modified only if a valid string can be decoded.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if the property does not exist, -ENODATA if
property does not have a value, and -EILSEQ if the string is not
null-terminated within the length of the property data.</p>
<dl class="function">
<dt id="c.of_property_match_string">
int <code class="descname">of_property_match_string</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, const char<em>&nbsp;*string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_match_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Find string in a list and return index</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>pointer to node containing string list property</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>string list property name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*string</span></code></dt>
<dd>pointer to string to search for in string list</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function searches a string list property and returns the index
of a specific string value.</p>
<dl class="function">
<dt id="c.of_property_read_string_helper">
int <code class="descname">of_property_read_string_helper</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*propname</em>, const char<em>&nbsp;**out_strs</em>, size_t<em>&nbsp;sz</em>, int<em>&nbsp;skip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_property_read_string_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility helper for parsing string properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node from which the property value is to be read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt>
<dd>name of the property to be searched.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">**out_strs</span></code></dt>
<dd>output array of string pointers.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sz</span></code></dt>
<dd>number of array elements to read.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">skip</span></code></dt>
<dd>Number of strings to skip over at beginning of list.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Don’t call this function directly. It is a utility helper for the
of_property_read_string*() family of functions.</p>
<dl class="function">
<dt id="c.of_graph_parse_endpoint">
int <code class="descname">of_graph_parse_endpoint</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*node</em>, struct <a class="reference internal" href="#c.of_endpoint" title="of_endpoint">of_endpoint</a><em>&nbsp;*endpoint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_graph_parse_endpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>parse common endpoint node properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>pointer to endpoint device_node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_endpoint</span> <span class="pre">*endpoint</span></code></dt>
<dd>pointer to the OF endpoint data structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller should hold a reference to <strong>node</strong>.</p>
<dl class="function">
<dt id="c.of_graph_get_port_by_id">
struct device_node * <code class="descname">of_graph_get_port_by_id</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*parent</em>, u32<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_graph_get_port_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>get the port matching a given id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*parent</span></code></dt>
<dd>pointer to the parent device node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">id</span></code></dt>
<dd>id of the port</dd>
</dl>
<p><strong>Return</strong></p>
<p>A ‘port’ node pointer with refcount incremented. The caller
has to use <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_graph_get_next_endpoint">
struct device_node * <code class="descname">of_graph_get_next_endpoint</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*parent</em>, struct device_node<em>&nbsp;*prev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_graph_get_next_endpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>get next endpoint node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*parent</span></code></dt>
<dd>pointer to the parent device node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*prev</span></code></dt>
<dd>previous endpoint node, or NULL to get first</dd>
</dl>
<p><strong>Return</strong></p>
<p>An ‘endpoint’ node pointer with refcount incremented. Refcount
of the passed <strong>prev</strong> node is decremented.</p>
<dl class="function">
<dt id="c.of_graph_get_endpoint_by_regs">
struct device_node * <code class="descname">of_graph_get_endpoint_by_regs</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*parent</em>, int<em>&nbsp;port_reg</em>, int<em>&nbsp;reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_graph_get_endpoint_by_regs" title="Permalink to this definition">¶</a></dt>
<dd><p>get endpoint node of specific identifiers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*parent</span></code></dt>
<dd>pointer to the parent device node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">port_reg</span></code></dt>
<dd>identifier (value of reg property) of the parent port node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reg</span></code></dt>
<dd>identifier (value of reg property) of the endpoint node</dd>
</dl>
<p><strong>Return</strong></p>
<p>An ‘endpoint’ node pointer which is identified by reg and at the same
is the child of a port node identified by port_reg. reg and port_reg are
ignored when they are -1. Use <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on the pointer when done.</p>
<dl class="function">
<dt id="c.of_graph_get_remote_endpoint">
struct device_node * <code class="descname">of_graph_get_remote_endpoint</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_graph_get_remote_endpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>get remote endpoint node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>pointer to a local endpoint device_node</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Remote endpoint node associated with remote endpoint node linked</dt>
<dd>to <strong>node</strong>. Use <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</dd>
</dl>
<dl class="function">
<dt id="c.of_graph_get_port_parent">
struct device_node * <code class="descname">of_graph_get_port_parent</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_graph_get_port_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>get port’s parent node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>pointer to a local endpoint device_node</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>device node associated with endpoint node linked</dt>
<dd>to <strong>node</strong>. Use <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</dd>
</dl>
<dl class="function">
<dt id="c.of_graph_get_remote_port_parent">
struct device_node * <code class="descname">of_graph_get_remote_port_parent</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_graph_get_remote_port_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>get remote port’s parent node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>pointer to a local endpoint device_node</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Remote device node associated with remote endpoint node linked</dt>
<dd>to <strong>node</strong>. Use <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</dd>
</dl>
<dl class="function">
<dt id="c.of_graph_get_remote_port">
struct device_node * <code class="descname">of_graph_get_remote_port</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_graph_get_remote_port" title="Permalink to this definition">¶</a></dt>
<dd><p>get remote port node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>pointer to a local endpoint device_node</dd>
</dl>
<p><strong>Return</strong></p>
<p>Remote port node associated with remote endpoint node linked
to <strong>node</strong>. Use <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="function">
<dt id="c.of_graph_get_remote_node">
struct device_node * <code class="descname">of_graph_get_remote_node</code><span class="sig-paren">(</span>const struct device_node<em>&nbsp;*node</em>, u32<em>&nbsp;port</em>, u32<em>&nbsp;endpoint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_graph_get_remote_node" title="Permalink to this definition">¶</a></dt>
<dd><p>get remote parent device_node for given port/endpoint</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>pointer to parent device_node containing graph port/endpoint</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">port</span></code></dt>
<dd>identifier (value of reg property) of the parent port node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">endpoint</span></code></dt>
<dd>identifier (value of reg property) of the endpoint node</dd>
</dl>
<p><strong>Return</strong></p>
<p>Remote device node associated with remote endpoint node linked
to <strong>node</strong>. Use <a class="reference internal" href="#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a> on it when done.</p>
<dl class="type">
<dt id="c.of_endpoint">
struct <code class="descname">of_endpoint</code><a class="headerlink" href="#c.of_endpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>the OF graph endpoint data structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct of_endpoint {
  unsigned int port;
  unsigned int id;
  const struct device_node *local_node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt>
<dd>identifier (value of reg property) of a port this endpoint belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt>
<dd>identifier (value of reg property) of this endpoint</dd>
<dt><code class="docutils literal notranslate"><span class="pre">local_node</span></code></dt>
<dd>pointer to device_node of this endpoint</dd>
</dl>
<dl class="function">
<dt id="c.for_each_endpoint_of_node">
<code class="descname">for_each_endpoint_of_node</code><span class="sig-paren">(</span><em>parent</em>, <em>child</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_endpoint_of_node" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over every endpoint in a device node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt>
<dd>parent device node containing ports and endpoints</dd>
<dt><code class="docutils literal notranslate"><span class="pre">child</span></code></dt>
<dd>loop variable pointing to the current endpoint node</dd>
</dl>
<p><strong>Description</strong></p>
<p>When breaking out of the loop, of_node_put(child) has to be called manually.</p>
<dl class="function">
<dt id="c.of_address_to_resource">
int <code class="descname">of_address_to_resource</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*dev</em>, int<em>&nbsp;index</em>, struct resource<em>&nbsp;*r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_address_to_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate device tree address and return as resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*dev</span></code></dt>
<dd>Caller’s Device Node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>Index into the array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*r</span></code></dt>
<dd>Pointer to resource array</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if your address is a PIO address, the conversion will fail if
the physical address can’t be internally converted to an IO token with
pci_address_to_pio(), that is because it’s either called too early or it
can’t be matched to any host bridge IO space</p>
<dl class="function">
<dt id="c.of_iomap">
void __iomem * <code class="descname">of_iomap</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*np</em>, int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_iomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the memory mapped IO for a given device_node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>the device whose io range will be mapped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of the io range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the mapped memory</p>
<dl class="function">
<dt id="c.of_dma_is_coherent">
bool <code class="descname">of_dma_is_coherent</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_dma_is_coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device is coherent</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns true if “dma-coherent” property was found
for this device in the DT, or if DMA is coherent by
default for OF devices on the current platform.</p>
<dl class="function">
<dt id="c.irq_of_parse_and_map">
unsigned int <code class="descname">irq_of_parse_and_map</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*dev</em>, int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_of_parse_and_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse and map an interrupt into linux virq space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*dev</span></code></dt>
<dd>Device node of the device whose interrupt is to be mapped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>Index of the interrupt to map</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a wrapper that chains <a class="reference internal" href="#c.of_irq_parse_one" title="of_irq_parse_one"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_irq_parse_one()</span></code></a> and
irq_create_of_mapping() to make things easier to callers</p>
<dl class="function">
<dt id="c.of_irq_find_parent">
struct device_node * <code class="descname">of_irq_find_parent</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*child</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_irq_find_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a device node, find its interrupt parent node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*child</span></code></dt>
<dd>pointer to device node</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the interrupt parent node, or NULL if the interrupt
parent could not be determined.</p>
<dl class="function">
<dt id="c.of_irq_parse_raw">
int <code class="descname">of_irq_parse_raw</code><span class="sig-paren">(</span>const __be32<em>&nbsp;*addr</em>, struct of_phandle_args<em>&nbsp;*out_irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_irq_parse_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>Low level interrupt tree parsing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">__be32</span> <span class="pre">*addr</span></code></dt>
<dd>address specifier (start of “reg” property of the device) in be32 format</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_phandle_args</span> <span class="pre">*out_irq</span></code></dt>
<dd>structure of_phandle_args updated by this function</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a low-level interrupt tree walking function. It
can be used to do a partial walk with synthetized reg and interrupts
properties, for example when resolving PCI interrupts when no device
node exist for the parent. It takes an interrupt specifier structure as
input, walks the tree looking for any interrupt-map properties, translates
the specifier for each map, and then returns the translated map.</p>
<p><strong>Return</strong></p>
<p>0 on success and a negative number on error</p>
<dl class="function">
<dt id="c.of_irq_parse_one">
int <code class="descname">of_irq_parse_one</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*device</em>, int<em>&nbsp;index</em>, struct of_phandle_args<em>&nbsp;*out_irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_irq_parse_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve an interrupt for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*device</span></code></dt>
<dd>the device whose interrupt is to be resolved</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of the interrupt to resolve</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_phandle_args</span> <span class="pre">*out_irq</span></code></dt>
<dd>structure of_phandle_args filled by this function</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function resolves an interrupt for a node by walking the interrupt tree,
finding which interrupt controller node it is attached to, and returning the
interrupt specifier that can be used to retrieve a Linux IRQ number.</p>
<dl class="function">
<dt id="c.of_irq_to_resource">
int <code class="descname">of_irq_to_resource</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*dev</em>, int<em>&nbsp;index</em>, struct resource<em>&nbsp;*r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_irq_to_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a node’s IRQ and return it as a resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*dev</span></code></dt>
<dd>pointer to device tree node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>zero-based index of the irq</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*r</span></code></dt>
<dd>pointer to resource structure to return result into.</dd>
</dl>
<dl class="function">
<dt id="c.of_irq_get">
int <code class="descname">of_irq_get</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*dev</em>, int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_irq_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a node’s IRQ and return it as a Linux IRQ number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*dev</span></code></dt>
<dd>pointer to device tree node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>zero-based index of the IRQ</dd>
</dl>
<p><strong>Return</strong></p>
<p>Linux IRQ number on success, or 0 on the IRQ mapping failure, or
-EPROBE_DEFER if the IRQ domain is not yet created, or error code in case
of any other failure.</p>
<dl class="function">
<dt id="c.of_irq_get_byname">
int <code class="descname">of_irq_get_byname</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*dev</em>, const char<em>&nbsp;*name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_irq_get_byname" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a node’s IRQ and return it as a Linux IRQ number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*dev</span></code></dt>
<dd>pointer to device tree node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt>
<dd>IRQ name</dd>
</dl>
<p><strong>Return</strong></p>
<p>Linux IRQ number on success, or 0 on the IRQ mapping failure, or
-EPROBE_DEFER if the IRQ domain is not yet created, or error code in case
of any other failure.</p>
<dl class="function">
<dt id="c.of_irq_to_resource_table">
int <code class="descname">of_irq_to_resource_table</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*dev</em>, struct resource<em>&nbsp;*res</em>, int<em>&nbsp;nr_irqs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_irq_to_resource_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill in resource table with node’s IRQ info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*dev</span></code></dt>
<dd>pointer to device tree node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt>
<dd>array of resources to fill in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_irqs</span></code></dt>
<dd>the number of IRQs (and upper bound for num of <strong>res</strong> elements)</dd>
</dl>
<p><strong>Return</strong></p>
<p>The size of the filled in table (up to <strong>nr_irqs</strong>).</p>
<dl class="function">
<dt id="c.of_msi_configure">
void <code class="descname">of_msi_configure</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em>, struct device_node<em>&nbsp;*np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_msi_configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the msi_domain field of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt>
<dd>device structure to associate with an MSI irq domain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node for that device</dd>
</dl>
<dl class="function">
<dt id="c.of_fdt_unflatten_tree">
void * <code class="descname">of_fdt_unflatten_tree</code><span class="sig-paren">(</span>const unsigned long<em>&nbsp;*blob</em>, struct device_node<em>&nbsp;*dad</em>, struct device_node<em>&nbsp;**mynodes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_fdt_unflatten_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>create tree of device_nodes from flat blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*blob</span></code></dt>
<dd>Flat device tree blob</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*dad</span></code></dt>
<dd>Parent device node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">**mynodes</span></code></dt>
<dd>The device tree created by the call</dd>
</dl>
<p><strong>Description</strong></p>
<p>unflattens the device-tree passed by the firmware, creating the
tree of struct device_node. It also fills the “name” and “type”
pointers of the nodes so the normal device-tree walking functions
can be used.</p>
<p><strong>Return</strong></p>
<p>NULL on failure or the memory chunk containing the unflattened
device tree on success.</p>
</div>
<div class="section" id="driver-model-functions">
<h2>Driver model functions<a class="headerlink" href="#driver-model-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.of_driver_match_device">
int <code class="descname">of_driver_match_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em>, const struct device_driver<em>&nbsp;*drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_driver_match_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell if a driver’s of_match_table matches a device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt>
<dd>the device structure to match against</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt>
<dd>the device_driver structure to test</dd>
</dl>
<dl class="function">
<dt id="c.of_match_device">
const struct of_device_id * <code class="descname">of_match_device</code><span class="sig-paren">(</span>const struct of_device_id<em>&nbsp;*matches</em>, const struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_match_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell if a <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> matches an of_device_id list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">of_device_id</span> <span class="pre">*matches</span></code></dt>
<dd>array of of device match structures to search in</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt>
<dd>the of device structure to match against</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by a driver to check whether an platform_device present in the
system is in its list of supported devices.</p>
<dl class="function">
<dt id="c.of_dma_configure_id">
int <code class="descname">of_dma_configure_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em>, struct device_node<em>&nbsp;*np</em>, bool<em>&nbsp;force_dma</em>, const u32<em>&nbsp;*id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_dma_configure_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup DMA configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt>
<dd>Device to apply DMA configuration</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>Pointer to OF node having DMA configuration</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force_dma</span></code></dt>
<dd>Whether device is to be set up by of_dma_configure() even if
DMA capability is not explicitly described by firmware.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*id</span></code></dt>
<dd>Optional const pointer value input id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to get devices’s DMA configuration from DT and update it
accordingly.</p>
<p>If platform code needs to use its own special DMA configuration, it
can use a platform bus notifier and handle BUS_NOTIFY_ADD_DEVICE events
to fix up DMA configuration.</p>
<dl class="function">
<dt id="c.of_device_modalias">
ssize_t <code class="descname">of_device_modalias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em>, char<em>&nbsp;*str</em>, ssize_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_device_modalias" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill buffer with newline terminated modalias string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt>
<dd>Calling device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*str</span></code></dt>
<dd>Modalias string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">len</span></code></dt>
<dd>Size of <strong>str</strong></dd>
</dl>
<dl class="type">
<dt id="c.of_dev_auxdata">
struct <code class="descname">of_dev_auxdata</code><a class="headerlink" href="#c.of_dev_auxdata" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup table entry for device names &amp; platform_data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct of_dev_auxdata {
  char *compatible;
  resource_size_t phys_addr;
  char *name;
  void *platform_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">compatible</span></code></dt>
<dd>compatible value of node to match against node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr</span></code></dt>
<dd>Start address of registers to match against node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>Name to assign for matching nodes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">platform_data</span></code></dt>
<dd>platform_data to assign for matching nodes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This lookup table allows the caller of <a class="reference internal" href="#c.of_platform_populate" title="of_platform_populate"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_platform_populate()</span></code></a> to override
the names of devices when creating devices from the device tree.  The table
should be terminated with an empty entry.  It also allows the platform_data
pointer to be set.</p>
<p>The reason for this functionality is that some Linux infrastructure uses
the device name to look up a specific device, but the Linux-specific names
are not encoded into the device tree, so the kernel needs to provide specific
values.</p>
<p><strong>Note</strong></p>
<p>Using an auxdata lookup table should be considered a last resort when
converting a platform to use the DT.  Normally the automatically generated
device name will not matter, and drivers should obtain data from the device
node instead of from an anonymous platform_data pointer.</p>
<dl class="function">
<dt id="c.of_find_device_by_node">
struct platform_device * <code class="descname">of_find_device_by_node</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_device_by_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the platform_device associated with a node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>Pointer to device tree node</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes a reference to the embedded <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> which needs to be dropped
after use.</p>
<p><strong>Return</strong></p>
<p>platform_device pointer, or NULL if not found</p>
<dl class="function">
<dt id="c.of_device_alloc">
struct platform_device * <code class="descname">of_device_alloc</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*bus_id</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_device_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and initialize an of_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>device node to assign to device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*bus_id</span></code></dt>
<dd>Name to assign to the device.  May be null to use default name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt>
<dd>Parent device.</dd>
</dl>
<dl class="function">
<dt id="c.of_platform_device_create">
struct platform_device * <code class="descname">of_platform_device_create</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*np</em>, const char<em>&nbsp;*bus_id</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_platform_device_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Alloc, initialize and register an of_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>pointer to node to create device for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*bus_id</span></code></dt>
<dd>name to assign device</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt>
<dd>Linux device model parent device.</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to created platform device, or NULL if a device was not
registered.  Unavailable devices will not get registered.</p>
<dl class="function">
<dt id="c.of_platform_bus_probe">
int <code class="descname">of_platform_bus_probe</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*root</em>, const struct of_device_id<em>&nbsp;*matches</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_platform_bus_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Probe the device-tree for platform buses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*root</span></code></dt>
<dd>parent of the first level to probe or NULL for the root of the tree</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">of_device_id</span> <span class="pre">*matches</span></code></dt>
<dd>match table for bus nodes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt>
<dd>parent to hook devices from, NULL for toplevel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that children of the provided root are not instantiated as devices
unless the specified root itself matches the bus list and is not NULL.</p>
<dl class="function">
<dt id="c.of_platform_populate">
int <code class="descname">of_platform_populate</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*root</em>, const struct of_device_id<em>&nbsp;*matches</em>, const struct <a class="reference internal" href="#c.of_dev_auxdata" title="of_dev_auxdata">of_dev_auxdata</a><em>&nbsp;*lookup</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_platform_populate" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate platform_devices from device tree data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*root</span></code></dt>
<dd>parent of the first level to probe or NULL for the root of the tree</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">of_device_id</span> <span class="pre">*matches</span></code></dt>
<dd>match table, NULL to use the default</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">of_dev_auxdata</span> <span class="pre">*lookup</span></code></dt>
<dd>auxdata table for matching id and platform_data with device nodes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt>
<dd>parent to hook devices from, NULL for toplevel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.of_platform_bus_probe" title="of_platform_bus_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_platform_bus_probe()</span></code></a>, this function walks the device tree
and creates devices from nodes.  It differs in that it follows the modern
convention of requiring all device nodes to have a ‘compatible’ property,
and it is suitable for creating devices which are children of the root
node (of_platform_bus_probe will only create children of the root which
are selected by the <strong>matches</strong> argument).</p>
<p>New board support should be using this function instead of
<a class="reference internal" href="#c.of_platform_bus_probe" title="of_platform_bus_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_platform_bus_probe()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, &lt; 0 on failure.</p>
<dl class="function">
<dt id="c.of_platform_depopulate">
void <code class="descname">of_platform_depopulate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_platform_depopulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove devices populated from device tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt>
<dd>device which children will be removed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Complementary to <a class="reference internal" href="#c.of_platform_populate" title="of_platform_populate"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_platform_populate()</span></code></a>, this function removes children
of the given device (and, recurrently, their children) that have been
created from their respective device tree nodes (and only those,
leaving others - eg. manually created - unharmed).</p>
<dl class="function">
<dt id="c.devm_of_platform_populate">
int <code class="descname">devm_of_platform_populate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_of_platform_populate" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate platform_devices from device tree data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt>
<dd>device that requested to populate from device tree data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.of_platform_populate" title="of_platform_populate"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_platform_populate()</span></code></a>, but will automatically call
<a class="reference internal" href="#c.of_platform_depopulate" title="of_platform_depopulate"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_platform_depopulate()</span></code></a> when the device is unbound from the bus.</p>
<p><strong>Return</strong></p>
<p>0 on success, &lt; 0 on failure.</p>
<dl class="function">
<dt id="c.devm_of_platform_depopulate">
void <code class="descname">devm_of_platform_depopulate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_of_platform_depopulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove devices populated from device tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt>
<dd>device that requested to depopulate from device tree data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Complementary to <a class="reference internal" href="#c.devm_of_platform_populate" title="devm_of_platform_populate"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_of_platform_populate()</span></code></a>, this function removes children
of the given device (and, recurrently, their children) that have been
created from their respective device tree nodes (and only those,
leaving others - eg. manually created - unharmed).</p>
</div>
<div class="section" id="overlay-and-dynamic-dt-functions">
<h2>Overlay and Dynamic DT functions<a class="headerlink" href="#overlay-and-dynamic-dt-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.of_resolve_phandles">
int <code class="descname">of_resolve_phandles</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*overlay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_resolve_phandles" title="Permalink to this definition">¶</a></dt>
<dd><p>Relocate and resolve overlay against live tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*overlay</span></code></dt>
<dd>Pointer to devicetree overlay to relocate and resolve</dd>
</dl>
<p><strong>Description</strong></p>
<p>Modify (relocate) values of local phandles in <strong>overlay</strong> to a range that
does not conflict with the live expanded devicetree.  Update references
to the local phandles in <strong>overlay</strong>.  Update (resolve) phandle references
in <strong>overlay</strong> that refer to the live expanded devicetree.</p>
<p>Phandle values in the live tree are in the range of
1 .. live_tree_max_phandle().  The range of phandle values in the overlay
also begin with at 1.  Adjust the phandle values in the overlay to begin
at live_tree_max_phandle() + 1.  Update references to the phandles to
the adjusted phandle values.</p>
<p>The name of each property in the “__fixups__” node in the overlay matches
the name of a symbol (a label) in the live tree.  The values of each
property in the “__fixups__” node is a list of the property values in the
overlay that need to be updated to contain the phandle reference
corresponding to that symbol in the live tree.  Update the references in
the overlay with the phandle values in the live tree.</p>
<p><strong>overlay</strong> must be detached.</p>
<p>Resolving and applying <strong>overlay</strong> to the live expanded devicetree must be
protected by a mechanism to ensure that multiple overlays are processed
in a single threaded manner so that multiple overlays will not relocate
phandles to overlapping ranges.  The mechanism to enforce this is not
yet implemented.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success or a negative error value on error.</p>
<dl class="function">
<dt id="c.of_node_get">
struct device_node * <code class="descname">of_node_get</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_node_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment refcount of a node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>Node to inc refcount, NULL is supported to simplify writing of
callers</dd>
</dl>
<p><strong>Return</strong></p>
<p>The node with refcount incremented.</p>
<dl class="function">
<dt id="c.of_node_put">
void <code class="descname">of_node_put</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_node_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement refcount of a node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt>
<dd>Node to dec refcount, NULL is supported to simplify writing of
callers</dd>
</dl>
<dl class="function">
<dt id="c.of_detach_node">
int <code class="descname">of_detach_node</code><span class="sig-paren">(</span>struct device_node<em>&nbsp;*np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_detach_node" title="Permalink to this definition">¶</a></dt>
<dd><p>“Unplug” a node from the device tree.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>Pointer to the caller’s Device Node</dd>
</dl>
<dl class="function">
<dt id="c.of_changeset_init">
void <code class="descname">of_changeset_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.of_changeset" title="of_changeset">of_changeset</a><em>&nbsp;*ocs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_changeset_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a changeset for use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_changeset</span> <span class="pre">*ocs</span></code></dt>
<dd>changeset pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a changeset structure</p>
<dl class="function">
<dt id="c.of_changeset_destroy">
void <code class="descname">of_changeset_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.of_changeset" title="of_changeset">of_changeset</a><em>&nbsp;*ocs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_changeset_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy a changeset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_changeset</span> <span class="pre">*ocs</span></code></dt>
<dd>changeset pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroys a changeset. Note that if a changeset is applied,
its changes to the tree cannot be reverted.</p>
<dl class="function">
<dt id="c.of_changeset_apply">
int <code class="descname">of_changeset_apply</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.of_changeset" title="of_changeset">of_changeset</a><em>&nbsp;*ocs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_changeset_apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a changeset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_changeset</span> <span class="pre">*ocs</span></code></dt>
<dd>changeset pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Applies a changeset to the live tree.
Any side-effects of live tree state changes are applied here on
success, like creation/destruction of devices and side-effects
like creation of sysfs properties and directories.</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative error value in case of an error.
On error the partially applied effects are reverted.</p>
<dl class="function">
<dt id="c.of_changeset_revert">
int <code class="descname">of_changeset_revert</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.of_changeset" title="of_changeset">of_changeset</a><em>&nbsp;*ocs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_changeset_revert" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverts an applied changeset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_changeset</span> <span class="pre">*ocs</span></code></dt>
<dd>changeset pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reverts a changeset returning the state of the tree to what it
was before the application.
Any side-effects like creation/destruction of devices and
removal of sysfs properties and directories are applied.</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative error value in case of an error.</p>
<dl class="function">
<dt id="c.of_changeset_action">
int <code class="descname">of_changeset_action</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.of_changeset" title="of_changeset">of_changeset</a><em>&nbsp;*ocs</em>, unsigned long<em>&nbsp;action</em>, struct device_node<em>&nbsp;*np</em>, struct property<em>&nbsp;*prop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_changeset_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an action to the tail of the changeset list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_changeset</span> <span class="pre">*ocs</span></code></dt>
<dd>changeset pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">action</span></code></dt>
<dd>action to perform</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt>
<dd>Pointer to device node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">property</span> <span class="pre">*prop</span></code></dt>
<dd>Pointer to property</dd>
</dl>
<p><strong>Description</strong></p>
<p>On action being one of:
+ OF_RECONFIG_ATTACH_NODE
+ OF_RECONFIG_DETACH_NODE,
+ OF_RECONFIG_ADD_PROPERTY
+ OF_RECONFIG_REMOVE_PROPERTY,
+ OF_RECONFIG_UPDATE_PROPERTY</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative error value in case of an error.</p>
<dl class="function">
<dt id="c.of_overlay_notifier_register">
int <code class="descname">of_overlay_notifier_register</code><span class="sig-paren">(</span>struct notifier_block<em>&nbsp;*nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_overlay_notifier_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register notifier for overlay operations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt>
<dd>Notifier block to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register for notification on overlay operations on device tree nodes. The
reported actions definied by <strong>of_reconfig_change</strong>. The notifier callback
furthermore receives a pointer to the affected device tree node.</p>
<p>Note that a notifier callback is not supposed to store pointers to a device
tree node or its content beyond <strong>OF_OVERLAY_POST_REMOVE</strong> corresponding to the
respective node it received.</p>
<dl class="function">
<dt id="c.of_overlay_notifier_unregister">
int <code class="descname">of_overlay_notifier_unregister</code><span class="sig-paren">(</span>struct notifier_block<em>&nbsp;*nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_overlay_notifier_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister notifier for overlay operations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt>
<dd>Notifier block to unregister</dd>
</dl>
<dl class="function">
<dt id="c.of_overlay_remove">
int <code class="descname">of_overlay_remove</code><span class="sig-paren">(</span>int<em>&nbsp;*ovcs_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_overlay_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Revert and free an overlay changeset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*ovcs_id</span></code></dt>
<dd>Pointer to overlay changeset id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes an overlay if it is permissible.  <strong>ovcs_id</strong> was previously returned
by of_overlay_fdt_apply().</p>
<p>If an error occurred while attempting to revert the overlay changeset,
then an attempt is made to re-apply any changeset entry that was
reverted.  If an error occurs on re-apply then the state of the device
tree can not be determined, and any following attempt to apply or remove
an overlay changeset will be refused.</p>
<dl class="docutils">
<dt>A non-zero return value will not revert the changeset if error is from:</dt>
<dd><ul class="first last simple">
<li>parameter checks</li>
<li>overlay changeset pre-remove notifier</li>
<li>overlay changeset entry revert</li>
</ul>
</dd>
</dl>
<p>If an error is returned by an overlay changeset pre-remove notifier
then no further overlay changeset pre-remove notifier will be called.</p>
<p>If more than one notifier returns an error, then the last notifier
error to occur is returned.</p>
<dl class="docutils">
<dt>A non-zero return value will revert the changeset if error is from:</dt>
<dd><ul class="first last simple">
<li>overlay changeset entry notifier</li>
<li>overlay changeset post-remove notifier</li>
</ul>
</dd>
</dl>
<p>If an error is returned by an overlay changeset post-remove notifier
then no further overlay changeset post-remove notifier will be called.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative error number.  <strong>*ovcs_id</strong> is set to
zero after reverting the changeset, even if a subsequent error occurs.</p>
<dl class="function">
<dt id="c.of_overlay_remove_all">
int <code class="descname">of_overlay_remove_all</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.of_overlay_remove_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverts and frees all overlay changesets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes all overlays from the system in the correct order.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative error number</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="changesets.html" class="btn btn-neutral float-right" title="Devicetree Changesets" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="of_unittest.html" class="btn btn-neutral" title="Open Firmware Devicetree Unittest" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>