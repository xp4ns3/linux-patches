

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux Kernel TIPC &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Linux Networking Documentation" href="index.html"/>
        <link rel="next" title="Transparent proxy support" href="tproxy.html"/>
        <link rel="prev" title="Timestamping" href="timestamping.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Networking Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="af_xdp.html">AF_XDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="bareudp.html">Bare UDP Tunnelling Module Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="batman-adv.html">batman-adv</a></li>
<li class="toctree-l2"><a class="reference internal" href="can.html">SocketCAN - Controller Area Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="can_ucan_protocol.html">The UCAN Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_drivers/index.html">Hardware Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dsa/index.html">Distributed Switch Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="devlink/index.html">Linux Devlink Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="caif/index.html">CAIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="ethtool-netlink.html">Netlink interface for ethtool</a></li>
<li class="toctree-l2"><a class="reference internal" href="ieee802154.html">IEEE 802.15.4 Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="j1939.html">J1939 Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="kapi.html">Linux Networking and Network Devices APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="msg_zerocopy.html">MSG_ZEROCOPY</a></li>
<li class="toctree-l2"><a class="reference internal" href="failover.html">FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="net_dim.html">Net DIM - Generic Network Dynamic Interrupt Moderation</a></li>
<li class="toctree-l2"><a class="reference internal" href="net_failover.html">NET_FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_pool.html">Page Pool API</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy.html">PHY Abstraction Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfp-phylink.html">phylink</a></li>
<li class="toctree-l2"><a class="reference internal" href="alias.html">IP-Aliasing</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge.html">Ethernet Bridging</a></li>
<li class="toctree-l2"><a class="reference internal" href="snmp_counter.html">SNMP counter</a></li>
<li class="toctree-l2"><a class="reference internal" href="checksum-offloads.html">Checksum Offloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="segmentation-offloads.html">Segmentation Offloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="scaling.html">Scaling in the Linux Networking Stack</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls.html">Kernel TLS</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls-offload.html">Kernel TLS offload</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc.html">Linux NFC subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="6lowpan.html">Netdev private dataroom for 6lowpan interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="6pack.html">6pack Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="arcnet-hardware.html">ARCnet Hardware</a></li>
<li class="toctree-l2"><a class="reference internal" href="arcnet.html">ARCnet</a></li>
<li class="toctree-l2"><a class="reference internal" href="atm.html">ATM</a></li>
<li class="toctree-l2"><a class="reference internal" href="ax25.html">AX.25</a></li>
<li class="toctree-l2"><a class="reference internal" href="bonding.html">Linux Ethernet Bonding Driver HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="cdc_mbim.html">cdc_mbim - Driver for CDC MBIM Mobile Broadband modems</a></li>
<li class="toctree-l2"><a class="reference internal" href="dccp.html">DCCP protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="dctcp.html">DCTCP (DataCenter TCP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="decnet.html">Linux DECnet Networking Layer Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="dns_resolver.html">DNS Resolver Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html">Softnet Driver Issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="eql.html">EQL Driver: Serial IP Load Balancing HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="fib_trie.html">LC-trie implementation notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="filter.html">Linux Socket Filtering aka Berkeley Packet Filter (BPF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-hdlc.html">Generic HDLC layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_netlink.html">Generic Netlink</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_stats.html">Generic networking statistics for netlink users</a></li>
<li class="toctree-l2"><a class="reference internal" href="gtp.html">The Linux kernel GTP tunneling module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ila.html">Identifier Locator Addressing (ILA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioam6-sysctl.html">IOAM6 Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipddp.html">AppleTalk-IP Decapsulation and AppleTalk-IP Encapsulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_dynaddr.html">IP dynamic address hack-port v0.03</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipsec.html">IPsec</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip-sysctl.html">IP Sysctl</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipv6.html">IPv6</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipvlan.html">IPVLAN Driver HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipvs-sysctl.html">IPvs-sysctl</a></li>
<li class="toctree-l2"><a class="reference internal" href="kcm.html">Kernel Connection Multiplexor</a></li>
<li class="toctree-l2"><a class="reference internal" href="l2tp.html">L2TP</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapb-module.html">The Linux LAPB Module Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="mac80211-injection.html">How to use packet injection with mac80211</a></li>
<li class="toctree-l2"><a class="reference internal" href="mctp.html">Management Component Transport Protocol (MCTP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpls-sysctl.html">MPLS Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="mptcp-sysctl.html">MPTCP Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="multiqueue.html">HOWTO for multiqueue network device support</a></li>
<li class="toctree-l2"><a class="reference internal" href="netconsole.html">Netconsole</a></li>
<li class="toctree-l2"><a class="reference internal" href="netdev-features.html">Netdev features mess and how to get out from it alive</a></li>
<li class="toctree-l2"><a class="reference internal" href="netdevices.html">Network Devices, the Kernel, and You!</a></li>
<li class="toctree-l2"><a class="reference internal" href="netfilter-sysctl.html">Netfilter Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="netif-msg.html">NETIF Msg Level</a></li>
<li class="toctree-l2"><a class="reference internal" href="nexthop-group-resilient.html">Resilient Next-hop Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="nf_conntrack-sysctl.html">Netfilter Conntrack Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="nf_flowtable.html">Netfilter’s flowtable infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="openvswitch.html">Open vSwitch datapath developer documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="operstates.html">Operational States</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_mmap.html">Packet MMAP</a></li>
<li class="toctree-l2"><a class="reference internal" href="phonet.html">Linux Phonet protocol family</a></li>
<li class="toctree-l2"><a class="reference internal" href="pktgen.html">HOWTO for the linux packet generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="plip.html">PLIP: The Parallel Line Internet Protocol Device</a></li>
<li class="toctree-l2"><a class="reference internal" href="ppp_generic.html">PPP Generic Driver and Channel Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="proc_net_tcp.html">The proc/net/tcp and proc/net/tcp6 variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="radiotap-headers.html">How to use radiotap headers</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html">RDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulatory.html">Linux wireless regulatory documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html">RxRPC Network Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html#socket-options">SOCKET OPTIONS</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html#security">SECURITY</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html#example-client-usage">EXAMPLE CLIENT USAGE</a></li>
<li class="toctree-l2"><a class="reference internal" href="sctp.html">Linux Kernel SCTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="secid.html">LSM/SeLinux secid</a></li>
<li class="toctree-l2"><a class="reference internal" href="seg6-sysctl.html">Seg6 Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc-sysctl.html">SMC Sysctl</a></li>
<li class="toctree-l2"><a class="reference internal" href="statistics.html">Interface statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="strparser.html">Stream Parser (strparser)</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchdev.html">Ethernet switch device driver model (switchdev)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sysfs-tagging.html">Sysfs tagging</a></li>
<li class="toctree-l2"><a class="reference internal" href="tc-actions-env-rules.html">TC Actions - Environmental Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="tcp-thin.html">Thin-streams and TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="team.html">Team</a></li>
<li class="toctree-l2"><a class="reference internal" href="timestamping.html">Timestamping</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Linux Kernel TIPC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tipc-features">TIPC Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#more-information">More Information</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tipc-base-types">TIPC Base Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-bearer-interfaces">TIPC Bearer Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-crypto-interfaces">TIPC Crypto Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-discoverer-interfaces">TIPC Discoverer Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-link-interfaces">TIPC Link Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-msg-interfaces">TIPC msg Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-name-interfaces">TIPC Name Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-node-management-interfaces">TIPC Node Management Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-socket-interfaces">TIPC Socket Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-network-topology-interfaces">TIPC Network Topology Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-server-interfaces">TIPC Server Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tipc-trace-interfaces">TIPC Trace Interfaces</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tproxy.html">Transparent proxy support</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuntap.html">Universal TUN/TAP device driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="udplite.html">The UDP-Lite protocol (RFC 3828)</a></li>
<li class="toctree-l2"><a class="reference internal" href="vrf.html">Virtual Routing and Forwarding (VRF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="vxlan.html">Virtual eXtensible Local Area Networking documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25-iface.html">Packet Layer to Device Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25-iface.html#device-driver-to-packet-layer">Device Driver to Packet Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25-iface.html#requirements-for-the-device-driver">Requirements for the device driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25.html">Linux X.25 Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_device.html">XFRM device - offloading the IPsec computations</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_proc.html">XFRM proc - /proc/net/xfrm_* files</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_sync.html">XFRM</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_sysctl.html">XFRM Syscall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Networking Documentation</a> &raquo;</li>
        
      <li>Linux Kernel TIPC</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/networking/tipc.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-kernel-tipc">
<h1>Linux Kernel TIPC<a class="headerlink" href="#linux-kernel-tipc" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>TIPC (Transparent Inter Process Communication) is a protocol that is specially
designed for intra-cluster communication. It can be configured to transmit
messages either on UDP or directly across Ethernet. Message delivery is
sequence guaranteed, loss free and flow controlled. Latency times are shorter
than with any other known protocol, while maximal throughput is comparable to
that of TCP.</p>
<div class="section" id="tipc-features">
<h3>TIPC Features<a class="headerlink" href="#tipc-features" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Cluster wide IPC service</p>
<p>Have you ever wished you had the convenience of Unix Domain Sockets even when
transmitting data between cluster nodes? Where you yourself determine the
addresses you want to bind to and use? Where you don’t have to perform DNS
lookups and worry about IP addresses? Where you don’t have to start timers
to monitor the continuous existence of peer sockets? And yet without the
downsides of that socket type, such as the risk of lingering inodes?</p>
<p>Welcome to the Transparent Inter Process Communication service, TIPC in short,
which gives you all of this, and a lot more.</p>
</li>
<li><p class="first">Service Addressing</p>
<p>A fundamental concept in TIPC is that of Service Addressing which makes it
possible for a programmer to chose his own address, bind it to a server
socket and let client programs use only that address for sending messages.</p>
</li>
<li><p class="first">Service Tracking</p>
<p>A client wanting to wait for the availability of a server, uses the Service
Tracking mechanism to subscribe for binding and unbinding/close events for
sockets with the associated service address.</p>
<p>The service tracking mechanism can also be used for Cluster Topology Tracking,
i.e., subscribing for availability/non-availability of cluster nodes.</p>
<p>Likewise, the service tracking mechanism can be used for Cluster Connectivity
Tracking, i.e., subscribing for up/down events for individual links between
cluster nodes.</p>
</li>
<li><p class="first">Transmission Modes</p>
<p>Using a service address, a client can send datagram messages to a server socket.</p>
<p>Using the same address type, it can establish a connection towards an accepting
server socket.</p>
<p>It can also use a service address to create and join a Communication Group,
which is the TIPC manifestation of a brokerless message bus.</p>
<p>Multicast with very good performance and scalability is available both in
datagram mode and in communication group mode.</p>
</li>
<li><p class="first">Inter Node Links</p>
<p>Communication between any two nodes in a cluster is maintained by one or two
Inter Node Links, which both guarantee data traffic integrity and monitor
the peer node’s availability.</p>
</li>
<li><p class="first">Cluster Scalability</p>
<p>By applying the Overlapping Ring Monitoring algorithm on the inter node links
it is possible to scale TIPC clusters up to 1000 nodes with a maintained
neighbor failure discovery time of 1-2 seconds. For smaller clusters this
time can be made much shorter.</p>
</li>
<li><p class="first">Neighbor Discovery</p>
<p>Neighbor Node Discovery in the cluster is done by Ethernet broadcast or UDP
multicast, when any of those services are available. If not, configured peer
IP addresses can be used.</p>
</li>
<li><p class="first">Configuration</p>
<p>When running TIPC in single node mode no configuration whatsoever is needed.
When running in cluster mode TIPC must as a minimum be given a node address
(before Linux 4.17) and told which interface to attach to. The “tipc”
configuration tool makes is possible to add and maintain many more
configuration parameters.</p>
</li>
<li><p class="first">Performance</p>
<p>TIPC message transfer latency times are better than in any other known protocol.
Maximal byte throughput for inter-node connections is still somewhat lower than
for TCP, while they are superior for intra-node and inter-container throughput
on the same host.</p>
</li>
<li><p class="first">Language Support</p>
<p>The TIPC user API has support for C, Python, Perl, Ruby, D and Go.</p>
</li>
</ul>
</div>
<div class="section" id="more-information">
<h3>More Information<a class="headerlink" href="#more-information" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">How to set up TIPC:</p>
<p><a class="reference external" href="http://tipc.io/getting_started.html">http://tipc.io/getting_started.html</a></p>
</li>
<li><p class="first">How to program with TIPC:</p>
<p><a class="reference external" href="http://tipc.io/programming.html">http://tipc.io/programming.html</a></p>
</li>
<li><p class="first">How to contribute to TIPC:</p>
</li>
<li><p class="first"><a class="reference external" href="http://tipc.io/contacts.html">http://tipc.io/contacts.html</a></p>
</li>
<li><p class="first">More details about TIPC specification:</p>
<p><a class="reference external" href="http://tipc.io/protocol.html">http://tipc.io/protocol.html</a></p>
</li>
</ul>
</div>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>TIPC is implemented as a kernel module in net/tipc/ directory.</p>
<div class="section" id="tipc-base-types">
<h3>TIPC Base Types<a class="headerlink" href="#tipc-base-types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.tipc_subscription">
struct <code class="descname">tipc_subscription</code><a class="headerlink" href="#c.tipc_subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>TIPC network topology subscription object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_subscription {
  struct tipc_subscr s;
  struct tipc_event evt;
  struct kref kref;
  struct net *net;
  struct timer_list timer;
  struct list_head service_list;
  struct list_head sub_list;
  int conid;
  bool inactive;
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code></dt>
<dd>host-endian copy of the user subscription</dd>
<dt><code class="docutils literal notranslate"><span class="pre">evt</span></code></dt>
<dd>template for events generated by subscription</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt>
<dd>reference count for this subscription</dd>
<dt><code class="docutils literal notranslate"><span class="pre">net</span></code></dt>
<dd>network namespace associated with subscription</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer</span></code></dt>
<dd>timer governing subscription duration (optional)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">service_list</span></code></dt>
<dd>adjacent subscriptions in name sequence’s subscription list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sub_list</span></code></dt>
<dd>adjacent subscriptions in subscriber’s subscription list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conid</span></code></dt>
<dd>connection identifier of topology server</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inactive</span></code></dt>
<dd>true if this subscription is inactive</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt>
<dd>serialize up/down and timer events</dd>
</dl>
<dl class="type">
<dt id="c.tipc_media_addr">
struct <code class="descname">tipc_media_addr</code><a class="headerlink" href="#c.tipc_media_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>destination address used by TIPC bearers</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_media_addr {
  u8 value[TIPC_MEDIA_INFO_SIZE];
  u8 media_id;
  u8 broadcast;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt>
<dd>address info (format defined by media)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">media_id</span></code></dt>
<dd>TIPC media type identifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">broadcast</span></code></dt>
<dd>non-zero if address is a broadcast address</dd>
</dl>
<dl class="type">
<dt id="c.tipc_media">
struct <code class="descname">tipc_media</code><a class="headerlink" href="#c.tipc_media" title="Permalink to this definition">¶</a></dt>
<dd><p>Media specific info exposed to generic bearer layer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_media {
  int (*send_msg)(struct net *net, struct sk_buff *buf,struct tipc_bearer *b, struct tipc_media_addr *dest);
  int (*enable_media)(struct net *net, struct tipc_bearer *b, struct nlattr *attr[]);
  void (*disable_media)(struct tipc_bearer *b);
  int (*addr2str)(struct tipc_media_addr *addr,char *strbuf, int bufsz);
  int (*addr2msg)(char *msg, struct tipc_media_addr *addr);
  int (*msg2addr)(struct tipc_bearer *b,struct tipc_media_addr *addr, char *msg);
  int (*raw2addr)(struct tipc_bearer *b,struct tipc_media_addr *addr, const char *raw);
  u32 priority;
  u32 tolerance;
  u32 min_win;
  u32 max_win;
  u32 mtu;
  u32 type_id;
  u32 hwaddr_len;
  char name[TIPC_MAX_MEDIA_NAME];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">send_msg</span></code></dt>
<dd>routine which handles buffer transmission</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_media</span></code></dt>
<dd>routine which enables a media</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_media</span></code></dt>
<dd>routine which disables a media</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr2str</span></code></dt>
<dd>convert media address format to string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr2msg</span></code></dt>
<dd>convert from media addr format to discovery msg addr format</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg2addr</span></code></dt>
<dd>convert from discovery msg addr format to media addr format</dd>
<dt><code class="docutils literal notranslate"><span class="pre">raw2addr</span></code></dt>
<dd>convert from raw addr format to media addr format</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priority</span></code></dt>
<dd>default link (and bearer) priority</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tolerance</span></code></dt>
<dd>default time (in ms) before declaring link failure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_win</span></code></dt>
<dd>minimum window (in packets) before declaring link congestion</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_win</span></code></dt>
<dd>maximum window (in packets) before declaring link congestion</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mtu</span></code></dt>
<dd>max packet size bearer can support for media type not dependent on
underlying device MTU</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type_id</span></code></dt>
<dd>TIPC media identifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwaddr_len</span></code></dt>
<dd>TIPC media address len</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>media name</dd>
</dl>
<dl class="type">
<dt id="c.tipc_bearer">
struct <code class="descname">tipc_bearer</code><a class="headerlink" href="#c.tipc_bearer" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic TIPC bearer structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_bearer {
  void __rcu *media_ptr;
  u32 mtu;
  struct tipc_media_addr addr;
  char name[TIPC_MAX_BEARER_NAME];
  struct tipc_media *media;
  struct tipc_media_addr bcast_addr;
  struct packet_type pt;
  struct rcu_head rcu;
  u32 priority;
  u32 min_win;
  u32 max_win;
  u32 tolerance;
  u32 domain;
  u32 identity;
  struct tipc_discoverer *disc;
  char net_plane;
  unsigned long up;
  refcount_t refcnt;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">media_ptr</span></code></dt>
<dd>pointer to additional media-specific information about bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mtu</span></code></dt>
<dd>max packet size bearer can support</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt>
<dd>media-specific address associated with bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>bearer name (format = media:interface)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">media</span></code></dt>
<dd>ptr to media structure associated with bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bcast_addr</span></code></dt>
<dd>media address used in broadcasting</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt</span></code></dt>
<dd>packet type for bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt>
<dd>rcu struct for tipc_bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priority</span></code></dt>
<dd>default link priority for bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_win</span></code></dt>
<dd>minimum window (in packets) before declaring link congestion</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_win</span></code></dt>
<dd>maximum window (in packets) before declaring link congestion</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tolerance</span></code></dt>
<dd>default link tolerance for bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">domain</span></code></dt>
<dd>network domain to which links can be established</dd>
<dt><code class="docutils literal notranslate"><span class="pre">identity</span></code></dt>
<dd>array index of this bearer within TIPC bearer array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disc</span></code></dt>
<dd>ptr to link setup request</dd>
<dt><code class="docutils literal notranslate"><span class="pre">net_plane</span></code></dt>
<dd>network plane (‘A’ through ‘H’) currently associated with bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up</span></code></dt>
<dd>bearer up flag (bit 0)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcnt</span></code></dt>
<dd>tipc_bearer reference counter</dd>
</dl>
<p><strong>Note</strong></p>
<p>media-specific code is responsible for initialization of the fields
indicated below when a bearer is enabled; TIPC’s generic bearer code takes
care of initializing all other fields.</p>
<dl class="type">
<dt id="c.publication">
struct <code class="descname">publication</code><a class="headerlink" href="#c.publication" title="Permalink to this definition">¶</a></dt>
<dd><p>info about a published service address or range</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct publication {
  struct tipc_service_range sr;
  struct tipc_socket_addr sk;
  u16 scope;
  u32 key;
  u32 id;
  struct list_head binding_node;
  struct list_head binding_sock;
  struct list_head local_publ;
  struct list_head all_publ;
  struct list_head list;
  struct rcu_head rcu;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">sr</span></code></dt>
<dd>service range represented by this publication</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk</span></code></dt>
<dd>address of socket bound to this publication</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scope</span></code></dt>
<dd>scope of publication, TIPC_NODE_SCOPE or TIPC_CLUSTER_SCOPE</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt>
<dd>publication key, unique across the cluster</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt>
<dd>publication id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">binding_node</span></code></dt>
<dd>all publications from the same node which bound this one
- Remote publications: in node-&gt;publ_list;
Used by node/name distr to withdraw publications when node is lost
- Local/node scope publications: in name_table-&gt;node_scope list
- Local/cluster scope publications: in name_table-&gt;cluster_scope list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">binding_sock</span></code></dt>
<dd>all publications from the same socket which bound this one
Used by socket to withdraw publications when socket is unbound/released</dd>
<dt><code class="docutils literal notranslate"><span class="pre">local_publ</span></code></dt>
<dd>list of identical publications made from this node
Used by closest_first and multicast receive lookup algorithms</dd>
<dt><code class="docutils literal notranslate"><span class="pre">all_publ</span></code></dt>
<dd>all publications identical to this one, whatever node and scope
Used by round-robin lookup algorithm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>to form a list of publications in temporal order</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt>
<dd>RCU callback head used for deferred freeing</dd>
</dl>
<dl class="type">
<dt id="c.name_table">
struct <code class="descname">name_table</code><a class="headerlink" href="#c.name_table" title="Permalink to this definition">¶</a></dt>
<dd><p>table containing all existing port name publications</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct name_table {
  struct hlist_head services[TIPC_NAMETBL_SIZE];
  struct list_head node_scope;
  struct list_head cluster_scope;
  rwlock_t cluster_scope_lock;
  u32 local_publ_count;
  u32 rc_dests;
  u32 snd_nxt;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">services</span></code></dt>
<dd>name sequence hash lists</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node_scope</span></code></dt>
<dd>all local publications with node scope
- used by name_distr during re-init of name table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cluster_scope</span></code></dt>
<dd>all local publications with cluster scope
- used by name_distr to send bulk updates to new nodes
- used by name_distr during re-init of name table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cluster_scope_lock</span></code></dt>
<dd>lock for accessing <strong>cluster_scope</strong></dd>
<dt><code class="docutils literal notranslate"><span class="pre">local_publ_count</span></code></dt>
<dd>number of publications issued by this node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_dests</span></code></dt>
<dd>destination node counter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_nxt</span></code></dt>
<dd>next sequence number to be used</dd>
</dl>
<dl class="type">
<dt id="c.distr_item">
struct <code class="descname">distr_item</code><a class="headerlink" href="#c.distr_item" title="Permalink to this definition">¶</a></dt>
<dd><p>publication info distributed to other nodes</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct distr_item {
  __be32 type;
  __be32 lower;
  __be32 upper;
  __be32 port;
  __be32 key;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt>
<dd>name sequence type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lower</span></code></dt>
<dd>name sequence lower bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">upper</span></code></dt>
<dd>name sequence upper bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt>
<dd>publishing port reference</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt>
<dd>publication key</dd>
</dl>
<p><strong>Description</strong></p>
<p>===&gt; All fields are stored in network byte order. &lt;===</p>
<p>First 3 fields identify (name or) name sequence being published.
Reference field uniquely identifies port that published name sequence.
Key field uniquely identifies publication, in the event a port has
multiple publications of the same name sequence.</p>
<p><strong>Note</strong></p>
<p>There is no field that identifies the publishing node because it is
the same for all items contained within a publication message.</p>
<dl class="type">
<dt id="c.tipc_bc_base">
struct <code class="descname">tipc_bc_base</code><a class="headerlink" href="#c.tipc_bc_base" title="Permalink to this definition">¶</a></dt>
<dd><p>base structure for keeping broadcast send state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_bc_base {
  struct tipc_link *link;
  struct sk_buff_head inputq;
  int dests[MAX_BEARERS];
  int primary_bearer;
  bool bcast_support;
  bool force_bcast;
  bool rcast_support;
  bool force_rcast;
  int rc_ratio;
  int bc_threshold;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">link</span></code></dt>
<dd>broadcast send link structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inputq</span></code></dt>
<dd>data input queue; will only carry SOCK_WAKEUP messages</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dests</span></code></dt>
<dd>array keeping number of reachable destinations per bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">primary_bearer</span></code></dt>
<dd>a bearer having links to all broadcast destinations, if any</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bcast_support</span></code></dt>
<dd>indicates if primary bearer, if any, supports broadcast</dd>
<dt><code class="docutils literal notranslate"><span class="pre">force_bcast</span></code></dt>
<dd>forces broadcast for multicast traffic</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcast_support</span></code></dt>
<dd>indicates if all peer nodes support replicast</dd>
<dt><code class="docutils literal notranslate"><span class="pre">force_rcast</span></code></dt>
<dd>forces replicast for multicast traffic</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_ratio</span></code></dt>
<dd>dest count as percentage of cluster size where send method changes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bc_threshold</span></code></dt>
<dd>calculated from rc_ratio; if dests &gt; threshold use broadcast</dd>
</dl>
</div>
<div class="section" id="tipc-bearer-interfaces">
<h3>TIPC Bearer Interfaces<a class="headerlink" href="#tipc-bearer-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.tipc_media_find">
struct <a class="reference internal" href="#c.tipc_media" title="tipc_media">tipc_media</a> * <code class="descname">tipc_media_find</code><span class="sig-paren">(</span>const char<em>&nbsp;*name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_media_find" title="Permalink to this definition">¶</a></dt>
<dd><p>locates specified media object by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt>
<dd>name to locate</dd>
</dl>
<dl class="function">
<dt id="c.media_find_id">
struct <a class="reference internal" href="#c.tipc_media" title="tipc_media">tipc_media</a> * <code class="descname">media_find_id</code><span class="sig-paren">(</span>u8<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_find_id" title="Permalink to this definition">¶</a></dt>
<dd><p>locates specified media object by type identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">type</span></code></dt>
<dd>type identifier to locate</dd>
</dl>
<dl class="function">
<dt id="c.tipc_media_addr_printf">
int <code class="descname">tipc_media_addr_printf</code><span class="sig-paren">(</span>char<em>&nbsp;*buf</em>, int<em>&nbsp;len</em>, struct <a class="reference internal" href="#c.tipc_media_addr" title="tipc_media_addr">tipc_media_addr</a><em>&nbsp;*a</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_media_addr_printf" title="Permalink to this definition">¶</a></dt>
<dd><p>record media address in print buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt>
<dd>output buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>output buffer size remaining</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_media_addr</span> <span class="pre">*a</span></code></dt>
<dd>input media address</dd>
</dl>
<dl class="function">
<dt id="c.bearer_name_validate">
int <code class="descname">bearer_name_validate</code><span class="sig-paren">(</span>const char<em>&nbsp;*name</em>, struct tipc_bearer_names<em>&nbsp;*name_parts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bearer_name_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>validate &amp; (optionally) deconstruct bearer name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt>
<dd>ptr to bearer name string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer_names</span> <span class="pre">*name_parts</span></code></dt>
<dd>ptr to area for bearer name components (or NULL if not needed)</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if bearer name is valid, otherwise 0.</p>
<dl class="function">
<dt id="c.tipc_bearer_find">
struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a> * <code class="descname">tipc_bearer_find</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, const char<em>&nbsp;*name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_bearer_find" title="Permalink to this definition">¶</a></dt>
<dd><p>locates bearer object with matching bearer name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt>
<dd>bearer name to locate</dd>
</dl>
<dl class="function">
<dt id="c.tipc_enable_bearer">
int <code class="descname">tipc_enable_bearer</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, const char<em>&nbsp;*name</em>, u32<em>&nbsp;disc_domain</em>, u32<em>&nbsp;prio</em>, struct nlattr<em>&nbsp;*attr[]</em>, struct netlink_ext_ack<em>&nbsp;*extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_enable_bearer" title="Permalink to this definition">¶</a></dt>
<dd><p>enable bearer with the given name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt>
<dd>bearer name to enable</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">disc_domain</span></code></dt>
<dd>bearer domain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">prio</span></code></dt>
<dd>bearer priority</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*attr[]</span></code></dt>
<dd>nlattr array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*extack</span></code></dt>
<dd>netlink extended ack</dd>
</dl>
<dl class="function">
<dt id="c.tipc_reset_bearer">
int <code class="descname">tipc_reset_bearer</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_reset_bearer" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset all links established over this bearer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>the target bearer</dd>
</dl>
<dl class="function">
<dt id="c.bearer_disable">
void <code class="descname">bearer_disable</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bearer_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable this bearer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>the bearer to disable</dd>
</dl>
<p><strong>Note</strong></p>
<p>This routine assumes caller holds RTNL lock.</p>
<dl class="function">
<dt id="c.tipc_l2_send_msg">
int <code class="descname">tipc_l2_send_msg</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em>, struct <a class="reference internal" href="#c.tipc_media_addr" title="tipc_media_addr">tipc_media_addr</a><em>&nbsp;*dest</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_l2_send_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>send a TIPC packet out over an L2 interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>the packet to be sent</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>the bearer through which the packet is to be sent</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_media_addr</span> <span class="pre">*dest</span></code></dt>
<dd>peer destination address</dd>
</dl>
<dl class="function">
<dt id="c.tipc_l2_rcv_msg">
int <code class="descname">tipc_l2_rcv_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct <a class="reference internal" href="kapi.html#c.net_device" title="net_device">net_device</a><em>&nbsp;*dev</em>, struct packet_type<em>&nbsp;*pt</em>, struct <a class="reference internal" href="kapi.html#c.net_device" title="net_device">net_device</a><em>&nbsp;*orig_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_l2_rcv_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>handle incoming TIPC message from an interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>the received message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt>
<dd>the net device that the packet was received on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">packet_type</span> <span class="pre">*pt</span></code></dt>
<dd>the packet_type structure which was used to register this handler</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*orig_dev</span></code></dt>
<dd>the original receive net device in case the device is a bond</dd>
</dl>
<p><strong>Description</strong></p>
<p>Accept only packets explicitly sent to this node, or broadcast packets;
ignores packets sent using interface multicast, and traffic sent to other
nodes (which can happen if interface is running in promiscuous mode).</p>
<dl class="function">
<dt id="c.tipc_l2_device_event">
int <code class="descname">tipc_l2_device_event</code><span class="sig-paren">(</span>struct notifier_block<em>&nbsp;*nb</em>, unsigned long<em>&nbsp;evt</em>, void<em>&nbsp;*ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_l2_device_event" title="Permalink to this definition">¶</a></dt>
<dd><p>handle device events from network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt>
<dd>the context of the notification</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">evt</span></code></dt>
<dd>the type of event</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt>
<dd>the net device that the event was on</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called by the Ethernet driver in case of link
change event.</p>
<dl class="type">
<dt id="c.udp_media_addr">
struct <code class="descname">udp_media_addr</code><a class="headerlink" href="#c.udp_media_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>IP/UDP addressing information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct udp_media_addr {
  __be16 proto;
  __be16 port;
  union {
    struct in_addr ipv4;
    struct in6_addr ipv6;
  };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">proto</span></code></dt>
<dd>Ethernet protocol in use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt>
<dd>port being used</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipv4</span></code></dt>
<dd>IPv4 address of neighbor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipv6</span></code></dt>
<dd>IPv6 address of neighbor</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the bearer level originating address used in neighbor discovery
messages, and all fields should be in network byte order</p>
<dl class="type">
<dt id="c.udp_bearer">
struct <code class="descname">udp_bearer</code><a class="headerlink" href="#c.udp_bearer" title="Permalink to this definition">¶</a></dt>
<dd><p>ip/udp bearer data structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct udp_bearer {
  struct tipc_bearer __rcu *bearer;
  struct socket *ubsock;
  u32 ifindex;
  struct work_struct work;
  struct udp_replicast rcast;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">bearer</span></code></dt>
<dd>associated generic tipc bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ubsock</span></code></dt>
<dd>bearer associated socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ifindex</span></code></dt>
<dd>local address scope</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt>
<dd>used to schedule deferred work on a bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcast</span></code></dt>
<dd>associated udp_replicast container</dd>
</dl>
<dl class="function">
<dt id="c.tipc_parse_udp_addr">
int <code class="descname">tipc_parse_udp_addr</code><span class="sig-paren">(</span>struct nlattr<em>&nbsp;*nla</em>, struct <a class="reference internal" href="#c.udp_media_addr" title="udp_media_addr">udp_media_addr</a><em>&nbsp;*addr</em>, u32<em>&nbsp;*scope_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_parse_udp_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>build udp media address from netlink data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*nla</span></code></dt>
<dd>netlink attribute containing sockaddr storage aligned address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">udp_media_addr</span> <span class="pre">*addr</span></code></dt>
<dd>tipc media address to fill with address, port and protocol type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*scope_id</span></code></dt>
<dd>IPv6 scope id pointer, not NULL indicates it’s required</dd>
</dl>
<dl class="function">
<dt id="c.tipc_udp_enable">
int <code class="descname">tipc_udp_enable</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em>, struct nlattr<em>&nbsp;*attrs[]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_udp_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>callback to create a new udp bearer instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>pointer to generic tipc_bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*attrs[]</span></code></dt>
<dd>netlink bearer configuration</dd>
</dl>
<p><strong>Description</strong></p>
<p>validate the bearer parameters and initialize the udp bearer
rtnl_lock should be held</p>
</div>
<div class="section" id="tipc-crypto-interfaces">
<h3>TIPC Crypto Interfaces<a class="headerlink" href="#tipc-crypto-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.tipc_tfm">
struct <code class="descname">tipc_tfm</code><a class="headerlink" href="#c.tipc_tfm" title="Permalink to this definition">¶</a></dt>
<dd><p>TIPC TFM structure to form a list of TFMs</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_tfm {
  struct crypto_aead *tfm;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">tfm</span></code></dt>
<dd>cipher handle/key</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>linked list of TFMs</dd>
</dl>
<dl class="type">
<dt id="c.tipc_aead">
struct <code class="descname">tipc_aead</code><a class="headerlink" href="#c.tipc_aead" title="Permalink to this definition">¶</a></dt>
<dd><p>TIPC AEAD key structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_aead {
#define TIPC_AEAD_HINT_LEN (5);
  struct tipc_tfm * __percpu *tfm_entry;
  struct tipc_crypto *crypto;
  struct tipc_aead *cloned;
  atomic_t users;
  u32 salt;
  u8 authsize;
  u8 mode;
  char hint[2 * TIPC_AEAD_HINT_LEN + 1];
  struct rcu_head rcu;
  struct tipc_aead_key *key;
  u16 gen;
  atomic64_t seqno ;
  refcount_t refcnt ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">tfm_entry</span></code></dt>
<dd>per-cpu pointer to one entry in TFM list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crypto</span></code></dt>
<dd>TIPC crypto owns this key</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cloned</span></code></dt>
<dd>reference to the source key in case cloning</dd>
<dt><code class="docutils literal notranslate"><span class="pre">users</span></code></dt>
<dd>the number of the key users (TX/RX)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">salt</span></code></dt>
<dd>the key’s SALT value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">authsize</span></code></dt>
<dd>authentication tag size (max = 16)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt>
<dd>crypto mode is applied to the key</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hint</span></code></dt>
<dd>a hint for user key</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt>
<dd>struct rcu_head</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt>
<dd>the aead key</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gen</span></code></dt>
<dd>the key’s generation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seqno</span></code></dt>
<dd>the key seqno (cluster scope)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcnt</span></code></dt>
<dd>the key reference counter</dd>
</dl>
<dl class="type">
<dt id="c.tipc_crypto_stats">
struct <code class="descname">tipc_crypto_stats</code><a class="headerlink" href="#c.tipc_crypto_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>TIPC Crypto statistics</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_crypto_stats {
  unsigned int stat[MAX_STATS];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">stat</span></code></dt>
<dd>array of crypto statistics</dd>
</dl>
<dl class="type">
<dt id="c.tipc_crypto">
struct <code class="descname">tipc_crypto</code><a class="headerlink" href="#c.tipc_crypto" title="Permalink to this definition">¶</a></dt>
<dd><p>TIPC TX/RX crypto structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_crypto {
  struct net *net;
  struct tipc_node *node;
  struct tipc_aead __rcu *aead[KEY_MAX + 1];
  atomic_t peer_rx_active;
  u16 key_gen;
  struct tipc_key key;
  u8 skey_mode;
  struct tipc_aead_key *skey;
  struct workqueue_struct *wq;
  struct delayed_work work;
#define KEY_DISTR_SCHED         1;
#define KEY_DISTR_COMPL         2;
  atomic_t key_distr;
  u32 rekeying_intv;
  struct tipc_crypto_stats __percpu *stats;
  char name[48];
  atomic64_t sndnxt ;
  unsigned long timer1;
  unsigned long timer2;
  union {
    struct {
      u8 working:1;
      u8 key_master:1;
      u8 legacy_user:1;
      u8 nokey: 1;
    };
    u8 flags;
  };
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">net</span></code></dt>
<dd>struct net</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt>
<dd>TIPC node (RX)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aead</span></code></dt>
<dd>array of pointers to AEAD keys for encryption/decryption</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_rx_active</span></code></dt>
<dd>replicated peer RX active key index</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_gen</span></code></dt>
<dd>TX/RX key generation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt>
<dd>the key states</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skey_mode</span></code></dt>
<dd>session key’s mode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skey</span></code></dt>
<dd>received session key</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt>
<dd>common workqueue on TX crypto</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt>
<dd>delayed work sched for TX/RX</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_distr</span></code></dt>
<dd>key distributing state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rekeying_intv</span></code></dt>
<dd>rekeying interval (in minutes)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats</span></code></dt>
<dd>the crypto statistics</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>the crypto name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sndnxt</span></code></dt>
<dd>the per-peer sndnxt (TX)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer1</span></code></dt>
<dd>general timer 1 (jiffies)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer2</span></code></dt>
<dd>general timer 2 (jiffies)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal notranslate"><span class="pre">working</span></code></dt>
<dd>the crypto is working or not</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_master</span></code></dt>
<dd>flag indicates if master key exists</dd>
<dt><code class="docutils literal notranslate"><span class="pre">legacy_user</span></code></dt>
<dd>flag indicates if a peer joins w/o master key (for bwd comp.)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nokey</span></code></dt>
<dd>no key indication</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>combined flags field</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt>
<dd>tipc_key lock</dd>
</dl>
<dl class="function">
<dt id="c.tipc_aead_key_validate">
int <code class="descname">tipc_aead_key_validate</code><span class="sig-paren">(</span>struct tipc_aead_key<em>&nbsp;*ukey</em>, struct genl_info<em>&nbsp;*info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_aead_key_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate a AEAD user key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead_key</span> <span class="pre">*ukey</span></code></dt>
<dd>pointer to user key data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">genl_info</span> <span class="pre">*info</span></code></dt>
<dd>netlink info pointer</dd>
</dl>
<dl class="function">
<dt id="c.tipc_aead_key_generate">
int <code class="descname">tipc_aead_key_generate</code><span class="sig-paren">(</span>struct tipc_aead_key<em>&nbsp;*skey</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_aead_key_generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate new session key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead_key</span> <span class="pre">*skey</span></code></dt>
<dd>input/output key with new content</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 in case of success, otherwise &lt; 0</p>
<dl class="function">
<dt id="c.tipc_aead_free">
void <code class="descname">tipc_aead_free</code><span class="sig-paren">(</span>struct rcu_head<em>&nbsp;*rp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_aead_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Release AEAD key incl. all the TFMs in the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*rp</span></code></dt>
<dd>rcu head pointer</dd>
</dl>
<dl class="function">
<dt id="c.tipc_aead_tfm_next">
struct crypto_aead * <code class="descname">tipc_aead_tfm_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_aead" title="tipc_aead">tipc_aead</a><em>&nbsp;*aead</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_aead_tfm_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Move TFM entry to the next one in list and return it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead</span> <span class="pre">*aead</span></code></dt>
<dd>the AEAD key pointer</dd>
</dl>
<dl class="function">
<dt id="c.tipc_aead_init">
int <code class="descname">tipc_aead_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_aead" title="tipc_aead">tipc_aead</a><em>&nbsp;**aead</em>, struct tipc_aead_key<em>&nbsp;*ukey</em>, u8<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_aead_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate TIPC AEAD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead</span> <span class="pre">**aead</span></code></dt>
<dd>returned new TIPC AEAD key handle pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead_key</span> <span class="pre">*ukey</span></code></dt>
<dd>pointer to user key data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">mode</span></code></dt>
<dd>the key mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a (list of) new cipher transformation (TFM) with the specific user
key data if valid. The number of the allocated TFMs can be set via the sysfs
“net/tipc/max_tfms” first.
Also, all the other AEAD data are also initialized.</p>
<p><strong>Return</strong></p>
<p>0 if the initiation is successful, otherwise: &lt; 0</p>
<dl class="function">
<dt id="c.tipc_aead_clone">
int <code class="descname">tipc_aead_clone</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_aead" title="tipc_aead">tipc_aead</a><em>&nbsp;**dst</em>, struct <a class="reference internal" href="#c.tipc_aead" title="tipc_aead">tipc_aead</a><em>&nbsp;*src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_aead_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone a TIPC AEAD key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead</span> <span class="pre">**dst</span></code></dt>
<dd>dest key for the cloning</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead</span> <span class="pre">*src</span></code></dt>
<dd>source key to clone from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make a “copy” of the source AEAD key data to the dest, the TFMs list is
common for the keys.
A reference to the source is hold in the “cloned” pointer for the later
freeing purposes.</p>
<p><strong>Note</strong></p>
<p>this must be done in cluster-key mode only!</p>
<p><strong>Return</strong></p>
<p>0 in case of success, otherwise &lt; 0</p>
<dl class="function">
<dt id="c.tipc_aead_mem_alloc">
void * <code class="descname">tipc_aead_mem_alloc</code><span class="sig-paren">(</span>struct crypto_aead<em>&nbsp;*tfm</em>, unsigned int<em>&nbsp;crypto_ctx_size</em>, u8<em>&nbsp;**iv</em>, struct <a class="reference internal" href="../crypto/api-aead.html#c.aead_request" title="aead_request">aead_request</a><em>&nbsp;**req</em>, struct scatterlist<em>&nbsp;**sg</em>, int<em>&nbsp;nsg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_aead_mem_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate memory for AEAD request operations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_aead</span> <span class="pre">*tfm</span></code></dt>
<dd>cipher handle to be registered with the request</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crypto_ctx_size</span></code></dt>
<dd>size of crypto context for callback</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">**iv</span></code></dt>
<dd>returned pointer to IV data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">aead_request</span> <span class="pre">**req</span></code></dt>
<dd>returned pointer to AEAD request data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">**sg</span></code></dt>
<dd>returned pointer to SG lists</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nsg</span></code></dt>
<dd>number of SG lists to be allocated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate memory to store the crypto context data, AEAD request, IV and SG
lists, the memory layout is as follows:
crypto_ctx || iv || aead_req || sg[]</p>
<p><strong>Return</strong></p>
<p>the pointer to the memory areas in case of success, otherwise NULL</p>
<dl class="function">
<dt id="c.tipc_aead_encrypt">
int <code class="descname">tipc_aead_encrypt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_aead" title="tipc_aead">tipc_aead</a><em>&nbsp;*aead</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em>, struct <a class="reference internal" href="#c.tipc_media_addr" title="tipc_media_addr">tipc_media_addr</a><em>&nbsp;*dst</em>, struct <a class="reference internal" href="#c.tipc_node" title="tipc_node">tipc_node</a><em>&nbsp;*__dnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_aead_encrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>Encrypt a message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead</span> <span class="pre">*aead</span></code></dt>
<dd>TIPC AEAD key for the message encryption</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>the input/output skb</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>TIPC bearer where the message will be delivered after the encryption</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_media_addr</span> <span class="pre">*dst</span></code></dt>
<dd>the destination media address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_node</span> <span class="pre">*__dnode</span></code></dt>
<dd>TIPC dest node if “known”</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li>0                   : if the encryption has completed</li>
<li>-EINPROGRESS/-EBUSY : if a callback will be performed</li>
<li>&lt; 0                 : the encryption has failed</li>
</ul>
<dl class="function">
<dt id="c.tipc_aead_decrypt">
int <code class="descname">tipc_aead_decrypt</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.tipc_aead" title="tipc_aead">tipc_aead</a><em>&nbsp;*aead</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_aead_decrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrypt an encrypted message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>struct net</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead</span> <span class="pre">*aead</span></code></dt>
<dd>TIPC AEAD for the message decryption</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>the input/output skb</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>TIPC bearer where the message has been received</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li>0                   : if the decryption has completed</li>
<li>-EINPROGRESS/-EBUSY : if a callback will be performed</li>
<li>&lt; 0                 : the decryption has failed</li>
</ul>
<dl class="function">
<dt id="c.tipc_ehdr_validate">
bool <code class="descname">tipc_ehdr_validate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_ehdr_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate an encryption message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>the message buffer</dd>
</dl>
<p><strong>Return</strong></p>
<p>“true” if this is a valid encryption message, otherwise “false”</p>
<dl class="function">
<dt id="c.tipc_ehdr_build">
int <code class="descname">tipc_ehdr_build</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.tipc_aead" title="tipc_aead">tipc_aead</a><em>&nbsp;*aead</em>, u8<em>&nbsp;tx_key</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*__rx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_ehdr_build" title="Permalink to this definition">¶</a></dt>
<dd><p>Build TIPC encryption message header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>struct net</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead</span> <span class="pre">*aead</span></code></dt>
<dd>TX AEAD key to be used for the message encryption</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">tx_key</span></code></dt>
<dd>key id used for the message encryption</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>input/output message skb</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*__rx</span></code></dt>
<dd>RX crypto handle if dest is “known”</dd>
</dl>
<p><strong>Return</strong></p>
<p>the header size if the building is successful, otherwise &lt; 0</p>
<dl class="function">
<dt id="c.tipc_crypto_key_init">
int <code class="descname">tipc_crypto_key_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*c</em>, struct tipc_aead_key<em>&nbsp;*ukey</em>, u8<em>&nbsp;mode</em>, bool<em>&nbsp;master_key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_key_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate a new user / AEAD key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*c</span></code></dt>
<dd>TIPC crypto to which new key is attached</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead_key</span> <span class="pre">*ukey</span></code></dt>
<dd>the user key</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">mode</span></code></dt>
<dd>the key mode (CLUSTER_KEY or PER_NODE_KEY)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">master_key</span></code></dt>
<dd>specify this is a cluster master key</dd>
</dl>
<p><strong>Description</strong></p>
<p>A new TIPC AEAD key will be allocated and initiated with the specified user
key, then attached to the TIPC crypto.</p>
<p><strong>Return</strong></p>
<p>new key id in case of success, otherwise: &lt; 0</p>
<dl class="function">
<dt id="c.tipc_crypto_key_attach">
int <code class="descname">tipc_crypto_key_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*c</em>, struct <a class="reference internal" href="#c.tipc_aead" title="tipc_aead">tipc_aead</a><em>&nbsp;*aead</em>, u8<em>&nbsp;pos</em>, bool<em>&nbsp;master_key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_key_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a new AEAD key to TIPC crypto</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*c</span></code></dt>
<dd>TIPC crypto to which the new AEAD key is attached</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead</span> <span class="pre">*aead</span></code></dt>
<dd>the new AEAD key pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">pos</span></code></dt>
<dd>desired slot in the crypto key array, = 0 if any!</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">master_key</span></code></dt>
<dd>specify this is a cluster master key</dd>
</dl>
<p><strong>Return</strong></p>
<p>new key id in case of success, otherwise: -EBUSY</p>
<dl class="function">
<dt id="c.tipc_crypto_key_try_align">
bool <code class="descname">tipc_crypto_key_try_align</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*rx</em>, u8<em>&nbsp;new_pending</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_key_try_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align RX keys if possible</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*rx</span></code></dt>
<dd>RX crypto handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">new_pending</span></code></dt>
<dd>new pending slot if aligned (= TX key from peer)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Peer has used an unknown key slot, this only happens when peer has left and
rejoned, or we are newcomer.
That means, there must be no active key but a pending key at unaligned slot.
If so, we try to move the pending key to the new slot.</p>
<p><strong>Note</strong></p>
<p>A potential passive key can exist, it will be shifted correspondingly!</p>
<p><strong>Return</strong></p>
<p>“true” if key is successfully aligned, otherwise “false”</p>
<dl class="function">
<dt id="c.tipc_crypto_key_pick_tx">
struct <a class="reference internal" href="#c.tipc_aead" title="tipc_aead">tipc_aead</a> * <code class="descname">tipc_crypto_key_pick_tx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*tx</em>, struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*rx</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, u8<em>&nbsp;tx_key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_key_pick_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick one TX key for message decryption</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*tx</span></code></dt>
<dd>TX crypto handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*rx</span></code></dt>
<dd>RX crypto handle (can be NULL)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>the message skb which will be decrypted later</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">tx_key</span></code></dt>
<dd>peer TX key id</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the existing TX keys and pick one which is suitable
for the message decryption, that must be a cluster key and not used before
on the same message (i.e. recursive).</p>
<p><strong>Return</strong></p>
<p>the TX AEAD key handle in case of success, otherwise NULL</p>
<dl class="function">
<dt id="c.tipc_crypto_key_synch">
void <code class="descname">tipc_crypto_key_synch</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*rx</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_key_synch" title="Permalink to this definition">¶</a></dt>
<dd><p>Synch own key data according to peer key status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*rx</span></code></dt>
<dd>RX crypto handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>TIPCv2 message buffer (incl. the ehdr from peer)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function updates the peer node related data as the peer RX active key
has changed, so the number of TX keys’ users on this node are increased and
decreased correspondingly.</p>
<p>It also considers if peer has no key, then we need to make own master key
(if any) taking over i.e. starting grace period and also trigger key
distributing process.</p>
<p>The “per-peer” sndnxt is also reset when the peer key has switched.</p>
<dl class="function">
<dt id="c.tipc_crypto_xmit">
int <code class="descname">tipc_crypto_xmit</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;**skb</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em>, struct <a class="reference internal" href="#c.tipc_media_addr" title="tipc_media_addr">tipc_media_addr</a><em>&nbsp;*dst</em>, struct <a class="reference internal" href="#c.tipc_node" title="tipc_node">tipc_node</a><em>&nbsp;*__dnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>Build &amp; encrypt TIPC message for xmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>struct net</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**skb</span></code></dt>
<dd>input/output message skb pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>bearer used for xmit later</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_media_addr</span> <span class="pre">*dst</span></code></dt>
<dd>destination media address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_node</span> <span class="pre">*__dnode</span></code></dt>
<dd>destination node for reference if any</dd>
</dl>
<p><strong>Description</strong></p>
<p>First, build an encryption message header on the top of the message, then
encrypt the original TIPC message by using the pending, master or active
key with this preference order.
If the encryption is successful, the encrypted skb is returned directly or
via the callback.
Otherwise, the skb is freed!</p>
<p><strong>Return</strong></p>
<ul>
<li><p class="first">0                   : the encryption has succeeded (or no encryption)</p>
</li>
<li><p class="first">-EINPROGRESS/-EBUSY : the encryption is ongoing, a callback will be made</p>
</li>
<li><table class="first docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>NOKEK</var></span></kbd></td>
<td><p class="first last">: the encryption has failed due to no key</p>
</td></tr>
</tbody>
</table>
</li>
<li><table class="first docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>KEYREVOKED</var></span></kbd></td>
<td><p class="first last">: the encryption has failed due to key revoked</p>
</td></tr>
</tbody>
</table>
</li>
<li><table class="first docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>NOMEM</var></span></kbd></td>
<td><p class="first last">: the encryption has failed due to no memory</p>
</td></tr>
</tbody>
</table>
</li>
<li><p class="first">&lt; 0                 : the encryption has failed due to other reasons</p>
</li>
</ul>
<dl class="function">
<dt id="c.tipc_crypto_rcv">
int <code class="descname">tipc_crypto_rcv</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*rx</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;**skb</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrypt an encrypted TIPC message from peer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>struct net</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*rx</span></code></dt>
<dd>RX crypto handle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**skb</span></code></dt>
<dd>input/output message skb pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>bearer where the message has been received</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the decryption is successful, the decrypted skb is returned directly or
as the callback, the encryption header and auth tag will be trimed out
before forwarding to <a class="reference internal" href="#c.tipc_rcv" title="tipc_rcv"><code class="xref c c-func docutils literal notranslate"><span class="pre">tipc_rcv()</span></code></a> via the tipc_crypto_rcv_complete().
Otherwise, the skb will be freed!</p>
<p><strong>Note</strong></p>
<p>RX key(s) can be re-aligned, or in case of no key suitable, TX
cluster key(s) can be taken for decryption (- recursive).</p>
<p><strong>Return</strong></p>
<ul>
<li><p class="first">0                   : the decryption has successfully completed</p>
</li>
<li><p class="first">-EINPROGRESS/-EBUSY : the decryption is ongoing, a callback will be made</p>
</li>
<li><table class="first docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>NOKEY</var></span></kbd></td>
<td><p class="first last">: the decryption has failed due to no key</p>
</td></tr>
</tbody>
</table>
</li>
<li><table class="first docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>BADMSG</var></span></kbd></td>
<td><p class="first last">: the decryption has failed due to bad message</p>
</td></tr>
</tbody>
</table>
</li>
<li><table class="first docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>NOMEM</var></span></kbd></td>
<td><p class="first last">: the decryption has failed due to no memory</p>
</td></tr>
</tbody>
</table>
</li>
<li><p class="first">&lt; 0                 : the decryption has failed due to other reasons</p>
</li>
</ul>
<dl class="function">
<dt id="c.tipc_crypto_msg_rcv">
void <code class="descname">tipc_crypto_msg_rcv</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_msg_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>Common ‘MSG_CRYPTO’ processing point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the struct net</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>the receiving message buffer</dd>
</dl>
<dl class="function">
<dt id="c.tipc_crypto_key_distr">
int <code class="descname">tipc_crypto_key_distr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*tx</em>, u8<em>&nbsp;key</em>, struct <a class="reference internal" href="#c.tipc_node" title="tipc_node">tipc_node</a><em>&nbsp;*dest</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_key_distr" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribute a TX key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*tx</span></code></dt>
<dd>the TX crypto</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">key</span></code></dt>
<dd>the key’s index</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_node</span> <span class="pre">*dest</span></code></dt>
<dd>the destination tipc node, = NULL if distributing to all nodes</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 in case of success, otherwise &lt; 0</p>
<dl class="function">
<dt id="c.tipc_crypto_key_xmit">
int <code class="descname">tipc_crypto_key_xmit</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct tipc_aead_key<em>&nbsp;*skey</em>, u16<em>&nbsp;gen</em>, u8<em>&nbsp;mode</em>, u32<em>&nbsp;dnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_key_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a session key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the struct net</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_aead_key</span> <span class="pre">*skey</span></code></dt>
<dd>the session key to be sent</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">gen</span></code></dt>
<dd>the key’s generation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">mode</span></code></dt>
<dd>the key’s mode</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dnode</span></code></dt>
<dd>the destination node address, = 0 if broadcasting to all nodes</dd>
</dl>
<p><strong>Description</strong></p>
<p>The session key ‘skey’ is packed in a TIPC v2 ‘MSG_CRYPTO/KEY_DISTR_MSG’
as its data section, then xmit-ed through the uc/bc link.</p>
<p><strong>Return</strong></p>
<p>0 in case of success, otherwise &lt; 0</p>
<dl class="function">
<dt id="c.tipc_crypto_key_rcv">
bool <code class="descname">tipc_crypto_key_rcv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*rx</em>, struct tipc_msg<em>&nbsp;*hdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_key_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a session key</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*rx</span></code></dt>
<dd>the RX crypto</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_msg</span> <span class="pre">*hdr</span></code></dt>
<dd>the TIPC v2 message incl. the receiving session key in its data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function retrieves the session key in the message from peer, then
schedules a RX work to attach the key to the corresponding RX crypto.</p>
<p><strong>Return</strong></p>
<p>“true” if the key has been scheduled for attaching, otherwise
“false”.</p>
<dl class="function">
<dt id="c.tipc_crypto_work_rx">
void <code class="descname">tipc_crypto_work_rx</code><span class="sig-paren">(</span>struct work_struct<em>&nbsp;*work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_work_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheduled RX works handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt>
<dd>the struct RX work</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function processes the previous scheduled works i.e. distributing TX key
or attaching a received session key on RX crypto.</p>
<dl class="function">
<dt id="c.tipc_crypto_rekeying_sched">
void <code class="descname">tipc_crypto_rekeying_sched</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a><em>&nbsp;*tx</em>, bool<em>&nbsp;changed</em>, u32<em>&nbsp;new_intv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_rekeying_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>(Re)schedule rekeying w/o new interval</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_crypto</span> <span class="pre">*tx</span></code></dt>
<dd>TX crypto</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">changed</span></code></dt>
<dd>if the rekeying needs to be rescheduled with new interval</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">new_intv</span></code></dt>
<dd>new rekeying interval (when “changed” = true)</dd>
</dl>
<dl class="function">
<dt id="c.tipc_crypto_work_tx">
void <code class="descname">tipc_crypto_work_tx</code><span class="sig-paren">(</span>struct work_struct<em>&nbsp;*work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_crypto_work_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheduled TX works handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt>
<dd>the struct TX work</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function processes the previous scheduled work, i.e. key rekeying, by
generating a new session key based on current one, then attaching it to the
TX crypto and finally distributing it to peers. It also re-schedules the
rekeying if needed.</p>
</div>
<div class="section" id="tipc-discoverer-interfaces">
<h3>TIPC Discoverer Interfaces<a class="headerlink" href="#tipc-discoverer-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.tipc_discoverer">
struct <code class="descname">tipc_discoverer</code><a class="headerlink" href="#c.tipc_discoverer" title="Permalink to this definition">¶</a></dt>
<dd><p>information about an ongoing link setup request</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_discoverer {
  u32 bearer_id;
  struct tipc_media_addr dest;
  struct net *net;
  u32 domain;
  int num_nodes;
  spinlock_t lock;
  struct sk_buff *skb;
  struct timer_list timer;
  unsigned long timer_intv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">bearer_id</span></code></dt>
<dd>identity of bearer issuing requests</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest</span></code></dt>
<dd>destination address for request messages</dd>
<dt><code class="docutils literal notranslate"><span class="pre">net</span></code></dt>
<dd>network namespace instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">domain</span></code></dt>
<dd>network domain to which links can be established</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_nodes</span></code></dt>
<dd>number of nodes currently discovered (i.e. with an active link)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt>
<dd>spinlock for controlling access to requests</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skb</span></code></dt>
<dd>request message to be (repeatedly) sent</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer</span></code></dt>
<dd>timer governing period between requests</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer_intv</span></code></dt>
<dd>current interval between requests (in ms)</dd>
</dl>
<dl class="function">
<dt id="c.tipc_disc_init_msg">
void <code class="descname">tipc_disc_init_msg</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, u32<em>&nbsp;mtyp</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_disc_init_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a link setup message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>buffer containing message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mtyp</span></code></dt>
<dd>message type (request or response)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>ptr to bearer issuing message</dd>
</dl>
<dl class="function">
<dt id="c.disc_dupl_alert">
void <code class="descname">disc_dupl_alert</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em>, u32<em>&nbsp;node_addr</em>, struct <a class="reference internal" href="#c.tipc_media_addr" title="tipc_media_addr">tipc_media_addr</a><em>&nbsp;*media_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disc_dupl_alert" title="Permalink to this definition">¶</a></dt>
<dd><p>issue node address duplication alert</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>pointer to bearer detecting duplication</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">node_addr</span></code></dt>
<dd>duplicated node address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_media_addr</span> <span class="pre">*media_addr</span></code></dt>
<dd>media address advertised by duplicated node</dd>
</dl>
<dl class="function">
<dt id="c.tipc_disc_rcv">
void <code class="descname">tipc_disc_rcv</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_disc_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>handle incoming discovery message (request or response)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>buffer containing message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>bearer that message arrived on</dd>
</dl>
<dl class="function">
<dt id="c.tipc_disc_create">
int <code class="descname">tipc_disc_create</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em>, struct <a class="reference internal" href="#c.tipc_media_addr" title="tipc_media_addr">tipc_media_addr</a><em>&nbsp;*dest</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;**skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_disc_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create object to send periodic link setup requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>ptr to bearer issuing requests</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_media_addr</span> <span class="pre">*dest</span></code></dt>
<dd>destination address for request messages</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**skb</span></code></dt>
<dd>pointer to created frame</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if successful, otherwise -errno.</p>
<dl class="function">
<dt id="c.tipc_disc_delete">
void <code class="descname">tipc_disc_delete</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_discoverer" title="tipc_discoverer">tipc_discoverer</a><em>&nbsp;*d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_disc_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy object sending periodic link setup requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_discoverer</span> <span class="pre">*d</span></code></dt>
<dd>ptr to link dest structure</dd>
</dl>
<dl class="function">
<dt id="c.tipc_disc_reset">
void <code class="descname">tipc_disc_reset</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_disc_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset object to send periodic link setup requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>ptr to bearer issuing requests</dd>
</dl>
</div>
<div class="section" id="tipc-link-interfaces">
<h3>TIPC Link Interfaces<a class="headerlink" href="#tipc-link-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.tipc_link">
struct <code class="descname">tipc_link</code><a class="headerlink" href="#c.tipc_link" title="Permalink to this definition">¶</a></dt>
<dd><p>TIPC link data structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_link {
  u32 addr;
  char name[TIPC_MAX_LINK_NAME];
  struct net *net;
  u16 peer_session;
  u16 session;
  u16 snd_nxt_state;
  u16 rcv_nxt_state;
  u32 peer_bearer_id;
  u32 bearer_id;
  u32 tolerance;
  u32 abort_limit;
  u32 state;
  u16 peer_caps;
  bool in_session;
  bool active;
  u32 silent_intv_cnt;
  char if_name[TIPC_MAX_IF_NAME];
  u32 priority;
  char net_plane;
  struct tipc_mon_state mon_state;
  u16 rst_cnt;
  u16 drop_point;
  struct sk_buff *failover_reasm_skb;
  struct sk_buff_head failover_deferdq;
  u16 mtu;
  u16 advertised_mtu;
  struct sk_buff_head transmq;
  struct sk_buff_head backlogq;
  struct {
    u16 len;
    u16 limit;
    struct sk_buff *target_bskb;
  } backlog[5];
  u16 snd_nxt;
  u16 rcv_nxt;
  u32 rcv_unacked;
  struct sk_buff_head deferdq;
  struct sk_buff_head *inputq;
  struct sk_buff_head *namedq;
  struct sk_buff_head wakeupq;
  u16 window;
  u16 min_win;
  u16 ssthresh;
  u16 max_win;
  u16 cong_acks;
  u16 checkpoint;
  struct sk_buff *reasm_buf;
  struct sk_buff *reasm_tnlmsg;
  u16 ackers;
  u16 acked;
  u16 last_gap;
  struct tipc_gap_ack_blks *last_ga;
  struct tipc_link *bc_rcvlink;
  struct tipc_link *bc_sndlink;
  u8 nack_state;
  bool bc_peer_is_up;
  struct tipc_stats stats;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt>
<dd>network address of link’s peer node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>link name character string</dd>
<dt><code class="docutils literal notranslate"><span class="pre">net</span></code></dt>
<dd>pointer to namespace struct</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_session</span></code></dt>
<dd>link session # being used by peer end of link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">session</span></code></dt>
<dd>session to be used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_nxt_state</span></code></dt>
<dd>next send seq number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcv_nxt_state</span></code></dt>
<dd>next rcv seq number</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_bearer_id</span></code></dt>
<dd>bearer id used by link’s peer endpoint</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bearer_id</span></code></dt>
<dd>local bearer id used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tolerance</span></code></dt>
<dd>minimum link continuity loss needed to reset link [in ms]</dd>
<dt><code class="docutils literal notranslate"><span class="pre">abort_limit</span></code></dt>
<dd># of unacknowledged continuity probes needed to reset link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt>
<dd>current state of link FSM</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_caps</span></code></dt>
<dd>bitmap describing capabilities of peer node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in_session</span></code></dt>
<dd>have received ACTIVATE_MSG from peer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active</span></code></dt>
<dd>link is active</dd>
<dt><code class="docutils literal notranslate"><span class="pre">silent_intv_cnt</span></code></dt>
<dd># of timer intervals without any reception from peer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">if_name</span></code></dt>
<dd>associated interface name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priority</span></code></dt>
<dd>current link priority</dd>
<dt><code class="docutils literal notranslate"><span class="pre">net_plane</span></code></dt>
<dd>current link network plane (‘A’ through ‘H’)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mon_state</span></code></dt>
<dd>cookie with information needed by link monitor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rst_cnt</span></code></dt>
<dd>link reset counter</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drop_point</span></code></dt>
<dd>seq number for failover handling (FIXME)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">failover_reasm_skb</span></code></dt>
<dd>saved failover msg ptr (FIXME)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">failover_deferdq</span></code></dt>
<dd>deferred message queue for failover processing (FIXME)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mtu</span></code></dt>
<dd>current maximum packet size for this link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">advertised_mtu</span></code></dt>
<dd>advertised own mtu when link is being established</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transmq</span></code></dt>
<dd>the link’s transmit queue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlogq</span></code></dt>
<dd>queue for messages waiting to be sent</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlog</span></code></dt>
<dd>link’s backlog by priority (importance)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_nxt</span></code></dt>
<dd>next sequence number to be used</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcv_nxt</span></code></dt>
<dd>next sequence number to expect for inbound messages</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcv_unacked</span></code></dt>
<dd># messages read by user, but not yet acked back to peer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deferdq</span></code></dt>
<dd>deferred receive queue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inputq</span></code></dt>
<dd>buffer queue for messages to be delivered upwards</dd>
<dt><code class="docutils literal notranslate"><span class="pre">namedq</span></code></dt>
<dd>buffer queue for name table messages to be delivered upwards</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wakeupq</span></code></dt>
<dd>linked list of wakeup msgs waiting for link congestion to abate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">window</span></code></dt>
<dd>sliding window size for congestion handling</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_win</span></code></dt>
<dd>minimal send window to be used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssthresh</span></code></dt>
<dd>slow start threshold for congestion handling</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_win</span></code></dt>
<dd>maximal send window to be used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cong_acks</span></code></dt>
<dd>congestion acks for congestion avoidance (FIXME)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">checkpoint</span></code></dt>
<dd>seq number for congestion window size handling</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reasm_buf</span></code></dt>
<dd>head of partially reassembled inbound message fragments</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reasm_tnlmsg</span></code></dt>
<dd>fragmentation/reassembly area for tunnel protocol message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ackers</span></code></dt>
<dd># of peers that needs to ack each packet before it can be released</dd>
<dt><code class="docutils literal notranslate"><span class="pre">acked</span></code></dt>
<dd># last packet acked by a certain peer. Used for broadcast.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_gap</span></code></dt>
<dd>last gap ack blocks for bcast (FIXME)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_ga</span></code></dt>
<dd>ptr to gap ack blocks</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bc_rcvlink</span></code></dt>
<dd>the peer specific link used for broadcast reception</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bc_sndlink</span></code></dt>
<dd>the namespace global link used for broadcast sending</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nack_state</span></code></dt>
<dd>bcast nack state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bc_peer_is_up</span></code></dt>
<dd>peer has acked the bcast init msg</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats</span></code></dt>
<dd>collects statistics regarding link activity</dd>
</dl>
<dl class="function">
<dt id="c.tipc_link_create">
bool <code class="descname">tipc_link_create</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, char<em>&nbsp;*if_name</em>, int<em>&nbsp;bearer_id</em>, int<em>&nbsp;tolerance</em>, char<em>&nbsp;net_plane</em>, u32<em>&nbsp;mtu</em>, int<em>&nbsp;priority</em>, u32<em>&nbsp;min_win</em>, u32<em>&nbsp;max_win</em>, u32<em>&nbsp;session</em>, u32<em>&nbsp;self</em>, u32<em>&nbsp;peer</em>, u8<em>&nbsp;*peer_id</em>, u16<em>&nbsp;peer_caps</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*bc_sndlink</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*bc_rcvlink</em>, struct sk_buff_head<em>&nbsp;*inputq</em>, struct sk_buff_head<em>&nbsp;*namedq</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;**link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_link_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>pointer to associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*if_name</span></code></dt>
<dd>associated interface name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bearer_id</span></code></dt>
<dd>id (index) of associated bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">tolerance</span></code></dt>
<dd>link tolerance to be used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">net_plane</span></code></dt>
<dd>network plane (A,B,c..) this link belongs to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mtu</span></code></dt>
<dd>mtu to be advertised by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">priority</span></code></dt>
<dd>priority to be used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">min_win</span></code></dt>
<dd>minimal send window to be used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">max_win</span></code></dt>
<dd>maximal send window to be used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">session</span></code></dt>
<dd>session to be used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">self</span></code></dt>
<dd>local unicast link id</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">peer</span></code></dt>
<dd>node id of peer node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*peer_id</span></code></dt>
<dd>128-bit ID of peer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">peer_caps</span></code></dt>
<dd>bitmap describing peer node capabilities</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*bc_sndlink</span></code></dt>
<dd>the namespace global link used for broadcast sending</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*bc_rcvlink</span></code></dt>
<dd>the peer specific link used for broadcast reception</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*inputq</span></code></dt>
<dd>queue to put messages ready for delivery</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*namedq</span></code></dt>
<dd>queue to put binding table update messages ready for delivery</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">**link</span></code></dt>
<dd>return value, pointer to put the created link</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if link was created, otherwise false</p>
<dl class="function">
<dt id="c.tipc_link_bc_create">
bool <code class="descname">tipc_link_bc_create</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, u32<em>&nbsp;ownnode</em>, u32<em>&nbsp;peer</em>, u8<em>&nbsp;*peer_id</em>, int<em>&nbsp;mtu</em>, u32<em>&nbsp;min_win</em>, u32<em>&nbsp;max_win</em>, u16<em>&nbsp;peer_caps</em>, struct sk_buff_head<em>&nbsp;*inputq</em>, struct sk_buff_head<em>&nbsp;*namedq</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*bc_sndlink</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;**link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_link_bc_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create new link to be used for broadcast</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>pointer to associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">ownnode</span></code></dt>
<dd>identity of own node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">peer</span></code></dt>
<dd>node id of peer node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*peer_id</span></code></dt>
<dd>128-bit ID of peer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mtu</span></code></dt>
<dd>mtu to be used initially if no peers</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">min_win</span></code></dt>
<dd>minimal send window to be used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">max_win</span></code></dt>
<dd>maximal send window to be used by link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">peer_caps</span></code></dt>
<dd>bitmap describing peer node capabilities</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*inputq</span></code></dt>
<dd>queue to put messages ready for delivery</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*namedq</span></code></dt>
<dd>queue to put binding table update messages ready for delivery</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*bc_sndlink</span></code></dt>
<dd>the namespace global link used for broadcast sending</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">**link</span></code></dt>
<dd>return value, pointer to put the created link</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if link was created, otherwise false</p>
<dl class="function">
<dt id="c.tipc_link_fsm_evt">
int <code class="descname">tipc_link_fsm_evt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em>, int<em>&nbsp;evt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_link_fsm_evt" title="Permalink to this definition">¶</a></dt>
<dd><p>link finite state machine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>pointer to link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">evt</span></code></dt>
<dd>state machine event to be processed</dd>
</dl>
<dl class="function">
<dt id="c.tipc_link_too_silent">
bool <code class="descname">tipc_link_too_silent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_link_too_silent" title="Permalink to this definition">¶</a></dt>
<dd><p>check if link is “too silent”</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>tipc link to be checked</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the link ‘silent_intv_cnt’ is about to reach the
‘abort_limit’ value, otherwise false</p>
<dl class="function">
<dt id="c.link_schedule_user">
int <code class="descname">link_schedule_user</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em>, struct tipc_msg<em>&nbsp;*hdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.link_schedule_user" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule a message sender for wakeup after congestion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>congested link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_msg</span> <span class="pre">*hdr</span></code></dt>
<dd>header of message that is being sent
Create pseudo msg to send back to user when congestion abates</dd>
</dl>
<dl class="function">
<dt id="c.link_prepare_wakeup">
void <code class="descname">link_prepare_wakeup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em><span class="sig-paren">)</span><a class="headerlink" href="#c.link_prepare_wakeup" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare users for wakeup after congestion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>congested link
Wake up a number of waiting users, as permitted by available space
in the send queue</dd>
</dl>
<dl class="function">
<dt id="c.tipc_link_set_skb_retransmit_time">
void <code class="descname">tipc_link_set_skb_retransmit_time</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_link_set_skb_retransmit_time" title="Permalink to this definition">¶</a></dt>
<dd><p>set the time at which retransmission of the given skb should be next attempted</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>skb to set a future retransmission time for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>link the skb will be transmitted on</dd>
</dl>
<dl class="function">
<dt id="c.tipc_link_xmit">
int <code class="descname">tipc_link_xmit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em>, struct sk_buff_head<em>&nbsp;*list</em>, struct sk_buff_head<em>&nbsp;*xmitq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_link_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>enqueue buffer list according to queue situation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>link to use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt>
<dd>chain of buffers containing message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>returned list of packets to be sent by caller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Consumes the buffer chain.
Messages at TIPC_SYSTEM_IMPORTANCE are always accepted</p>
<p><strong>Return</strong></p>
<p>0 if success, or errno: -ELINKCONG, -EMSGSIZE or -ENOBUFS</p>
<dl class="function">
<dt id="c.link_retransmit_failure">
bool <code class="descname">link_retransmit_failure</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*r</em>, int<em>&nbsp;*rc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.link_retransmit_failure" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect repeated retransmit failures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>tipc link sender</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*r</span></code></dt>
<dd>tipc link receiver (= l in case of unicast)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*rc</span></code></dt>
<dd>returned code</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the repeated retransmit failures happens, otherwise
false</p>
<dl class="function">
<dt id="c.tipc_get_gap_ack_blks">
u16 <code class="descname">tipc_get_gap_ack_blks</code><span class="sig-paren">(</span>struct tipc_gap_ack_blks<em>&nbsp;**ga</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em>, struct tipc_msg<em>&nbsp;*hdr</em>, bool<em>&nbsp;uc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_get_gap_ack_blks" title="Permalink to this definition">¶</a></dt>
<dd><p>get Gap ACK blocks from PROTOCOL/STATE_MSG</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_gap_ack_blks</span> <span class="pre">**ga</span></code></dt>
<dd>returned pointer to the Gap ACK blocks if any</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>the tipc link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_msg</span> <span class="pre">*hdr</span></code></dt>
<dd>the PROTOCOL/STATE_MSG header</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">uc</span></code></dt>
<dd>desired Gap ACK blocks type, i.e. unicast (= 1) or broadcast (= 0)</dd>
</dl>
<p><strong>Return</strong></p>
<p>the total Gap ACK blocks size</p>
<dl class="function">
<dt id="c.tipc_link_failover_prepare">
void <code class="descname">tipc_link_failover_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*tnl</em>, struct sk_buff_head<em>&nbsp;*xmitq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_link_failover_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare tnl for link failover</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>failover link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*tnl</span></code></dt>
<dd>tunnel link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>queue for messages to be xmited</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a special version of the precursor - tipc_link_tnl_prepare(),
see the <a class="reference internal" href="#c.tipc_node_link_failover" title="tipc_node_link_failover"><code class="xref c c-func docutils literal notranslate"><span class="pre">tipc_node_link_failover()</span></code></a> for details</p>
<dl class="function">
<dt id="c.tipc_link_reset_stats">
void <code class="descname">tipc_link_reset_stats</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_link_reset_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>reset link statistics</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>pointer to link</dd>
</dl>
<dl class="function">
<dt id="c.tipc_link_dump">
int <code class="descname">tipc_link_dump</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em>, u16<em>&nbsp;dqueues</em>, char<em>&nbsp;*buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_link_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>dump TIPC link data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>tipc link to be dumped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">dqueues</span></code></dt>
<dd>bitmask to decide if any link queue to be dumped?
- TIPC_DUMP_NONE: don’t dump link queues
- TIPC_DUMP_TRANSMQ: dump link transmq queue
- TIPC_DUMP_BACKLOGQ: dump link backlog queue
- TIPC_DUMP_DEFERDQ: dump link deferd queue
- TIPC_DUMP_INPUTQ: dump link input queue
- TIPC_DUMP_WAKEUP: dump link wakeup queue
- TIPC_DUMP_ALL: dump all the link queues above</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt>
<dd>returned buffer of dump data in format</dd>
</dl>
</div>
<div class="section" id="tipc-msg-interfaces">
<h3>TIPC msg Interfaces<a class="headerlink" href="#tipc-msg-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.tipc_buf_acquire">
struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">tipc_buf_acquire</code><span class="sig-paren">(</span>u32<em>&nbsp;size</em>, <a class="reference internal" href="../core-api/mm-api.html#c.gfp_t" title="gfp_t">gfp_t</a><em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_buf_acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a TIPC message buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">size</span></code></dt>
<dd>message size (including TIPC header)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Return</strong></p>
<p>a new buffer with data pointers set to the specified size.</p>
<p><strong>NOTE</strong></p>
<p>Headroom is reserved to allow prepending of a data link header.
There may also be unrequested tailroom present at the buffer’s end.</p>
<dl class="function">
<dt id="c.tipc_msg_append">
int <code class="descname">tipc_msg_append</code><span class="sig-paren">(</span>struct tipc_msg<em>&nbsp;*_hdr</em>, struct msghdr<em>&nbsp;*m</em>, int<em>&nbsp;dlen</em>, int<em>&nbsp;mss</em>, struct sk_buff_head<em>&nbsp;*txq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_msg_append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append data to tail of an existing buffer queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_msg</span> <span class="pre">*_hdr</span></code></dt>
<dd>header to be used</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>the data to be appended</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dlen</span></code></dt>
<dd>size of data to be appended</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mss</span></code></dt>
<dd>max allowable size of buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*txq</span></code></dt>
<dd>queue to append to</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of 1k blocks appended or errno value</p>
<dl class="function">
<dt id="c.tipc_msg_fragment">
int <code class="descname">tipc_msg_fragment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, const struct tipc_msg<em>&nbsp;*hdr</em>, int<em>&nbsp;pktmax</em>, struct sk_buff_head<em>&nbsp;*frags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_msg_fragment" title="Permalink to this definition">¶</a></dt>
<dd><p>build a fragment skb list for TIPC message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>TIPC message skb</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">tipc_msg</span> <span class="pre">*hdr</span></code></dt>
<dd>internal msg header to be put on the top of the fragments</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pktmax</span></code></dt>
<dd>max size of a fragment incl. the header</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*frags</span></code></dt>
<dd>returned fragment skb list</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if the fragmentation is successful, otherwise: -EINVAL
or -ENOMEM</p>
<dl class="function">
<dt id="c.tipc_msg_build">
int <code class="descname">tipc_msg_build</code><span class="sig-paren">(</span>struct tipc_msg<em>&nbsp;*mhdr</em>, struct msghdr<em>&nbsp;*m</em>, int<em>&nbsp;offset</em>, int<em>&nbsp;dsz</em>, int<em>&nbsp;pktmax</em>, struct sk_buff_head<em>&nbsp;*list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_msg_build" title="Permalink to this definition">¶</a></dt>
<dd><p>create buffer chain containing specified header and data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_msg</span> <span class="pre">*mhdr</span></code></dt>
<dd>Message header, to be prepended to data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>User message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>buffer offset for fragmented messages (FIXME)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dsz</span></code></dt>
<dd>Total length of user data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pktmax</span></code></dt>
<dd>Max packet size that can be used</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt>
<dd>Buffer or chain of buffers to be returned to caller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the recursive call we are making here is safe, since it can
logically go only one further level down.</p>
<p><strong>Return</strong></p>
<p>message data size or errno: -ENOMEM, -EFAULT</p>
<dl class="function">
<dt id="c.tipc_msg_bundle">
bool <code class="descname">tipc_msg_bundle</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*bskb</em>, struct tipc_msg<em>&nbsp;*msg</em>, u32<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_msg_bundle" title="Permalink to this definition">¶</a></dt>
<dd><p>Append contents of a buffer to tail of an existing one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*bskb</span></code></dt>
<dd>the bundle buffer to append to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_msg</span> <span class="pre">*msg</span></code></dt>
<dd>message to be appended</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">max</span></code></dt>
<dd>max allowable size for the bundle buffer</dd>
</dl>
<p><strong>Return</strong></p>
<p>“true” if bundling has been performed, otherwise “false”</p>
<dl class="function">
<dt id="c.tipc_msg_try_bundle">
bool <code class="descname">tipc_msg_try_bundle</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*tskb</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;**skb</em>, u32<em>&nbsp;mss</em>, u32<em>&nbsp;dnode</em>, bool<em>&nbsp;*new_bundle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_msg_try_bundle" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to bundle a new message to the last one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*tskb</span></code></dt>
<dd>the last/target message to which the new one will be appended</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**skb</span></code></dt>
<dd>the new message skb pointer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mss</span></code></dt>
<dd>max message size (header inclusive)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dnode</span></code></dt>
<dd>destination node for the message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*new_bundle</span></code></dt>
<dd>if this call made a new bundle or not</dd>
</dl>
<p><strong>Return</strong></p>
<p>“true” if the new message skb is potential for bundling this time or
later, in the case a bundling has been done this time, the skb is consumed
(the skb pointer = NULL).
Otherwise, “false” if the skb cannot be bundled at all.</p>
<dl class="function">
<dt id="c.tipc_msg_extract">
bool <code class="descname">tipc_msg_extract</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;**iskb</em>, int<em>&nbsp;*pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_msg_extract" title="Permalink to this definition">¶</a></dt>
<dd><p>extract bundled inner packet from buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>buffer to be extracted from.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**iskb</span></code></dt>
<dd>extracted inner buffer, to be returned</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*pos</span></code></dt>
<dd>position in outer message of msg to be extracted.
Returns position of next msg.
Consumes outer buffer when last packet extracted</dd>
</dl>
<p><strong>Return</strong></p>
<p>true when there is an extracted buffer, otherwise false</p>
<dl class="function">
<dt id="c.tipc_msg_reverse">
bool <code class="descname">tipc_msg_reverse</code><span class="sig-paren">(</span>u32<em>&nbsp;own_node</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;**skb</em>, int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_msg_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>swap source and destination addresses and add error code</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">own_node</span></code></dt>
<dd>originating node id for reversed message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**skb</span></code></dt>
<dd>buffer containing message to be reversed; will be consumed</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">err</span></code></dt>
<dd>error code to be set in message, if any
Replaces consumed buffer with new one when successful</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if success, otherwise false</p>
<dl class="function">
<dt id="c.tipc_msg_lookup_dest">
bool <code class="descname">tipc_msg_lookup_dest</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, int<em>&nbsp;*err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_msg_lookup_dest" title="Permalink to this definition">¶</a></dt>
<dd><p>try to find new destination for named message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>pointer to associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>the buffer containing the message.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*err</span></code></dt>
<dd>error code to be used by caller if lookup fails
Does not consume buffer</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if a destination is found, false otherwise</p>
</div>
<div class="section" id="tipc-name-interfaces">
<h3>TIPC Name Interfaces<a class="headerlink" href="#tipc-name-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.service_range">
struct <code class="descname">service_range</code><a class="headerlink" href="#c.service_range" title="Permalink to this definition">¶</a></dt>
<dd><p>container for all bindings of a service range</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct service_range {
  u32 lower;
  u32 upper;
  struct rb_node tree_node;
  u32 max;
  struct list_head local_publ;
  struct list_head all_publ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">lower</span></code></dt>
<dd>service range lower bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">upper</span></code></dt>
<dd>service range upper bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tree_node</span></code></dt>
<dd>member of service range RB tree</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max</span></code></dt>
<dd>largest ‘upper’ in this node subtree</dd>
<dt><code class="docutils literal notranslate"><span class="pre">local_publ</span></code></dt>
<dd>list of identical publications made from this node
Used by closest_first lookup and multicast lookup algorithm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">all_publ</span></code></dt>
<dd>all publications identical to this one, whatever node and scope
Used by round-robin lookup algorithm</dd>
</dl>
<dl class="type">
<dt id="c.tipc_service">
struct <code class="descname">tipc_service</code><a class="headerlink" href="#c.tipc_service" title="Permalink to this definition">¶</a></dt>
<dd><p>container for all published instances of a service type</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_service {
  u32 type;
  u32 publ_cnt;
  struct rb_root ranges;
  struct hlist_node service_list;
  struct list_head subscriptions;
  spinlock_t lock;
  struct rcu_head rcu;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt>
<dd>32 bit ‘type’ value for service</dd>
<dt><code class="docutils literal notranslate"><span class="pre">publ_cnt</span></code></dt>
<dd>increasing counter for publications in this service</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ranges</span></code></dt>
<dd>rb tree containing all service ranges for this service</dd>
<dt><code class="docutils literal notranslate"><span class="pre">service_list</span></code></dt>
<dd>links to adjacent name ranges in hash chain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subscriptions</span></code></dt>
<dd>list of subscriptions for this service type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt>
<dd>spinlock controlling access to pertaining service ranges/publications</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt>
<dd>RCU callback head used for deferred freeing</dd>
</dl>
<dl class="function">
<dt id="c.service_range_foreach_match">
<code class="descname">service_range_foreach_match</code><span class="sig-paren">(</span><em>sr</em>, <em>sc</em>, <em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.service_range_foreach_match" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over tipc service rbtree for each range match</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">sr</span></code></dt>
<dd>the service range pointer as a loop cursor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sc</span></code></dt>
<dd>the pointer to tipc service which holds the service range rbtree</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt>
<dd>beginning of the search range (end &gt;= start) for matching</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end</span></code></dt>
<dd>end of the search range (end &gt;= start) for matching</dd>
</dl>
<dl class="function">
<dt id="c.service_range_match_first">
struct <a class="reference internal" href="#c.service_range" title="service_range">service_range</a> * <code class="descname">service_range_match_first</code><span class="sig-paren">(</span>struct rb_node<em>&nbsp;*n</em>, u32<em>&nbsp;start</em>, u32<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.service_range_match_first" title="Permalink to this definition">¶</a></dt>
<dd><p>find first service range matching a range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rb_node</span> <span class="pre">*n</span></code></dt>
<dd>the root node of service range rbtree for searching</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">start</span></code></dt>
<dd>beginning of the search range (end &gt;= start) for matching</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">end</span></code></dt>
<dd>end of the search range (end &gt;= start) for matching</dd>
</dl>
<p><strong>Return</strong></p>
<p>the leftmost service range node in the rbtree that overlaps the
specific range if any. Otherwise, returns NULL.</p>
<dl class="function">
<dt id="c.service_range_match_next">
struct <a class="reference internal" href="#c.service_range" title="service_range">service_range</a> * <code class="descname">service_range_match_next</code><span class="sig-paren">(</span>struct rb_node<em>&nbsp;*n</em>, u32<em>&nbsp;start</em>, u32<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.service_range_match_next" title="Permalink to this definition">¶</a></dt>
<dd><p>find next service range matching a range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rb_node</span> <span class="pre">*n</span></code></dt>
<dd>a node in service range rbtree from which the searching starts</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">start</span></code></dt>
<dd>beginning of the search range (end &gt;= start) for matching</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">end</span></code></dt>
<dd>end of the search range (end &gt;= start) for matching</dd>
</dl>
<p><strong>Return</strong></p>
<p>the next service range node to the given node in the rbtree that
overlaps the specific range if any. Otherwise, returns NULL.</p>
<dl class="function">
<dt id="c.tipc_publ_create">
struct <a class="reference internal" href="#c.publication" title="publication">publication</a> * <code class="descname">tipc_publ_create</code><span class="sig-paren">(</span>struct tipc_uaddr<em>&nbsp;*ua</em>, struct tipc_socket_addr<em>&nbsp;*sk</em>, u32<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_publ_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a publication structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_uaddr</span> <span class="pre">*ua</span></code></dt>
<dd>the service range the user is binding to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_socket_addr</span> <span class="pre">*sk</span></code></dt>
<dd>the address of the socket that is bound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">key</span></code></dt>
<dd>publication key</dd>
</dl>
<dl class="function">
<dt id="c.tipc_service_create">
struct <a class="reference internal" href="#c.tipc_service" title="tipc_service">tipc_service</a> * <code class="descname">tipc_service_create</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct tipc_uaddr<em>&nbsp;*ua</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_service_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a service structure for the specified ‘type’</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_uaddr</span> <span class="pre">*ua</span></code></dt>
<dd>address representing the service to be bound</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a single range structure and sets it to all 0’s.</p>
<dl class="function">
<dt id="c.tipc_service_remove_publ">
struct <a class="reference internal" href="#c.publication" title="publication">publication</a> * <code class="descname">tipc_service_remove_publ</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.service_range" title="service_range">service_range</a><em>&nbsp;*r</em>, struct tipc_socket_addr<em>&nbsp;*sk</em>, u32<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_service_remove_publ" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a publication from a service</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">service_range</span> <span class="pre">*r</span></code></dt>
<dd>service_range to remove publication from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_socket_addr</span> <span class="pre">*sk</span></code></dt>
<dd>address publishing socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">key</span></code></dt>
<dd>target publication key</dd>
</dl>
<dl class="function">
<dt id="c.tipc_service_subscribe">
void <code class="descname">tipc_service_subscribe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_service" title="tipc_service">tipc_service</a><em>&nbsp;*service</em>, struct <a class="reference internal" href="#c.tipc_subscription" title="tipc_subscription">tipc_subscription</a><em>&nbsp;*sub</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_service_subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a subscription, and optionally issue the prescribed number of events if there is any service range overlapping with the requested range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_service</span> <span class="pre">*service</span></code></dt>
<dd>the tipc_service to attach the <strong>sub</strong> to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_subscription</span> <span class="pre">*sub</span></code></dt>
<dd>the subscription to attach</dd>
</dl>
<dl class="function">
<dt id="c.tipc_nametbl_lookup_anycast">
bool <code class="descname">tipc_nametbl_lookup_anycast</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct tipc_uaddr<em>&nbsp;*ua</em>, struct tipc_socket_addr<em>&nbsp;*sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_nametbl_lookup_anycast" title="Permalink to this definition">¶</a></dt>
<dd><p>perform service instance to socket translation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_uaddr</span> <span class="pre">*ua</span></code></dt>
<dd>service address to look up</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_socket_addr</span> <span class="pre">*sk</span></code></dt>
<dd>address to socket we want to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>On entry, a non-zero ‘sk-&gt;node’ indicates the node where we want lookup to be
performed, which may not be this one.</p>
<p>On exit:</p>
<ul class="simple">
<li>If lookup is deferred to another node, leave ‘sk-&gt;node’ unchanged and
return ‘true’.</li>
<li>If lookup is successful, set the ‘sk-&gt;node’ and ‘sk-&gt;ref’ (== portid) which
represent the bound socket and return ‘true’.</li>
<li>If lookup fails, return ‘false’</li>
</ul>
<p>Note that for legacy users (node configured with Z.C.N address format) the
‘closest-first’ lookup algorithm must be maintained, i.e., if sk.node is 0
we must look in the local binding list first</p>
<dl class="function">
<dt id="c.tipc_nametbl_withdraw">
void <code class="descname">tipc_nametbl_withdraw</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct tipc_uaddr<em>&nbsp;*ua</em>, struct tipc_socket_addr<em>&nbsp;*sk</em>, u32<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_nametbl_withdraw" title="Permalink to this definition">¶</a></dt>
<dd><p>withdraw a service binding</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_uaddr</span> <span class="pre">*ua</span></code></dt>
<dd>service address/range being unbound</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_socket_addr</span> <span class="pre">*sk</span></code></dt>
<dd>address of the socket being unbound from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">key</span></code></dt>
<dd>target publication key</dd>
</dl>
<dl class="function">
<dt id="c.tipc_nametbl_subscribe">
bool <code class="descname">tipc_nametbl_subscribe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_subscription" title="tipc_subscription">tipc_subscription</a><em>&nbsp;*sub</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_nametbl_subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>add a subscription object to the name table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_subscription</span> <span class="pre">*sub</span></code></dt>
<dd>subscription to add</dd>
</dl>
<dl class="function">
<dt id="c.tipc_nametbl_unsubscribe">
void <code class="descname">tipc_nametbl_unsubscribe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_subscription" title="tipc_subscription">tipc_subscription</a><em>&nbsp;*sub</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_nametbl_unsubscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a subscription object from name table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_subscription</span> <span class="pre">*sub</span></code></dt>
<dd>subscription to remove</dd>
</dl>
<dl class="function">
<dt id="c.tipc_service_delete">
void <code class="descname">tipc_service_delete</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.tipc_service" title="tipc_service">tipc_service</a><em>&nbsp;*sc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_service_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>purge all publications for a service and delete it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_service</span> <span class="pre">*sc</span></code></dt>
<dd>tipc_service to delete</dd>
</dl>
<dl class="function">
<dt id="c.publ_to_item">
void <code class="descname">publ_to_item</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.distr_item" title="distr_item">distr_item</a><em>&nbsp;*i</em>, struct <a class="reference internal" href="#c.publication" title="publication">publication</a><em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.publ_to_item" title="Permalink to this definition">¶</a></dt>
<dd><p>add publication info to a publication message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">distr_item</span> <span class="pre">*i</span></code></dt>
<dd>location of item in the message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">publication</span> <span class="pre">*p</span></code></dt>
<dd>publication info</dd>
</dl>
<dl class="function">
<dt id="c.named_prepare_buf">
struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">named_prepare_buf</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, u32<em>&nbsp;type</em>, u32<em>&nbsp;size</em>, u32<em>&nbsp;dest</em><span class="sig-paren">)</span><a class="headerlink" href="#c.named_prepare_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate &amp; initialize a publication message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">type</span></code></dt>
<dd>message type</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">size</span></code></dt>
<dd>payload size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dest</span></code></dt>
<dd>destination node</dd>
</dl>
<p><strong>Description</strong></p>
<p>The buffer returned is of size INT_H_SIZE + payload size</p>
<dl class="function">
<dt id="c.tipc_named_publish">
struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">tipc_named_publish</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.publication" title="publication">publication</a><em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_named_publish" title="Permalink to this definition">¶</a></dt>
<dd><p>tell other nodes about a new publication by this node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">publication</span> <span class="pre">*p</span></code></dt>
<dd>the new publication</dd>
</dl>
<dl class="function">
<dt id="c.tipc_named_withdraw">
struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">tipc_named_withdraw</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.publication" title="publication">publication</a><em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_named_withdraw" title="Permalink to this definition">¶</a></dt>
<dd><p>tell other nodes about a withdrawn publication by this node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">publication</span> <span class="pre">*p</span></code></dt>
<dd>the withdrawn publication</dd>
</dl>
<dl class="function">
<dt id="c.named_distribute">
void <code class="descname">named_distribute</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct sk_buff_head<em>&nbsp;*list</em>, u32<em>&nbsp;dnode</em>, struct list_head<em>&nbsp;*pls</em>, u16<em>&nbsp;seqno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.named_distribute" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare name info for bulk distribution to another node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt>
<dd>list of messages (buffers) to be returned from this function</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dnode</span></code></dt>
<dd>node to be updated</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*pls</span></code></dt>
<dd>linked list of publication items to be packed into buffer chain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">seqno</span></code></dt>
<dd>sequence number for this message</dd>
</dl>
<dl class="function">
<dt id="c.tipc_named_node_up">
void <code class="descname">tipc_named_node_up</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, u32<em>&nbsp;dnode</em>, u16<em>&nbsp;capabilities</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_named_node_up" title="Permalink to this definition">¶</a></dt>
<dd><p>tell specified node about all publications by this node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dnode</span></code></dt>
<dd>destination node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">capabilities</span></code></dt>
<dd>peer node’s capabilities</dd>
</dl>
<dl class="function">
<dt id="c.tipc_publ_purge">
void <code class="descname">tipc_publ_purge</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.publication" title="publication">publication</a><em>&nbsp;*p</em>, u32<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_publ_purge" title="Permalink to this definition">¶</a></dt>
<dd><p>remove publication associated with a failed node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">publication</span> <span class="pre">*p</span></code></dt>
<dd>the publication to remove</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">addr</span></code></dt>
<dd>failed node’s address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoked for each publication issued by a newly failed node.
Removes publication structure from name table &amp; deletes it.</p>
<dl class="function">
<dt id="c.tipc_update_nametbl">
bool <code class="descname">tipc_update_nametbl</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.distr_item" title="distr_item">distr_item</a><em>&nbsp;*i</em>, u32<em>&nbsp;node</em>, u32<em>&nbsp;dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_update_nametbl" title="Permalink to this definition">¶</a></dt>
<dd><p>try to process a nametable update and notify subscribers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">distr_item</span> <span class="pre">*i</span></code></dt>
<dd>location of item in the message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">node</span></code></dt>
<dd>node address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dtype</span></code></dt>
<dd>name distributor message type</dd>
</dl>
<p><strong>Description</strong></p>
<p>tipc_nametbl_lock must be held.</p>
<p><strong>Return</strong></p>
<p>the publication item if successful, otherwise NULL.</p>
<dl class="function">
<dt id="c.tipc_named_rcv">
void <code class="descname">tipc_named_rcv</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct sk_buff_head<em>&nbsp;*namedq</em>, u16<em>&nbsp;*rcv_nxt</em>, bool<em>&nbsp;*open</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_named_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>process name table update messages sent by another node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*namedq</span></code></dt>
<dd>queue to receive from</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*rcv_nxt</span></code></dt>
<dd>store last received seqno here</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*open</span></code></dt>
<dd>last bulk msg was received (FIXME)</dd>
</dl>
<dl class="function">
<dt id="c.tipc_named_reinit">
void <code class="descname">tipc_named_reinit</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_named_reinit" title="Permalink to this definition">¶</a></dt>
<dd><p>re-initialize local publications</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called whenever TIPC networking is enabled.
All name table entries published by this node are updated to reflect
the node’s new network address.</p>
</div>
<div class="section" id="tipc-node-management-interfaces">
<h3>TIPC Node Management Interfaces<a class="headerlink" href="#tipc-node-management-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.tipc_node">
struct <code class="descname">tipc_node</code><a class="headerlink" href="#c.tipc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>TIPC node structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_node {
  u32 addr;
  struct kref kref;
  rwlock_t lock;
  struct net *net;
  struct hlist_node hash;
  int active_links[2];
  struct tipc_link_entry links[MAX_BEARERS];
  struct tipc_bclink_entry bc_entry;
  int action_flags;
  struct list_head list;
  int state;
  bool preliminary;
  bool failover_sent;
  u16 sync_point;
  int link_cnt;
  u16 working_links;
  u16 capabilities;
  u32 signature;
  u32 link_id;
  u8 peer_id[16];
  char peer_id_string[NODE_ID_STR_LEN];
  struct list_head publ_list;
  struct list_head conn_sks;
  unsigned long keepalive_intv;
  struct timer_list timer;
  struct rcu_head rcu;
  unsigned long delete_at;
  struct net *peer_net;
  u32 peer_hash_mix;
#ifdef CONFIG_TIPC_CRYPTO;
  struct tipc_crypto *crypto_rx;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt>
<dd>network address of node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt>
<dd>reference counter to node object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt>
<dd>rwlock governing access to structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hash</span></code></dt>
<dd>links to adjacent nodes in unsorted hash chain</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_links</span></code></dt>
<dd>bearer ids of active links, used as index into links[] array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">links</span></code></dt>
<dd>array containing references to all links to node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bc_entry</span></code></dt>
<dd>broadcast link entry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">action_flags</span></code></dt>
<dd>bit mask of different types of node actions</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt>
<dd>links to adjacent nodes in sorted list of cluster’s nodes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt>
<dd>connectivity state vs peer node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">preliminary</span></code></dt>
<dd>a preliminary node or not</dd>
<dt><code class="docutils literal notranslate"><span class="pre">failover_sent</span></code></dt>
<dd>failover sent or not</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync_point</span></code></dt>
<dd>sequence number where synch/failover is finished</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_cnt</span></code></dt>
<dd>number of links to node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">working_links</span></code></dt>
<dd>number of working links to node (both active and standby)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capabilities</span></code></dt>
<dd>bitmap, indicating peer node’s functional capabilities</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signature</span></code></dt>
<dd>node instance identifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_id</span></code></dt>
<dd>local and remote bearer ids of changing link, if any</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_id</span></code></dt>
<dd>128-bit ID of peer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_id_string</span></code></dt>
<dd>ID string of peer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">publ_list</span></code></dt>
<dd>list of publications</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn_sks</span></code></dt>
<dd>list of connections (FIXME)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keepalive_intv</span></code></dt>
<dd>keepalive interval in milliseconds</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer</span></code></dt>
<dd>node’s keepalive timer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt>
<dd>rcu struct for tipc_node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delete_at</span></code></dt>
<dd>indicates the time for deleting a down node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_net</span></code></dt>
<dd>peer’s net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_hash_mix</span></code></dt>
<dd>hash for this peer (FIXME)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crypto_rx</span></code></dt>
<dd>RX crypto handler</dd>
</dl>
<dl class="function">
<dt id="c.tipc_node_crypto_rx">
struct <a class="reference internal" href="#c.tipc_crypto" title="tipc_crypto">tipc_crypto</a> * <code class="descname">tipc_node_crypto_rx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_node" title="tipc_node">tipc_node</a><em>&nbsp;*__n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_node_crypto_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve crypto RX handle from node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_node</span> <span class="pre">*__n</span></code></dt>
<dd>target tipc_node</dd>
</dl>
<p><strong>Note</strong></p>
<p>node ref counter must be held first!</p>
<dl class="function">
<dt id="c.__tipc_node_link_up">
void <code class="descname">__tipc_node_link_up</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_node" title="tipc_node">tipc_node</a><em>&nbsp;*n</em>, int<em>&nbsp;bearer_id</em>, struct sk_buff_head<em>&nbsp;*xmitq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__tipc_node_link_up" title="Permalink to this definition">¶</a></dt>
<dd><p>handle addition of link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_node</span> <span class="pre">*n</span></code></dt>
<dd>target tipc_node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bearer_id</span></code></dt>
<dd>id of the bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>queue for messages to be xmited on
Node lock must be held by caller
Link becomes active (alone or shared) or standby, depending on its priority.</dd>
</dl>
<dl class="function">
<dt id="c.tipc_node_link_up">
void <code class="descname">tipc_node_link_up</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_node" title="tipc_node">tipc_node</a><em>&nbsp;*n</em>, int<em>&nbsp;bearer_id</em>, struct sk_buff_head<em>&nbsp;*xmitq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_node_link_up" title="Permalink to this definition">¶</a></dt>
<dd><p>handle addition of link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_node</span> <span class="pre">*n</span></code></dt>
<dd>target tipc_node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bearer_id</span></code></dt>
<dd>id of the bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>queue for messages to be xmited on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Link becomes active (alone or shared) or standby, depending on its priority.</p>
<dl class="function">
<dt id="c.tipc_node_link_failover">
void <code class="descname">tipc_node_link_failover</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_node" title="tipc_node">tipc_node</a><em>&nbsp;*n</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*l</em>, struct <a class="reference internal" href="#c.tipc_link" title="tipc_link">tipc_link</a><em>&nbsp;*tnl</em>, struct sk_buff_head<em>&nbsp;*xmitq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_node_link_failover" title="Permalink to this definition">¶</a></dt>
<dd><p>start failover in case “half-failover”</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_node</span> <span class="pre">*n</span></code></dt>
<dd>tipc node structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*l</span></code></dt>
<dd>link peer endpoint failingover (- can be NULL)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_link</span> <span class="pre">*tnl</span></code></dt>
<dd>tunnel link</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>queue for messages to be xmited on tnl link later</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is only called in a very special situation where link
failover can be already started on peer node but not on this node.
This can happen when e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1. Both links &lt;1A-2A&gt;, &lt;1B-2B&gt; down
2. Link endpoint 2A up, but 1A still down (e.g. due to network
disturbance, wrong session, etc.)
3. Link &lt;1B-2B&gt; up
4. Link endpoint 2A down (e.g. due to link tolerance timeout)
5. Node 2 starts failover onto link &lt;1B-2B&gt;

==&gt; Node 1 does never start link/node failover!
</pre></div>
</div>
<dl class="function">
<dt id="c.__tipc_node_link_down">
void <code class="descname">__tipc_node_link_down</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_node" title="tipc_node">tipc_node</a><em>&nbsp;*n</em>, int<em>&nbsp;*bearer_id</em>, struct sk_buff_head<em>&nbsp;*xmitq</em>, struct <a class="reference internal" href="#c.tipc_media_addr" title="tipc_media_addr">tipc_media_addr</a><em>&nbsp;**maddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__tipc_node_link_down" title="Permalink to this definition">¶</a></dt>
<dd><p>handle loss of link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_node</span> <span class="pre">*n</span></code></dt>
<dd>target tipc_node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*bearer_id</span></code></dt>
<dd>id of the bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>queue for messages to be xmited on</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_media_addr</span> <span class="pre">**maddr</span></code></dt>
<dd>output media address of the bearer</dd>
</dl>
<dl class="function">
<dt id="c.tipc_node_get_linkname">
int <code class="descname">tipc_node_get_linkname</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, u32<em>&nbsp;bearer_id</em>, u32<em>&nbsp;addr</em>, char<em>&nbsp;*linkname</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_node_get_linkname" title="Permalink to this definition">¶</a></dt>
<dd><p>get the name of a link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">bearer_id</span></code></dt>
<dd>id of the bearer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">addr</span></code></dt>
<dd>peer node address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*linkname</span></code></dt>
<dd>link name output buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>size of <strong>linkname</strong> output buffer</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success</p>
<dl class="function">
<dt id="c.tipc_node_xmit">
int <code class="descname">tipc_node_xmit</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct sk_buff_head<em>&nbsp;*list</em>, u32<em>&nbsp;dnode</em>, int<em>&nbsp;selector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_node_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>general link level function for message sending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt>
<dd>chain of buffers containing message</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dnode</span></code></dt>
<dd>address of destination node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">selector</span></code></dt>
<dd>a number used for deterministic link selection
Consumes the buffer chain.</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if success, otherwise: -ELINKCONG,-EHOSTUNREACH,-EMSGSIZE,-ENOBUF</p>
<dl class="function">
<dt id="c.tipc_node_bc_rcv">
void <code class="descname">tipc_node_bc_rcv</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, int<em>&nbsp;bearer_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_node_bc_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>process TIPC broadcast packet arriving from off-node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>TIPC packet</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bearer_id</span></code></dt>
<dd>id of bearer message arrived on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoked with no locks held.</p>
<dl class="function">
<dt id="c.tipc_node_check_state">
bool <code class="descname">tipc_node_check_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_node" title="tipc_node">tipc_node</a><em>&nbsp;*n</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, int<em>&nbsp;bearer_id</em>, struct sk_buff_head<em>&nbsp;*xmitq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_node_check_state" title="Permalink to this definition">¶</a></dt>
<dd><p>check and if necessary update node state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_node</span> <span class="pre">*n</span></code></dt>
<dd>target tipc_node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>TIPC packet</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bearer_id</span></code></dt>
<dd>identity of bearer delivering the packet</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>queue for messages to be xmited on</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if state and msg are ok, otherwise false</p>
<dl class="function">
<dt id="c.tipc_rcv">
void <code class="descname">tipc_rcv</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct <a class="reference internal" href="#c.tipc_bearer" title="tipc_bearer">tipc_bearer</a><em>&nbsp;*b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>process TIPC packets/messages arriving from off-node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>TIPC packet</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_bearer</span> <span class="pre">*b</span></code></dt>
<dd>pointer to bearer message arrived on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoked with no locks held. Bearer pointer must point to a valid bearer
structure (i.e. cannot be NULL), but bearer can be inactive.</p>
<dl class="function">
<dt id="c.tipc_node_dump">
int <code class="descname">tipc_node_dump</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_node" title="tipc_node">tipc_node</a><em>&nbsp;*n</em>, bool<em>&nbsp;more</em>, char<em>&nbsp;*buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_node_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>dump TIPC node data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_node</span> <span class="pre">*n</span></code></dt>
<dd>tipc node to be dumped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">more</span></code></dt>
<dd>dump more?
- false: dump only tipc node data
- true: dump node link data as well</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt>
<dd>returned buffer of dump data in format</dd>
</dl>
</div>
<div class="section" id="tipc-socket-interfaces">
<h3>TIPC Socket Interfaces<a class="headerlink" href="#tipc-socket-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.tipc_sock">
struct <code class="descname">tipc_sock</code><a class="headerlink" href="#c.tipc_sock" title="Permalink to this definition">¶</a></dt>
<dd><p>TIPC socket structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_sock {
  struct sock sk;
  u32 max_pkt;
  u32 maxnagle;
  u32 portid;
  struct tipc_msg phdr;
  struct list_head cong_links;
  struct list_head publications;
  u32 pub_count;
  atomic_t dupl_rcvcnt;
  u16 conn_timeout;
  bool probe_unacked;
  u16 cong_link_cnt;
  u16 snt_unacked;
  u16 snd_win;
  u16 peer_caps;
  u16 rcv_unacked;
  u16 rcv_win;
  struct sockaddr_tipc peer;
  struct rhash_head node;
  struct tipc_mc_method mc_method;
  struct rcu_head rcu;
  struct tipc_group *group;
  u32 oneway;
  u32 nagle_start;
  u16 snd_backlog;
  u16 msg_acc;
  u16 pkt_cnt;
  bool expect_ack;
  bool nodelay;
  bool group_is_open;
  bool published;
  u8 conn_addrtype;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">sk</span></code></dt>
<dd>socket - interacts with ‘port’ and with user via the socket API</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_pkt</span></code></dt>
<dd>maximum packet size “hint” used when building messages sent by port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">maxnagle</span></code></dt>
<dd>maximum size of msg which can be subject to nagle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">portid</span></code></dt>
<dd>unique port identity in TIPC socket hash table</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phdr</span></code></dt>
<dd>preformatted message header used when sending messages</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cong_links</span></code></dt>
<dd>list of congested links</dd>
<dt><code class="docutils literal notranslate"><span class="pre">publications</span></code></dt>
<dd>list of publications for port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pub_count</span></code></dt>
<dd>total # of publications port has made during its lifetime</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dupl_rcvcnt</span></code></dt>
<dd>number of bytes counted twice, in both backlog and rcv queue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn_timeout</span></code></dt>
<dd>the time we can wait for an unresponded setup request</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_unacked</span></code></dt>
<dd>probe has not received ack yet</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cong_link_cnt</span></code></dt>
<dd>number of congested links</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snt_unacked</span></code></dt>
<dd># messages sent by socket, and not yet acked by peer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_win</span></code></dt>
<dd>send window size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer_caps</span></code></dt>
<dd>peer capabilities mask</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcv_unacked</span></code></dt>
<dd># messages read by user, but not yet acked back to peer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcv_win</span></code></dt>
<dd>receive window size</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer</span></code></dt>
<dd>‘connected’ peer for dgram/rdm</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt>
<dd>hash table node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mc_method</span></code></dt>
<dd>cookie for use between socket and broadcast layer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt>
<dd>rcu struct for tipc_sock</dd>
<dt><code class="docutils literal notranslate"><span class="pre">group</span></code></dt>
<dd>TIPC communications group</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oneway</span></code></dt>
<dd>message count in one direction (FIXME)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nagle_start</span></code></dt>
<dd>current nagle value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_backlog</span></code></dt>
<dd>send backlog count</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg_acc</span></code></dt>
<dd>messages accepted; used in managing backlog and nagle</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pkt_cnt</span></code></dt>
<dd>TIPC socket packet count</dd>
<dt><code class="docutils literal notranslate"><span class="pre">expect_ack</span></code></dt>
<dd>whether this TIPC socket is expecting an ack</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nodelay</span></code></dt>
<dd>setsockopt() TIPC_NODELAY setting</dd>
<dt><code class="docutils literal notranslate"><span class="pre">group_is_open</span></code></dt>
<dd>TIPC socket group is fully open (FIXME)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">published</span></code></dt>
<dd>true if port has one or more associated names</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn_addrtype</span></code></dt>
<dd>address type used when establishing connection</dd>
</dl>
<dl class="function">
<dt id="c.tsk_advance_rx_queue">
void <code class="descname">tsk_advance_rx_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tsk_advance_rx_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>discard first buffer in socket receive queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>network socket</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must hold socket lock</p>
<dl class="function">
<dt id="c.tsk_rej_rx_queue">
void <code class="descname">tsk_rej_rx_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em>, int<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tsk_rej_rx_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>reject all buffers in socket receive queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>network socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">error</span></code></dt>
<dd>response error code</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must hold socket lock</p>
<dl class="function">
<dt id="c.tipc_sk_create">
int <code class="descname">tipc_sk_create</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, int<em>&nbsp;protocol</em>, int<em>&nbsp;kern</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a TIPC socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>network namespace (must be default network)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>pre-allocated socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt>
<dd>protocol indicator (must be 0)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kern</span></code></dt>
<dd>caused by kernel or by userspace?</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine creates additional data structures used by the TIPC socket,
initializes them, and links them together.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<dl class="function">
<dt id="c.tipc_release">
int <code class="descname">tipc_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_release" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a TIPC socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket to destroy</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine cleans up any messages that are still queued on the socket.
For DGRAM and RDM socket types, all queued messages are rejected.
For SEQPACKET and STREAM socket types, the first message is rejected
and any others are discarded.  (If the first message on a STREAM socket
is partially-read, it is discarded and the next one is rejected instead.)</p>
<p><strong>NOTE</strong></p>
<p>Rejected messages are not necessarily returned to the sender!  They
are returned or discarded according to the “destination droppable” setting
specified for the message by the sender.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<dl class="function">
<dt id="c.__tipc_bind">
int <code class="descname">__tipc_bind</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct sockaddr<em>&nbsp;*skaddr</em>, int<em>&nbsp;alen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__tipc_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>associate or disassocate TIPC name(s) with a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*skaddr</span></code></dt>
<dd>socket address describing name(s) and desired operation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">alen</span></code></dt>
<dd>size of socket address data structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Name and name sequence binding are indicated using a positive scope value;
a negative scope value unbinds the specified name.  Specifying no name
(i.e. a socket address length of 0) unbinds all names from the socket.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<p><strong>NOTE</strong></p>
<dl class="docutils">
<dt>This routine doesn’t need to take the socket lock since it doesn’t</dt>
<dd>access any non-constant socket information.</dd>
</dl>
<dl class="function">
<dt id="c.tipc_getname">
int <code class="descname">tipc_getname</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct sockaddr<em>&nbsp;*uaddr</em>, int<em>&nbsp;peer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_getname" title="Permalink to this definition">¶</a></dt>
<dd><p>get port ID of socket or peer socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*uaddr</span></code></dt>
<dd>area for returned socket address</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">peer</span></code></dt>
<dd>0 = own ID, 1 = current peer ID, 2 = current/former peer ID</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<p><strong>NOTE</strong></p>
<dl class="docutils">
<dt>This routine doesn’t need to take the socket lock since it only</dt>
<dd>accesses socket information that is unchanging (or which changes in
a completely predictable manner).</dd>
</dl>
<dl class="function">
<dt id="c.tipc_poll">
__poll_t <code class="descname">tipc_poll</code><span class="sig-paren">(</span>struct file<em>&nbsp;*file</em>, struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, poll_table<em>&nbsp;*wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>read and possibly block on pollmask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt>
<dd>file structure associated with the socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket for which to calculate the poll bits</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*wait</span></code></dt>
<dd>???</dd>
</dl>
<p><strong>Return</strong></p>
<p>pollmask value</p>
<p><strong>Description</strong></p>
<p>COMMENTARY:
It appears that the usual socket locking mechanisms are not useful here
since the pollmask info is potentially out-of-date the moment this routine
exits.  TCP and other protocols seem to rely on higher level poll routines
to handle any preventable race conditions, so TIPC will do the same …</p>
<p>IMPORTANT: The fact that a read or write operation is indicated does NOT
imply that the operation will succeed, merely that it should be performed
and will not block.</p>
<dl class="function">
<dt id="c.tipc_sendmcast">
int <code class="descname">tipc_sendmcast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct tipc_uaddr<em>&nbsp;*ua</em>, struct msghdr<em>&nbsp;*msg</em>, size_t<em>&nbsp;dlen</em>, long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sendmcast" title="Permalink to this definition">¶</a></dt>
<dd><p>send multicast message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_uaddr</span> <span class="pre">*ua</span></code></dt>
<dd>destination address struct</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg</span></code></dt>
<dd>message to send</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">dlen</span></code></dt>
<dd>length of data to send</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>timeout to wait for wakeup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from function <a class="reference internal" href="#c.tipc_sendmsg" title="tipc_sendmsg"><code class="xref c c-func docutils literal notranslate"><span class="pre">tipc_sendmsg()</span></code></a>, which has done all sanity checks</p>
<p><strong>Return</strong></p>
<p>the number of bytes sent on success, or errno</p>
<dl class="function">
<dt id="c.tipc_send_group_msg">
int <code class="descname">tipc_send_group_msg</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct <a class="reference internal" href="#c.tipc_sock" title="tipc_sock">tipc_sock</a><em>&nbsp;*tsk</em>, struct msghdr<em>&nbsp;*m</em>, struct tipc_member<em>&nbsp;*mb</em>, u32<em>&nbsp;dnode</em>, u32<em>&nbsp;dport</em>, int<em>&nbsp;dlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_send_group_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>send a message to a member in the group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_sock</span> <span class="pre">*tsk</span></code></dt>
<dd>tipc socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>message to send</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_member</span> <span class="pre">*mb</span></code></dt>
<dd>group member</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dnode</span></code></dt>
<dd>destination node</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dport</span></code></dt>
<dd>destination port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dlen</span></code></dt>
<dd>total length of message data</dd>
</dl>
<dl class="function">
<dt id="c.tipc_send_group_unicast">
int <code class="descname">tipc_send_group_unicast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct msghdr<em>&nbsp;*m</em>, int<em>&nbsp;dlen</em>, long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_send_group_unicast" title="Permalink to this definition">¶</a></dt>
<dd><p>send message to a member in the group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>message to send</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dlen</span></code></dt>
<dd>total length of message data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>timeout to wait for wakeup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from function <a class="reference internal" href="#c.tipc_sendmsg" title="tipc_sendmsg"><code class="xref c c-func docutils literal notranslate"><span class="pre">tipc_sendmsg()</span></code></a>, which has done all sanity checks</p>
<p><strong>Return</strong></p>
<p>the number of bytes sent on success, or errno</p>
<dl class="function">
<dt id="c.tipc_send_group_anycast">
int <code class="descname">tipc_send_group_anycast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct msghdr<em>&nbsp;*m</em>, int<em>&nbsp;dlen</em>, long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_send_group_anycast" title="Permalink to this definition">¶</a></dt>
<dd><p>send message to any member with given identity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>message to send</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dlen</span></code></dt>
<dd>total length of message data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>timeout to wait for wakeup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from function <a class="reference internal" href="#c.tipc_sendmsg" title="tipc_sendmsg"><code class="xref c c-func docutils literal notranslate"><span class="pre">tipc_sendmsg()</span></code></a>, which has done all sanity checks</p>
<p><strong>Return</strong></p>
<p>the number of bytes sent on success, or errno</p>
<dl class="function">
<dt id="c.tipc_send_group_bcast">
int <code class="descname">tipc_send_group_bcast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct msghdr<em>&nbsp;*m</em>, int<em>&nbsp;dlen</em>, long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_send_group_bcast" title="Permalink to this definition">¶</a></dt>
<dd><p>send message to all members in communication group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>message to send</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dlen</span></code></dt>
<dd>total length of message data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>timeout to wait for wakeup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from function <a class="reference internal" href="#c.tipc_sendmsg" title="tipc_sendmsg"><code class="xref c c-func docutils literal notranslate"><span class="pre">tipc_sendmsg()</span></code></a>, which has done all sanity checks</p>
<p><strong>Return</strong></p>
<p>the number of bytes sent on success, or errno</p>
<dl class="function">
<dt id="c.tipc_send_group_mcast">
int <code class="descname">tipc_send_group_mcast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct msghdr<em>&nbsp;*m</em>, int<em>&nbsp;dlen</em>, long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_send_group_mcast" title="Permalink to this definition">¶</a></dt>
<dd><p>send message to all members with given identity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>message to send</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dlen</span></code></dt>
<dd>total length of message data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>timeout to wait for wakeup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from function <a class="reference internal" href="#c.tipc_sendmsg" title="tipc_sendmsg"><code class="xref c c-func docutils literal notranslate"><span class="pre">tipc_sendmsg()</span></code></a>, which has done all sanity checks</p>
<p><strong>Return</strong></p>
<p>the number of bytes sent on success, or errno</p>
<dl class="function">
<dt id="c.tipc_sk_mcast_rcv">
void <code class="descname">tipc_sk_mcast_rcv</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct sk_buff_head<em>&nbsp;*arrvq</em>, struct sk_buff_head<em>&nbsp;*inputq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_mcast_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>Deliver multicast messages to all destination sockets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*arrvq</span></code></dt>
<dd>queue with arriving messages, to be cloned after destination lookup</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*inputq</span></code></dt>
<dd>queue with cloned messages, delivered to socket after dest lookup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Multi-threaded: parallel calls with reference to same queues may occur</p>
<dl class="function">
<dt id="c.tipc_sk_conn_proto_rcv">
void <code class="descname">tipc_sk_conn_proto_rcv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_sock" title="tipc_sock">tipc_sock</a><em>&nbsp;*tsk</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct sk_buff_head<em>&nbsp;*inputq</em>, struct sk_buff_head<em>&nbsp;*xmitq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_conn_proto_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>receive a connection mng protocol message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_sock</span> <span class="pre">*tsk</span></code></dt>
<dd>receiving socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>pointer to message buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*inputq</span></code></dt>
<dd>buffer list containing the buffers</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>output message area</dd>
</dl>
<dl class="function">
<dt id="c.tipc_sendmsg">
int <code class="descname">tipc_sendmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct msghdr<em>&nbsp;*m</em>, size_t<em>&nbsp;dsz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sendmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>send message in connectionless manner</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>message to send</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">dsz</span></code></dt>
<dd>amount of user data to be sent</dd>
</dl>
<p><strong>Description</strong></p>
<p>Message must have an destination specified explicitly.
Used for SOCK_RDM and SOCK_DGRAM messages,
and for ‘SYN’ messages on SOCK_SEQPACKET and SOCK_STREAM connections.
(Note: ‘SYN+’ is prohibited on SOCK_STREAM.)</p>
<p><strong>Return</strong></p>
<p>the number of bytes sent on success, or errno otherwise</p>
<dl class="function">
<dt id="c.tipc_sendstream">
int <code class="descname">tipc_sendstream</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct msghdr<em>&nbsp;*m</em>, size_t<em>&nbsp;dsz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sendstream" title="Permalink to this definition">¶</a></dt>
<dd><p>send stream-oriented data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>data to send</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">dsz</span></code></dt>
<dd>total length of data to be transmitted</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used for SOCK_STREAM data.</p>
<p><strong>Return</strong></p>
<p>the number of bytes sent on success (or partial success),
or errno if no data sent</p>
<dl class="function">
<dt id="c.tipc_send_packet">
int <code class="descname">tipc_send_packet</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct msghdr<em>&nbsp;*m</em>, size_t<em>&nbsp;dsz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_send_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>send a connection-oriented message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>message to send</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">dsz</span></code></dt>
<dd>length of data to be transmitted</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used for SOCK_SEQPACKET messages.</p>
<p><strong>Return</strong></p>
<p>the number of bytes sent on success, or errno otherwise</p>
<dl class="function">
<dt id="c.tipc_sk_set_orig_addr">
void <code class="descname">tipc_sk_set_orig_addr</code><span class="sig-paren">(</span>struct msghdr<em>&nbsp;*m</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_set_orig_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>capture sender’s address for received message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>descriptor for message info</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>received message</dd>
</dl>
<p><strong>Note</strong></p>
<p>Address is not captured if not requested by receiver.</p>
<dl class="function">
<dt id="c.tipc_sk_anc_data_recv">
int <code class="descname">tipc_sk_anc_data_recv</code><span class="sig-paren">(</span>struct msghdr<em>&nbsp;*m</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct <a class="reference internal" href="#c.tipc_sock" title="tipc_sock">tipc_sock</a><em>&nbsp;*tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_anc_data_recv" title="Permalink to this definition">¶</a></dt>
<dd><p>optionally capture ancillary data for received message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>descriptor for message info</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>received message buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_sock</span> <span class="pre">*tsk</span></code></dt>
<dd>TIPC port associated with message</dd>
</dl>
<p><strong>Note</strong></p>
<p>Ancillary data is not captured if not requested by receiver.</p>
<p><strong>Return</strong></p>
<p>0 if successful, otherwise errno</p>
<dl class="function">
<dt id="c.tipc_recvmsg">
int <code class="descname">tipc_recvmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct msghdr<em>&nbsp;*m</em>, size_t<em>&nbsp;buflen</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_recvmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>receive packet-oriented message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>network socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>descriptor for message info</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">buflen</span></code></dt>
<dd>length of user buffer area</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>receive flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used for SOCK_DGRAM, SOCK_RDM, and SOCK_SEQPACKET messages.
If the complete message doesn’t fit in user area, truncate it.</p>
<p><strong>Return</strong></p>
<p>size of returned message data, errno otherwise</p>
<dl class="function">
<dt id="c.tipc_recvstream">
int <code class="descname">tipc_recvstream</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct msghdr<em>&nbsp;*m</em>, size_t<em>&nbsp;buflen</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_recvstream" title="Permalink to this definition">¶</a></dt>
<dd><p>receive stream-oriented data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>network socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*m</span></code></dt>
<dd>descriptor for message info</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">buflen</span></code></dt>
<dd>total size of user buffer area</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>receive flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used for SOCK_STREAM messages only.  If not enough data is available
will optionally wait for more; never truncates data.</p>
<p><strong>Return</strong></p>
<p>size of returned message data, errno otherwise</p>
<dl class="function">
<dt id="c.tipc_write_space">
void <code class="descname">tipc_write_space</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_write_space" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up thread if port congestion is released</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>socket</dd>
</dl>
<dl class="function">
<dt id="c.tipc_data_ready">
void <code class="descname">tipc_data_ready</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_data_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up threads to indicate messages have been received</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>socket</dd>
</dl>
<dl class="function">
<dt id="c.tipc_sk_filter_connect">
bool <code class="descname">tipc_sk_filter_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tipc_sock" title="tipc_sock">tipc_sock</a><em>&nbsp;*tsk</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct sk_buff_head<em>&nbsp;*xmitq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_filter_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>check incoming message for a connection-based socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_sock</span> <span class="pre">*tsk</span></code></dt>
<dd>TIPC socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>pointer to message buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>for Nagle ACK if any</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if message should be added to receive queue, false otherwise</p>
<dl class="function">
<dt id="c.rcvbuf_limit">
unsigned int <code class="descname">rcvbuf_limit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcvbuf_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>get proper overload limit of socket receive queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>message</dd>
</dl>
<p><strong>Description</strong></p>
<p>For connection oriented messages, irrespective of importance,
default queue limit is 2 MB.</p>
<p>For connectionless messages, queue limits are based on message
importance as follows:</p>
<p>TIPC_LOW_IMPORTANCE       (2 MB)
TIPC_MEDIUM_IMPORTANCE    (4 MB)
TIPC_HIGH_IMPORTANCE      (8 MB)
TIPC_CRITICAL_IMPORTANCE  (16 MB)</p>
<p><strong>Return</strong></p>
<p>overload limit according to corresponding message importance</p>
<dl class="function">
<dt id="c.tipc_sk_filter_rcv">
void <code class="descname">tipc_sk_filter_rcv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, struct sk_buff_head<em>&nbsp;*xmitq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_filter_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>validate incoming message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>pointer to message.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>output message area (FIXME)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enqueues message on receive queue if acceptable; optionally handles
disconnect indication for a connected socket.</p>
<p>Called with socket lock already taken</p>
<dl class="function">
<dt id="c.tipc_sk_backlog_rcv">
int <code class="descname">tipc_sk_backlog_rcv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_backlog_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>handle incoming message from backlog queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>message</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must hold socket lock</p>
<dl class="function">
<dt id="c.tipc_sk_enqueue">
void <code class="descname">tipc_sk_enqueue</code><span class="sig-paren">(</span>struct sk_buff_head<em>&nbsp;*inputq</em>, struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em>, u32<em>&nbsp;dport</em>, struct sk_buff_head<em>&nbsp;*xmitq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_enqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>extract all buffers with destination ‘dport’ from inputq and try adding them to socket or backlog queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*inputq</span></code></dt>
<dd>list of incoming buffers with potentially different destinations</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>socket where the buffers should be enqueued</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dport</span></code></dt>
<dd>port number for the socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*xmitq</span></code></dt>
<dd>output queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must hold socket lock</p>
<dl class="function">
<dt id="c.tipc_sk_rcv">
void <code class="descname">tipc_sk_rcv</code><span class="sig-paren">(</span>struct net<em>&nbsp;*net</em>, struct sk_buff_head<em>&nbsp;*inputq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a chain of incoming buffers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt>
<dd>the associated network namespace</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*inputq</span></code></dt>
<dd>buffer list containing the buffers
Consumes all buffers in list until inputq is empty</dd>
</dl>
<p><strong>Note</strong></p>
<p>may be called in multiple threads referring to the same queue</p>
<dl class="function">
<dt id="c.tipc_connect">
int <code class="descname">tipc_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct sockaddr<em>&nbsp;*dest</em>, int<em>&nbsp;destlen</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>establish a connection to another TIPC port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*dest</span></code></dt>
<dd>socket address for destination port</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">destlen</span></code></dt>
<dd>size of socket address data structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>file-related flags associated with socket</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<dl class="function">
<dt id="c.tipc_listen">
int <code class="descname">tipc_listen</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_listen" title="Permalink to this definition">¶</a></dt>
<dd><p>allow socket to listen for incoming connections</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>(unused)</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<dl class="function">
<dt id="c.tipc_accept">
int <code class="descname">tipc_accept</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*new_sock</em>, int<em>&nbsp;flags</em>, bool<em>&nbsp;kern</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for connection request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>listening socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*new_sock</span></code></dt>
<dd>new socket that is to be connected</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>file-related flags associated with socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">kern</span></code></dt>
<dd>caused by kernel or by userspace?</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<dl class="function">
<dt id="c.tipc_shutdown">
int <code class="descname">tipc_shutdown</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, int<em>&nbsp;how</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown socket connection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">how</span></code></dt>
<dd>direction to close (must be SHUT_RDWR)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Terminates connection (if necessary), then purges socket’s receive queue.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<dl class="function">
<dt id="c.tipc_setsockopt">
int <code class="descname">tipc_setsockopt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, int<em>&nbsp;lvl</em>, int<em>&nbsp;opt</em>, sockptr_t<em>&nbsp;ov</em>, unsigned int<em>&nbsp;ol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_setsockopt" title="Permalink to this definition">¶</a></dt>
<dd><p>set socket option</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">lvl</span></code></dt>
<dd>option level</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">opt</span></code></dt>
<dd>option identifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sockptr_t</span> <span class="pre">ov</span></code></dt>
<dd>pointer to new option value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ol</span></code></dt>
<dd>length of option value</dd>
</dl>
<p><strong>Description</strong></p>
<p>For stream sockets only, accepts and ignores all IPPROTO_TCP options
(to ease compatibility).</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<dl class="function">
<dt id="c.tipc_getsockopt">
int <code class="descname">tipc_getsockopt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.socket" title="socket">socket</a><em>&nbsp;*sock</em>, int<em>&nbsp;lvl</em>, int<em>&nbsp;opt</em>, char __user<em>&nbsp;*ov</em>, int __user<em>&nbsp;*ol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_getsockopt" title="Permalink to this definition">¶</a></dt>
<dd><p>get socket option</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt>
<dd>socket structure</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">lvl</span></code></dt>
<dd>option level</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">opt</span></code></dt>
<dd>option identifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*ov</span></code></dt>
<dd>receptacle for option value</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">__user</span> <span class="pre">*ol</span></code></dt>
<dd>receptacle for length of option value</dd>
</dl>
<p><strong>Description</strong></p>
<p>For stream sockets only, returns 0 length result for all IPPROTO_TCP options
(to ease compatibility).</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<dl class="function">
<dt id="c.tipc_socket_init">
int <code class="descname">tipc_socket_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_socket_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize TIPC socket interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise</p>
<dl class="function">
<dt id="c.tipc_socket_stop">
void <code class="descname">tipc_socket_stop</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_socket_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stop TIPC socket interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.tipc_sk_filtering">
bool <code class="descname">tipc_sk_filtering</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_filtering" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a socket should be traced</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>the socket to be examined</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>sysctl_tipc_sk_filter</strong> is used as the socket tuple for filtering:
(portid, sock type, name type, name lower, name upper)</p>
<p><strong>Return</strong></p>
<p>true if the socket meets the socket tuple data
(value 0 = ‘any’) or when there is no tuple set (all = 0),
otherwise false</p>
<dl class="function">
<dt id="c.tipc_sk_overlimit1">
bool <code class="descname">tipc_sk_overlimit1</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_overlimit1" title="Permalink to this definition">¶</a></dt>
<dd><p>check if socket rx queue is about to be overloaded, both the rcv and backlog queues are considered</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>tipc sk to be checked</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>tipc msg to be checked</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the socket rx queue allocation is &gt; 90%, otherwise false</p>
<dl class="function">
<dt id="c.tipc_sk_overlimit2">
bool <code class="descname">tipc_sk_overlimit2</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_overlimit2" title="Permalink to this definition">¶</a></dt>
<dd><p>check if socket rx queue is about to be overloaded, only the rcv queue is considered</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>tipc sk to be checked</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>tipc msg to be checked</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the socket rx queue allocation is &gt; 90%, otherwise false</p>
<dl class="function">
<dt id="c.tipc_sk_dump">
int <code class="descname">tipc_sk_dump</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sock" title="sock">sock</a><em>&nbsp;*sk</em>, u16<em>&nbsp;dqueues</em>, char<em>&nbsp;*buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sk_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>dump TIPC socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt>
<dd>tipc sk to be dumped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">dqueues</span></code></dt>
<dd>bitmask to decide if any socket queue to be dumped?
- TIPC_DUMP_NONE: don’t dump socket queues
- TIPC_DUMP_SK_SNDQ: dump socket send queue
- TIPC_DUMP_SK_RCVQ: dump socket rcv queue
- TIPC_DUMP_SK_BKLGQ: dump socket backlog queue
- TIPC_DUMP_ALL: dump all the socket queues above</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt>
<dd>returned buffer of dump data in format</dd>
</dl>
</div>
<div class="section" id="tipc-network-topology-interfaces">
<h3>TIPC Network Topology Interfaces<a class="headerlink" href="#tipc-network-topology-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.tipc_sub_check_overlap">
bool <code class="descname">tipc_sub_check_overlap</code><span class="sig-paren">(</span>struct tipc_service_range<em>&nbsp;*subscribed</em>, struct tipc_service_range<em>&nbsp;*found</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_sub_check_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>test for subscription overlap with the given values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_service_range</span> <span class="pre">*subscribed</span></code></dt>
<dd>the service range subscribed for</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tipc_service_range</span> <span class="pre">*found</span></code></dt>
<dd>the service range we are checking for match</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if there is overlap, otherwise false.</p>
</div>
<div class="section" id="tipc-server-interfaces">
<h3>TIPC Server Interfaces<a class="headerlink" href="#tipc-server-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.tipc_topsrv">
struct <code class="descname">tipc_topsrv</code><a class="headerlink" href="#c.tipc_topsrv" title="Permalink to this definition">¶</a></dt>
<dd><p>TIPC server structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_topsrv {
  struct idr conn_idr;
  spinlock_t idr_lock;
  int idr_in_use;
  struct net *net;
  struct work_struct awork;
  struct workqueue_struct *rcv_wq;
  struct workqueue_struct *send_wq;
  struct socket *listener;
  char name[TIPC_SERVER_NAME_LEN];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">conn_idr</span></code></dt>
<dd>identifier set of connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idr_lock</span></code></dt>
<dd>protect the connection identifier set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idr_in_use</span></code></dt>
<dd>amount of allocated identifier entry</dd>
<dt><code class="docutils literal notranslate"><span class="pre">net</span></code></dt>
<dd>network namspace instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">awork</span></code></dt>
<dd>accept work item</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcv_wq</span></code></dt>
<dd>receive workqueue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_wq</span></code></dt>
<dd>send workqueue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">listener</span></code></dt>
<dd>topsrv listener socket</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>server name</dd>
</dl>
<dl class="type">
<dt id="c.tipc_conn">
struct <code class="descname">tipc_conn</code><a class="headerlink" href="#c.tipc_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>TIPC connection structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tipc_conn {
  struct kref kref;
  int conid;
  struct socket *sock;
  unsigned long flags;
  struct tipc_topsrv *server;
  struct list_head sub_list;
  spinlock_t sub_lock;
  struct work_struct rwork;
  struct list_head outqueue;
  spinlock_t outqueue_lock;
  struct work_struct swork;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt>
<dd>reference counter to connection object</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conid</span></code></dt>
<dd>connection identifier</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sock</span></code></dt>
<dd>socket handler associated with connection</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd>indicates connection state</dd>
<dt><code class="docutils literal notranslate"><span class="pre">server</span></code></dt>
<dd>pointer to connected server</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sub_list</span></code></dt>
<dd>lsit to all pertaing subscriptions</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sub_lock</span></code></dt>
<dd>lock protecting the subscription list</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rwork</span></code></dt>
<dd>receive work item</dd>
<dt><code class="docutils literal notranslate"><span class="pre">outqueue</span></code></dt>
<dd>pointer to first outbound message in queue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">outqueue_lock</span></code></dt>
<dd>control access to the outqueue</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swork</span></code></dt>
<dd>send work item</dd>
</dl>
</div>
<div class="section" id="tipc-trace-interfaces">
<h3>TIPC Trace Interfaces<a class="headerlink" href="#tipc-trace-interfaces" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.tipc_skb_dump">
int <code class="descname">tipc_skb_dump</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, bool<em>&nbsp;more</em>, char<em>&nbsp;*buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_skb_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>dump TIPC skb data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt>
<dd>skb to be dumped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">more</span></code></dt>
<dd>dump more?
- false: dump only tipc msg data
- true: dump kernel-related skb data and tipc cb[] array as well</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt>
<dd>returned buffer of dump data in format</dd>
</dl>
<dl class="function">
<dt id="c.tipc_list_dump">
int <code class="descname">tipc_list_dump</code><span class="sig-paren">(</span>struct sk_buff_head<em>&nbsp;*list</em>, bool<em>&nbsp;more</em>, char<em>&nbsp;*buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tipc_list_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>dump TIPC skb list/queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt>
<dd>list of skbs to be dumped</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">more</span></code></dt>
<dd>dump more?
- false: dump only the head &amp; tail skbs
- true: dump the first &amp; last 5 skbs</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt>
<dd>returned buffer of dump data in format</dd>
</dl>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tproxy.html" class="btn btn-neutral float-right" title="Transparent proxy support" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="timestamping.html" class="btn btn-neutral" title="Timestamping" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>