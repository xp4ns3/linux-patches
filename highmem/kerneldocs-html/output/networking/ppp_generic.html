

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PPP Generic Driver and Channel Interface &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../index.html"/>
        <link rel="up" title="Linux Networking Documentation" href="index.html"/>
        <link rel="next" title="The proc/net/tcp and proc/net/tcp6 variables" href="proc_net_tcp.html"/>
        <link rel="prev" title="PLIP: The Parallel Line Internet Protocol Device" href="plip.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Networking Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="af_xdp.html">AF_XDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="bareudp.html">Bare UDP Tunnelling Module Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="batman-adv.html">batman-adv</a></li>
<li class="toctree-l2"><a class="reference internal" href="can.html">SocketCAN - Controller Area Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="can_ucan_protocol.html">The UCAN Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_drivers/index.html">Hardware Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dsa/index.html">Distributed Switch Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="devlink/index.html">Linux Devlink Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="caif/index.html">CAIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="ethtool-netlink.html">Netlink interface for ethtool</a></li>
<li class="toctree-l2"><a class="reference internal" href="ieee802154.html">IEEE 802.15.4 Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="j1939.html">J1939 Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="kapi.html">Linux Networking and Network Devices APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="msg_zerocopy.html">MSG_ZEROCOPY</a></li>
<li class="toctree-l2"><a class="reference internal" href="failover.html">FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="net_dim.html">Net DIM - Generic Network Dynamic Interrupt Moderation</a></li>
<li class="toctree-l2"><a class="reference internal" href="net_failover.html">NET_FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="page_pool.html">Page Pool API</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy.html">PHY Abstraction Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfp-phylink.html">phylink</a></li>
<li class="toctree-l2"><a class="reference internal" href="alias.html">IP-Aliasing</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge.html">Ethernet Bridging</a></li>
<li class="toctree-l2"><a class="reference internal" href="snmp_counter.html">SNMP counter</a></li>
<li class="toctree-l2"><a class="reference internal" href="checksum-offloads.html">Checksum Offloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="segmentation-offloads.html">Segmentation Offloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="scaling.html">Scaling in the Linux Networking Stack</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls.html">Kernel TLS</a></li>
<li class="toctree-l2"><a class="reference internal" href="tls-offload.html">Kernel TLS offload</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc.html">Linux NFC subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="6lowpan.html">Netdev private dataroom for 6lowpan interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="6pack.html">6pack Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="arcnet-hardware.html">ARCnet Hardware</a></li>
<li class="toctree-l2"><a class="reference internal" href="arcnet.html">ARCnet</a></li>
<li class="toctree-l2"><a class="reference internal" href="atm.html">ATM</a></li>
<li class="toctree-l2"><a class="reference internal" href="ax25.html">AX.25</a></li>
<li class="toctree-l2"><a class="reference internal" href="bonding.html">Linux Ethernet Bonding Driver HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="cdc_mbim.html">cdc_mbim - Driver for CDC MBIM Mobile Broadband modems</a></li>
<li class="toctree-l2"><a class="reference internal" href="dccp.html">DCCP protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="dctcp.html">DCTCP (DataCenter TCP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="decnet.html">Linux DECnet Networking Layer Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="dns_resolver.html">DNS Resolver Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html">Softnet Driver Issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="eql.html">EQL Driver: Serial IP Load Balancing HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="fib_trie.html">LC-trie implementation notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="filter.html">Linux Socket Filtering aka Berkeley Packet Filter (BPF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic-hdlc.html">Generic HDLC layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_netlink.html">Generic Netlink</a></li>
<li class="toctree-l2"><a class="reference internal" href="gen_stats.html">Generic networking statistics for netlink users</a></li>
<li class="toctree-l2"><a class="reference internal" href="gtp.html">The Linux kernel GTP tunneling module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ila.html">Identifier Locator Addressing (ILA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioam6-sysctl.html">IOAM6 Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipddp.html">AppleTalk-IP Decapsulation and AppleTalk-IP Encapsulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_dynaddr.html">IP dynamic address hack-port v0.03</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipsec.html">IPsec</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip-sysctl.html">IP Sysctl</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipv6.html">IPv6</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipvlan.html">IPVLAN Driver HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipvs-sysctl.html">IPvs-sysctl</a></li>
<li class="toctree-l2"><a class="reference internal" href="kcm.html">Kernel Connection Multiplexor</a></li>
<li class="toctree-l2"><a class="reference internal" href="l2tp.html">L2TP</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapb-module.html">The Linux LAPB Module Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="mac80211-injection.html">How to use packet injection with mac80211</a></li>
<li class="toctree-l2"><a class="reference internal" href="mctp.html">Management Component Transport Protocol (MCTP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpls-sysctl.html">MPLS Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="mptcp-sysctl.html">MPTCP Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="multiqueue.html">HOWTO for multiqueue network device support</a></li>
<li class="toctree-l2"><a class="reference internal" href="netconsole.html">Netconsole</a></li>
<li class="toctree-l2"><a class="reference internal" href="netdev-features.html">Netdev features mess and how to get out from it alive</a></li>
<li class="toctree-l2"><a class="reference internal" href="netdevices.html">Network Devices, the Kernel, and You!</a></li>
<li class="toctree-l2"><a class="reference internal" href="netfilter-sysctl.html">Netfilter Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="netif-msg.html">NETIF Msg Level</a></li>
<li class="toctree-l2"><a class="reference internal" href="nexthop-group-resilient.html">Resilient Next-hop Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="nf_conntrack-sysctl.html">Netfilter Conntrack Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="nf_flowtable.html">Netfilter’s flowtable infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="openvswitch.html">Open vSwitch datapath developer documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="operstates.html">Operational States</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_mmap.html">Packet MMAP</a></li>
<li class="toctree-l2"><a class="reference internal" href="phonet.html">Linux Phonet protocol family</a></li>
<li class="toctree-l2"><a class="reference internal" href="pktgen.html">HOWTO for the linux packet generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="plip.html">PLIP: The Parallel Line Internet Protocol Device</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">PPP Generic Driver and Channel Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ppp-channel-api">PPP channel API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buffering-and-flow-control">Buffering and flow control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smp-safety">SMP safety</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interface-to-pppd">Interface to pppd</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proc_net_tcp.html">The proc/net/tcp and proc/net/tcp6 variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="radiotap-headers.html">How to use radiotap headers</a></li>
<li class="toctree-l2"><a class="reference internal" href="rds.html">RDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulatory.html">Linux wireless regulatory documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html">RxRPC Network Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html#socket-options">SOCKET OPTIONS</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html#security">SECURITY</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxrpc.html#example-client-usage">EXAMPLE CLIENT USAGE</a></li>
<li class="toctree-l2"><a class="reference internal" href="sctp.html">Linux Kernel SCTP</a></li>
<li class="toctree-l2"><a class="reference internal" href="secid.html">LSM/SeLinux secid</a></li>
<li class="toctree-l2"><a class="reference internal" href="seg6-sysctl.html">Seg6 Sysfs variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc-sysctl.html">SMC Sysctl</a></li>
<li class="toctree-l2"><a class="reference internal" href="statistics.html">Interface statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="strparser.html">Stream Parser (strparser)</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchdev.html">Ethernet switch device driver model (switchdev)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sysfs-tagging.html">Sysfs tagging</a></li>
<li class="toctree-l2"><a class="reference internal" href="tc-actions-env-rules.html">TC Actions - Environmental Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="tcp-thin.html">Thin-streams and TCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="team.html">Team</a></li>
<li class="toctree-l2"><a class="reference internal" href="timestamping.html">Timestamping</a></li>
<li class="toctree-l2"><a class="reference internal" href="tipc.html">Linux Kernel TIPC</a></li>
<li class="toctree-l2"><a class="reference internal" href="tproxy.html">Transparent proxy support</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuntap.html">Universal TUN/TAP device driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="udplite.html">The UDP-Lite protocol (RFC 3828)</a></li>
<li class="toctree-l2"><a class="reference internal" href="vrf.html">Virtual Routing and Forwarding (VRF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="vxlan.html">Virtual eXtensible Local Area Networking documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25-iface.html">Packet Layer to Device Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25-iface.html#device-driver-to-packet-layer">Device Driver to Packet Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25-iface.html#requirements-for-the-device-driver">Requirements for the device driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="x25.html">Linux X.25 Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_device.html">XFRM device - offloading the IPsec computations</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_proc.html">XFRM proc - /proc/net/xfrm_* files</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_sync.html">XFRM</a></li>
<li class="toctree-l2"><a class="reference internal" href="xfrm_sysctl.html">XFRM Syscall</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Networking Documentation</a> &raquo;</li>
        
      <li>PPP Generic Driver and Channel Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/networking/ppp_generic.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="ppp-generic-driver-and-channel-interface">
<h1>PPP Generic Driver and Channel Interface<a class="headerlink" href="#ppp-generic-driver-and-channel-interface" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Paul Mackerras
<a class="reference external" href="mailto:paulus&#37;&#52;&#48;samba&#46;org">paulus<span>&#64;</span>samba<span>&#46;</span>org</a></p>
<blockquote>
<div>7 Feb 2002</div></blockquote>
</div></blockquote>
<p>The generic PPP driver in linux-2.4 provides an implementation of the
functionality which is of use in any PPP implementation, including:</p>
<ul class="simple">
<li>the network interface unit (ppp0 etc.)</li>
<li>the interface to the networking code</li>
<li>PPP multilink: splitting datagrams between multiple links, and
ordering and combining received fragments</li>
<li>the interface to pppd, via a /dev/ppp character device</li>
<li>packet compression and decompression</li>
<li>TCP/IP header compression and decompression</li>
<li>detecting network traffic for demand dialling and for idle timeouts</li>
<li>simple packet filtering</li>
</ul>
<p>For sending and receiving PPP frames, the generic PPP driver calls on
the services of PPP <code class="docutils literal notranslate"><span class="pre">channels</span></code>.  A PPP channel encapsulates a
mechanism for transporting PPP frames from one machine to another.  A
PPP channel implementation can be arbitrarily complex internally but
has a very simple interface with the generic PPP code: it merely has
to be able to send PPP frames, receive PPP frames, and optionally
handle ioctl requests.  Currently there are PPP channel
implementations for asynchronous serial ports, synchronous serial
ports, and for PPP over ethernet.</p>
<p>This architecture makes it possible to implement PPP multilink in a
natural and straightforward way, by allowing more than one channel to
be linked to each ppp network interface unit.  The generic layer is
responsible for splitting datagrams on transmit and recombining them
on receive.</p>
<div class="section" id="ppp-channel-api">
<h2>PPP channel API<a class="headerlink" href="#ppp-channel-api" title="Permalink to this headline">¶</a></h2>
<p>See include/linux/ppp_channel.h for the declaration of the types and
functions used to communicate between the generic PPP layer and PPP
channels.</p>
<p>Each channel has to provide two functions to the generic PPP layer,
via the ppp_channel.ops pointer:</p>
<ul class="simple">
<li>start_xmit() is called by the generic layer when it has a frame to
send.  The channel has the option of rejecting the frame for
flow-control reasons.  In this case, start_xmit() should return 0
and the channel should call the ppp_output_wakeup() function at a
later time when it can accept frames again, and the generic layer
will then attempt to retransmit the rejected frame(s).  If the frame
is accepted, the start_xmit() function should return 1.</li>
<li>ioctl() provides an interface which can be used by a user-space
program to control aspects of the channel’s behaviour.  This
procedure will be called when a user-space program does an ioctl
system call on an instance of /dev/ppp which is bound to the
channel.  (Usually it would only be pppd which would do this.)</li>
</ul>
<p>The generic PPP layer provides seven functions to channels:</p>
<ul class="simple">
<li>ppp_register_channel() is called when a channel has been created, to
notify the PPP generic layer of its presence.  For example, setting
a serial port to the PPPDISC line discipline causes the ppp_async
channel code to call this function.</li>
<li>ppp_unregister_channel() is called when a channel is to be
destroyed.  For example, the ppp_async channel code calls this when
a hangup is detected on the serial port.</li>
<li>ppp_output_wakeup() is called by a channel when it has previously
rejected a call to its start_xmit function, and can now accept more
packets.</li>
<li>ppp_input() is called by a channel when it has received a complete
PPP frame.</li>
<li>ppp_input_error() is called by a channel when it has detected that a
frame has been lost or dropped (for example, because of a FCS (frame
check sequence) error).</li>
<li>ppp_channel_index() returns the channel index assigned by the PPP
generic layer to this channel.  The channel should provide some way
(e.g. an ioctl) to transmit this back to user-space, as user-space
will need it to attach an instance of /dev/ppp to this channel.</li>
<li>ppp_unit_number() returns the unit number of the ppp network
interface to which this channel is connected, or -1 if the channel
is not connected.</li>
</ul>
<p>Connecting a channel to the ppp generic layer is initiated from the
channel code, rather than from the generic layer.  The channel is
expected to have some way for a user-level process to control it
independently of the ppp generic layer.  For example, with the
ppp_async channel, this is provided by the file descriptor to the
serial port.</p>
<p>Generally a user-level process will initialize the underlying
communications medium and prepare it to do PPP.  For example, with an
async tty, this can involve setting the tty speed and modes, issuing
modem commands, and then going through some sort of dialog with the
remote system to invoke PPP service there.  We refer to this process
as <code class="docutils literal notranslate"><span class="pre">discovery</span></code>.  Then the user-level process tells the medium to
become a PPP channel and register itself with the generic PPP layer.
The channel then has to report the channel number assigned to it back
to the user-level process.  From that point, the PPP negotiation code
in the PPP daemon (pppd) can take over and perform the PPP
negotiation, accessing the channel through the /dev/ppp interface.</p>
<p>At the interface to the PPP generic layer, PPP frames are stored in
skbuff structures and start with the two-byte PPP protocol number.
The frame does <em>not</em> include the 0xff <code class="docutils literal notranslate"><span class="pre">address</span></code> byte or the 0x03
<code class="docutils literal notranslate"><span class="pre">control</span></code> byte that are optionally used in async PPP.  Nor is there
any escaping of control characters, nor are there any FCS or framing
characters included.  That is all the responsibility of the channel
code, if it is needed for the particular medium.  That is, the skbuffs
presented to the start_xmit() function contain only the 2-byte
protocol number and the data, and the skbuffs presented to ppp_input()
must be in the same format.</p>
<p>The channel must provide an instance of a ppp_channel struct to
represent the channel.  The channel is free to use the <code class="docutils literal notranslate"><span class="pre">private</span></code> field
however it wishes.  The channel should initialize the <code class="docutils literal notranslate"><span class="pre">mtu</span></code> and
<code class="docutils literal notranslate"><span class="pre">hdrlen</span></code> fields before calling ppp_register_channel() and not change
them until after ppp_unregister_channel() returns.  The <code class="docutils literal notranslate"><span class="pre">mtu</span></code> field
represents the maximum size of the data part of the PPP frames, that
is, it does not include the 2-byte protocol number.</p>
<p>If the channel needs some headroom in the skbuffs presented to it for
transmission (i.e., some space free in the skbuff data area before the
start of the PPP frame), it should set the <code class="docutils literal notranslate"><span class="pre">hdrlen</span></code> field of the
ppp_channel struct to the amount of headroom required.  The generic
PPP layer will attempt to provide that much headroom but the channel
should still check if there is sufficient headroom and copy the skbuff
if there isn’t.</p>
<p>On the input side, channels should ideally provide at least 2 bytes of
headroom in the skbuffs presented to ppp_input().  The generic PPP
code does not require this but will be more efficient if this is done.</p>
</div>
<div class="section" id="buffering-and-flow-control">
<h2>Buffering and flow control<a class="headerlink" href="#buffering-and-flow-control" title="Permalink to this headline">¶</a></h2>
<p>The generic PPP layer has been designed to minimize the amount of data
that it buffers in the transmit direction.  It maintains a queue of
transmit packets for the PPP unit (network interface device) plus a
queue of transmit packets for each attached channel.  Normally the
transmit queue for the unit will contain at most one packet; the
exceptions are when pppd sends packets by writing to /dev/ppp, and
when the core networking code calls the generic layer’s start_xmit()
function with the queue stopped, i.e. when the generic layer has
called <a class="reference internal" href="kapi.html#c.netif_stop_queue" title="netif_stop_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_stop_queue()</span></code></a>, which only happens on a transmit timeout.
The start_xmit function always accepts and queues the packet which it
is asked to transmit.</p>
<p>Transmit packets are dequeued from the PPP unit transmit queue and
then subjected to TCP/IP header compression and packet compression
(Deflate or BSD-Compress compression), as appropriate.  After this
point the packets can no longer be reordered, as the decompression
algorithms rely on receiving compressed packets in the same order that
they were generated.</p>
<p>If multilink is not in use, this packet is then passed to the attached
channel’s start_xmit() function.  If the channel refuses to take
the packet, the generic layer saves it for later transmission.  The
generic layer will call the channel’s start_xmit() function again
when the channel calls  ppp_output_wakeup() or when the core
networking code calls the generic layer’s start_xmit() function
again.  The generic layer contains no timeout and retransmission
logic; it relies on the core networking code for that.</p>
<p>If multilink is in use, the generic layer divides the packet into one
or more fragments and puts a multilink header on each fragment.  It
decides how many fragments to use based on the length of the packet
and the number of channels which are potentially able to accept a
fragment at the moment.  A channel is potentially able to accept a
fragment if it doesn’t have any fragments currently queued up for it
to transmit.  The channel may still refuse a fragment; in this case
the fragment is queued up for the channel to transmit later.  This
scheme has the effect that more fragments are given to higher-
bandwidth channels.  It also means that under light load, the generic
layer will tend to fragment large packets across all the channels,
thus reducing latency, while under heavy load, packets will tend to be
transmitted as single fragments, thus reducing the overhead of
fragmentation.</p>
</div>
<div class="section" id="smp-safety">
<h2>SMP safety<a class="headerlink" href="#smp-safety" title="Permalink to this headline">¶</a></h2>
<p>The PPP generic layer has been designed to be SMP-safe.  Locks are
used around accesses to the internal data structures where necessary
to ensure their integrity.  As part of this, the generic layer
requires that the channels adhere to certain requirements and in turn
provides certain guarantees to the channels.  Essentially the channels
are required to provide the appropriate locking on the ppp_channel
structures that form the basis of the communication between the
channel and the generic layer.  This is because the channel provides
the storage for the ppp_channel structure, and so the channel is
required to provide the guarantee that this storage exists and is
valid at the appropriate times.</p>
<p>The generic layer requires these guarantees from the channel:</p>
<ul class="simple">
<li>The ppp_channel object must exist from the time that
ppp_register_channel() is called until after the call to
ppp_unregister_channel() returns.</li>
<li>No thread may be in a call to any of ppp_input(), ppp_input_error(),
ppp_output_wakeup(), ppp_channel_index() or ppp_unit_number() for a
channel at the time that ppp_unregister_channel() is called for that
channel.</li>
<li>ppp_register_channel() and ppp_unregister_channel() must be called
from process context, not interrupt or softirq/BH context.</li>
<li>The remaining generic layer functions may be called at softirq/BH
level but must not be called from a hardware interrupt handler.</li>
<li>The generic layer may call the channel start_xmit() function at
softirq/BH level but will not call it at interrupt level.  Thus the
start_xmit() function may not block.</li>
<li>The generic layer will only call the channel ioctl() function in
process context.</li>
</ul>
<p>The generic layer provides these guarantees to the channels:</p>
<ul class="simple">
<li>The generic layer will not call the start_xmit() function for a
channel while any thread is already executing in that function for
that channel.</li>
<li>The generic layer will not call the ioctl() function for a channel
while any thread is already executing in that function for that
channel.</li>
<li>By the time a call to ppp_unregister_channel() returns, no thread
will be executing in a call from the generic layer to that channel’s
start_xmit() or ioctl() function, and the generic layer will not
call either of those functions subsequently.</li>
</ul>
</div>
<div class="section" id="interface-to-pppd">
<h2>Interface to pppd<a class="headerlink" href="#interface-to-pppd" title="Permalink to this headline">¶</a></h2>
<p>The PPP generic layer exports a character device interface called
/dev/ppp.  This is used by pppd to control PPP interface units and
channels.  Although there is only one /dev/ppp, each open instance of
/dev/ppp acts independently and can be attached either to a PPP unit
or a PPP channel.  This is achieved using the file-&gt;private_data field
to point to a separate object for each open instance of /dev/ppp.  In
this way an effect similar to Solaris’ clone open is obtained,
allowing us to control an arbitrary number of PPP interfaces and
channels without having to fill up /dev with hundreds of device names.</p>
<p>When /dev/ppp is opened, a new instance is created which is initially
unattached.  Using an ioctl call, it can then be attached to an
existing unit, attached to a newly-created unit, or attached to an
existing channel.  An instance attached to a unit can be used to send
and receive PPP control frames, using the read() and write() system
calls, along with poll() if necessary.  Similarly, an instance
attached to a channel can be used to send and receive PPP frames on
that channel.</p>
<p>In multilink terms, the unit represents the bundle, while the channels
represent the individual physical links.  Thus, a PPP frame sent by a
write to the unit (i.e., to an instance of /dev/ppp attached to the
unit) will be subject to bundle-level compression and to fragmentation
across the individual links (if multilink is in use).  In contrast, a
PPP frame sent by a write to the channel will be sent as-is on that
channel, without any multilink header.</p>
<p>A channel is not initially attached to any unit.  In this state it can
be used for PPP negotiation but not for the transfer of data packets.
It can then be connected to a PPP unit with an ioctl call, which
makes it available to send and receive data packets for that unit.</p>
<p>The ioctl calls which are available on an instance of /dev/ppp depend
on whether it is unattached, attached to a PPP interface, or attached
to a PPP channel.  The ioctl calls which are available on an
unattached instance are:</p>
<ul class="simple">
<li>PPPIOCNEWUNIT creates a new PPP interface and makes this /dev/ppp
instance the “owner” of the interface.  The argument should point to
an int which is the desired unit number if &gt;= 0, or -1 to assign the
lowest unused unit number.  Being the owner of the interface means
that the interface will be shut down if this instance of /dev/ppp is
closed.</li>
<li>PPPIOCATTACH attaches this instance to an existing PPP interface.
The argument should point to an int containing the unit number.
This does not make this instance the owner of the PPP interface.</li>
<li>PPPIOCATTCHAN attaches this instance to an existing PPP channel.
The argument should point to an int containing the channel number.</li>
</ul>
<p>The ioctl calls available on an instance of /dev/ppp attached to a
channel are:</p>
<ul class="simple">
<li>PPPIOCCONNECT connects this channel to a PPP interface.  The
argument should point to an int containing the interface unit
number.  It will return an EINVAL error if the channel is already
connected to an interface, or ENXIO if the requested interface does
not exist.</li>
<li>PPPIOCDISCONN disconnects this channel from the PPP interface that
it is connected to.  It will return an EINVAL error if the channel
is not connected to an interface.</li>
<li>PPPIOCBRIDGECHAN bridges a channel with another. The argument should
point to an int containing the channel number of the channel to bridge
to. Once two channels are bridged, frames presented to one channel by
ppp_input() are passed to the bridge instance for onward transmission.
This allows frames to be switched from one channel into another: for
example, to pass PPPoE frames into a PPPoL2TP session. Since channel
bridging interrupts the normal ppp_input() path, a given channel may
not be part of a bridge at the same time as being part of a unit.
This ioctl will return an EALREADY error if the channel is already
part of a bridge or unit, or ENXIO if the requested channel does not
exist.</li>
<li>PPPIOCUNBRIDGECHAN performs the inverse of PPPIOCBRIDGECHAN, unbridging
a channel pair.  This ioctl will return an EINVAL error if the channel
does not form part of a bridge.</li>
<li>All other ioctl commands are passed to the channel ioctl() function.</li>
</ul>
<p>The ioctl calls that are available on an instance that is attached to
an interface unit are:</p>
<ul>
<li><p class="first">PPPIOCSMRU sets the MRU (maximum receive unit) for the interface.
The argument should point to an int containing the new MRU value.</p>
</li>
<li><p class="first">PPPIOCSFLAGS sets flags which control the operation of the
interface.  The argument should be a pointer to an int containing
the new flags value.  The bits in the flags value that can be set
are:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>SC_COMP_TCP</td>
<td>enable transmit TCP header compression</td>
</tr>
<tr class="row-even"><td>SC_NO_TCP_CCID</td>
<td>disable connection-id compression for
TCP header compression</td>
</tr>
<tr class="row-odd"><td>SC_REJ_COMP_TCP</td>
<td>disable receive TCP header decompression</td>
</tr>
<tr class="row-even"><td>SC_CCP_OPEN</td>
<td>Compression Control Protocol (CCP) is
open, so inspect CCP packets</td>
</tr>
<tr class="row-odd"><td>SC_CCP_UP</td>
<td>CCP is up, may (de)compress packets</td>
</tr>
<tr class="row-even"><td>SC_LOOP_TRAFFIC</td>
<td>send IP traffic to pppd</td>
</tr>
<tr class="row-odd"><td>SC_MULTILINK</td>
<td>enable PPP multilink fragmentation on
transmitted packets</td>
</tr>
<tr class="row-even"><td>SC_MP_SHORTSEQ</td>
<td>expect short multilink sequence
numbers on received multilink fragments</td>
</tr>
<tr class="row-odd"><td>SC_MP_XSHORTSEQ</td>
<td>transmit short multilink sequence nos.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The values of these flags are defined in &lt;linux/ppp-ioctl.h&gt;.  Note
that the values of the SC_MULTILINK, SC_MP_SHORTSEQ and
SC_MP_XSHORTSEQ bits are ignored if the CONFIG_PPP_MULTILINK option
is not selected.</p>
</li>
<li><p class="first">PPPIOCGFLAGS returns the value of the status/control flags for the
interface unit.  The argument should point to an int where the ioctl
will store the flags value.  As well as the values listed above for
PPPIOCSFLAGS, the following bits may be set in the returned value:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>SC_COMP_RUN</td>
<td>CCP compressor is running</td>
</tr>
<tr class="row-even"><td>SC_DECOMP_RUN</td>
<td>CCP decompressor is running</td>
</tr>
<tr class="row-odd"><td>SC_DC_ERROR</td>
<td>CCP decompressor detected non-fatal error</td>
</tr>
<tr class="row-even"><td>SC_DC_FERROR</td>
<td>CCP decompressor detected fatal error</td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p class="first">PPPIOCSCOMPRESS sets the parameters for packet compression or
decompression.  The argument should point to a ppp_option_data
structure (defined in &lt;linux/ppp-ioctl.h&gt;), which contains a
pointer/length pair which should describe a block of memory
containing a CCP option specifying a compression method and its
parameters.  The ppp_option_data struct also contains a <code class="docutils literal notranslate"><span class="pre">transmit</span></code>
field.  If this is 0, the ioctl will affect the receive path,
otherwise the transmit path.</p>
</li>
<li><p class="first">PPPIOCGUNIT returns, in the int pointed to by the argument, the unit
number of this interface unit.</p>
</li>
<li><p class="first">PPPIOCSDEBUG sets the debug flags for the interface to the value in
the int pointed to by the argument.  Only the least significant bit
is used; if this is 1 the generic layer will print some debug
messages during its operation.  This is only intended for debugging
the generic PPP layer code; it is generally not helpful for working
out why a PPP connection is failing.</p>
</li>
<li><p class="first">PPPIOCGDEBUG returns the debug flags for the interface in the int
pointed to by the argument.</p>
</li>
<li><p class="first">PPPIOCGIDLE returns the time, in seconds, since the last data
packets were sent and received.  The argument should point to a
ppp_idle structure (defined in &lt;linux/ppp_defs.h&gt;).  If the
CONFIG_PPP_FILTER option is enabled, the set of packets which reset
the transmit and receive idle timers is restricted to those which
pass the <code class="docutils literal notranslate"><span class="pre">active</span></code> packet filter.
Two versions of this command exist, to deal with user space
expecting times as either 32-bit or 64-bit time_t seconds.</p>
</li>
<li><p class="first">PPPIOCSMAXCID sets the maximum connection-ID parameter (and thus the
number of connection slots) for the TCP header compressor and
decompressor.  The lower 16 bits of the int pointed to by the
argument specify the maximum connection-ID for the compressor.  If
the upper 16 bits of that int are non-zero, they specify the maximum
connection-ID for the decompressor, otherwise the decompressor’s
maximum connection-ID is set to 15.</p>
</li>
<li><p class="first">PPPIOCSNPMODE sets the network-protocol mode for a given network
protocol.  The argument should point to an npioctl struct (defined
in &lt;linux/ppp-ioctl.h&gt;).  The <code class="docutils literal notranslate"><span class="pre">protocol</span></code> field gives the PPP protocol
number for the protocol to be affected, and the <code class="docutils literal notranslate"><span class="pre">mode</span></code> field
specifies what to do with packets for that protocol:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>NPMODE_PASS</td>
<td>normal operation, transmit and receive packets</td>
</tr>
<tr class="row-even"><td>NPMODE_DROP</td>
<td>silently drop packets for this protocol</td>
</tr>
<tr class="row-odd"><td>NPMODE_ERROR</td>
<td>drop packets and return an error on transmit</td>
</tr>
<tr class="row-even"><td>NPMODE_QUEUE</td>
<td>queue up packets for transmit, drop received
packets</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>At present NPMODE_ERROR and NPMODE_QUEUE have the same effect as
NPMODE_DROP.</p>
</li>
<li><p class="first">PPPIOCGNPMODE returns the network-protocol mode for a given
protocol.  The argument should point to an npioctl struct with the
<code class="docutils literal notranslate"><span class="pre">protocol</span></code> field set to the PPP protocol number for the protocol of
interest.  On return the <code class="docutils literal notranslate"><span class="pre">mode</span></code> field will be set to the network-
protocol mode for that protocol.</p>
</li>
<li><p class="first">PPPIOCSPASS and PPPIOCSACTIVE set the <code class="docutils literal notranslate"><span class="pre">pass</span></code> and <code class="docutils literal notranslate"><span class="pre">active</span></code> packet
filters.  These ioctls are only available if the CONFIG_PPP_FILTER
option is selected.  The argument should point to a sock_fprog
structure (defined in &lt;linux/filter.h&gt;) containing the compiled BPF
instructions for the filter.  Packets are dropped if they fail the
<code class="docutils literal notranslate"><span class="pre">pass</span></code> filter; otherwise, if they fail the <code class="docutils literal notranslate"><span class="pre">active</span></code> filter they are
passed but they do not reset the transmit or receive idle timer.</p>
</li>
<li><p class="first">PPPIOCSMRRU enables or disables multilink processing for received
packets and sets the multilink MRRU (maximum reconstructed receive
unit).  The argument should point to an int containing the new MRRU
value.  If the MRRU value is 0, processing of received multilink
fragments is disabled.  This ioctl is only available if the
CONFIG_PPP_MULTILINK option is selected.</p>
</li>
</ul>
<p>Last modified: 7-feb-2002</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="proc_net_tcp.html" class="btn btn-neutral float-right" title="The proc/net/tcp and proc/net/tcp6 variables" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="plip.html" class="btn btn-neutral" title="PLIP: The Parallel Line Internet Protocol Device" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>