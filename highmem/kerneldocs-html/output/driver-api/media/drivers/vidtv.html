

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>9.2.3. vidtv: Virtual Digital TV driver &mdash; The Linux Kernel 5.18.0-rc1-torvalds+ documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../_static/theme_rtd_colors.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="The Linux Kernel 5.18.0-rc1-torvalds+ documentation" href="../../../index.html"/>
        <link rel="up" title="9. Media driver-specific documentation" href="index.html"/>
        <link rel="next" title="9.2.4. Contributors" href="contributors.html"/>
        <link rel="prev" title="9.2.2. Frontend drivers" href="frontends.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.18.0-rc2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cxl/index.html">Compute Express Link</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../md/index.html">RAID</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../maintainer-entry-profile.html">1. Media Subsystem Profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../v4l2-core.html">2. Video4Linux devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dtv-core.html">3. Digital TV (DVB) devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rc-core.html">4. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mc-core.html">5. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cec-core.html">6. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tx-rx.html">7. Pixel data transmitter and receiver drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../camera-sensor.html">8. Writing camera sensor drivers</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">9. Media driver-specific documentation</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="index.html#video4linux-v4l-drivers">9.1. Video4Linux (V4L) drivers</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="index.html#digital-tv-drivers">9.2. Digital TV drivers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="../../vfio-pci-device-specific-driver-acceptance.html">Acceptance criteria for vfio-pci device specific driver variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mhi/index.html">MHI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tty/index.html">TTY</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../peci/index.html">Linux PECI Subsystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">Kernel tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">The Linux Kernel</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="../index.html">Media subsystem kernel internal API</a> &raquo;</li>
        
          <li><a href="index.html">9. Media driver-specific documentation</a> &raquo;</li>
        
      <li>9.2.3. vidtv: Virtual Digital TV driver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/driver-api/media/drivers/vidtv.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="vidtv-virtual-digital-tv-driver">
<h1>9.2.3. vidtv: Virtual Digital TV driver<a class="headerlink" href="#vidtv-virtual-digital-tv-driver" title="Permalink to this headline">¶</a></h1>
<p>Author: Daniel W. S. Almeida &lt;<a class="reference external" href="mailto:dwlsalmeida&#37;&#52;&#48;gmail&#46;com">dwlsalmeida<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;, June 2020.</p>
<div class="section" id="background">
<h2>9.2.3.1. Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>Vidtv is a virtual DVB driver that aims to serve as a reference for driver
writers by serving as a template. It also validates the existing media DVB
APIs, thus helping userspace application writers.</p>
<p>Currently, it consists of:</p>
<ul class="simple">
<li>A fake tuner driver, which will report a bad signal quality if the chosen
frequency is too far away from a table of valid frequencies for a
particular delivery system.</li>
<li>A fake demod driver, which will constantly poll the fake signal quality
returned by the tuner, simulating a device that can lose/reacquire a lock
on the signal depending on the CNR levels.</li>
<li>A fake bridge driver, which is the module responsible for modprobing the
fake tuner and demod modules and implementing the demux logic. This module
takes parameters at initialization that will dictate how the simulation
behaves.</li>
<li>Code reponsible for encoding a valid MPEG Transport Stream, which is then
passed to the bridge driver. This fake stream contains some hardcoded content.
For now, we have a single, audio-only channel containing a single MPEG
Elementary Stream, which in turn contains a SMPTE 302m encoded sine-wave.
Note that this particular encoder was chosen because it is the easiest
way to encode PCM audio data in a MPEG Transport Stream.</li>
</ul>
</div>
<div class="section" id="building-vidtv">
<h2>9.2.3.2. Building vidtv<a class="headerlink" href="#building-vidtv" title="Permalink to this headline">¶</a></h2>
<p>vidtv is a test driver and thus is <strong>not</strong> enabled by default when
compiling the kernel.</p>
<p>In order to enable compilation of vidtv:</p>
<ul class="simple">
<li>Enable <strong>DVB_TEST_DRIVERS</strong>, then</li>
<li>Enable <strong>DVB_VIDTV</strong></li>
</ul>
<p>When compiled as a module, expect the following .ko files:</p>
<ul class="simple">
<li>dvb_vidtv_tuner.ko</li>
<li>dvb_vidtv_demod.ko</li>
<li>dvb_vidtv_bridge.ko</li>
</ul>
</div>
<div class="section" id="running-vidtv">
<h2>9.2.3.3. Running vidtv<a class="headerlink" href="#running-vidtv" title="Permalink to this headline">¶</a></h2>
<p>When compiled as a module, run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>modprobe vidtv
</pre></div>
</div>
<p>That’s it! The bridge driver will initialize the tuner and demod drivers as
part of its own initialization.</p>
<p>By default, it will accept the following frequencies:</p>
<blockquote>
<div><ul class="simple">
<li>474 MHz for DVB-T/T2/C;</li>
<li>11,362 GHz for DVB-S/S2.</li>
</ul>
</div></blockquote>
<p>For satellite systems, the driver simulates an universal extended
LNBf, with frequencies at Ku-Band, ranging from 10.7 GHz to 12.75 GHz.</p>
<p>You can optionally define some command-line arguments to vidtv.</p>
</div>
<div class="section" id="command-line-arguments-to-vidtv">
<h2>9.2.3.4. Command-line arguments to vidtv<a class="headerlink" href="#command-line-arguments-to-vidtv" title="Permalink to this headline">¶</a></h2>
<p>Below is a list of all arguments that can be supplied to vidtv:</p>
<dl class="docutils">
<dt>drop_tslock_prob_on_low_snr</dt>
<dd>Probability of losing the TS lock if the signal quality is bad.
This probability be used by the fake demodulator driver to
eventually return a status of 0 when the signal quality is not
good.</dd>
<dt>recover_tslock_prob_on_good_snr:</dt>
<dd>Probability recovering the TS lock when the signal improves. This
probability be used by the fake demodulator driver to eventually
return a status of 0x1f when/if the signal quality improves.</dd>
<dt>mock_power_up_delay_msec</dt>
<dd>Simulate a power up delay.  Default: 0.</dd>
<dt>mock_tune_delay_msec</dt>
<dd>Simulate a tune delay.  Default 0.</dd>
<dt>vidtv_valid_dvb_t_freqs</dt>
<dd>Valid DVB-T frequencies to simulate, in Hz.</dd>
<dt>vidtv_valid_dvb_c_freqs</dt>
<dd>Valid DVB-C frequencies to simulate, in Hz.</dd>
<dt>vidtv_valid_dvb_s_freqs</dt>
<dd>Valid DVB-S/S2 frequencies to simulate at Ku-Band, in kHz.</dd>
<dt>max_frequency_shift_hz,</dt>
<dd>Maximum shift in HZ allowed when tuning in a channel.</dd>
<dt>si_period_msec</dt>
<dd>How often to send SI packets.  Default: 40ms.</dd>
<dt>pcr_period_msec</dt>
<dd>How often to send PCR packets.  Default: 40ms.</dd>
<dt>mux_rate_kbytes_sec</dt>
<dd>Attempt to maintain this bit rate by inserting TS null packets, if
necessary.  Default: 4096.</dd>
<dt>pcr_pid,</dt>
<dd>PCR PID for all channels.  Default: 0x200.</dd>
<dt>mux_buf_sz_pkts,</dt>
<dd>Size for the mux buffer in multiples of 188 bytes.</dd>
</dl>
</div>
<div class="section" id="vidtv-internal-structure">
<h2>9.2.3.5. vidtv internal structure<a class="headerlink" href="#vidtv-internal-structure" title="Permalink to this headline">¶</a></h2>
<p>The kernel modules are split in the following way:</p>
<dl class="docutils">
<dt>vidtv_tuner.[ch]</dt>
<dd>Implements a fake tuner DVB driver.</dd>
<dt>vidtv_demod.[ch]</dt>
<dd>Implements a fake demodulator DVB driver.</dd>
<dt>vidtv_bridge.[ch]</dt>
<dd>Implements a bridge driver.</dd>
</dl>
<p>The MPEG related code is split in the following way:</p>
<dl class="docutils">
<dt>vidtv_ts.[ch]</dt>
<dd>Code to work with MPEG TS packets, such as TS headers, adaptation
fields, PCR packets and NULL packets.</dd>
<dt>vidtv_psi.[ch]</dt>
<dd><p class="first">This is the PSI generator.  PSI packets contain general information
about a MPEG Transport Stream.  A PSI generator is needed so
userspace apps can retrieve information about the Transport Stream
and eventually tune into a (dummy) channel.</p>
<p>Because the generator is implemented in a separate file, it can be
reused elsewhere in the media subsystem.</p>
<p>Currently vidtv supports working with 5 PSI tables: PAT, PMT,
SDT, NIT and EIT.</p>
<p>The specification for PAT and PMT can be found in <em>ISO 13818-1:
Systems</em>, while the specification for the SDT, NIT, EIT can be found in <em>ETSI
EN 300 468: Specification for Service Information (SI) in DVB
systems</em>.</p>
<p>It isn’t strictly necessary, but using a real TS file helps when
debugging PSI tables. Vidtv currently tries to replicate the PSI
structure found in this file: <a class="reference external" href="https://tsduck.io/streams/brazil-isdb-tb/TS1globo.ts">TS1Globo.ts</a>.</p>
<p class="last">A good way to visualize the structure of streams is by using
<a class="reference external" href="https://sourceforge.net/projects/dvbinspector/">DVBInspector</a>.</p>
</dd>
<dt>vidtv_pes.[ch]</dt>
<dd>Implements the PES logic to convert encoder data into MPEG TS
packets. These can then be fed into a TS multiplexer and eventually
into userspace.</dd>
<dt>vidtv_encoder.h</dt>
<dd>An interface for vidtv encoders. New encoders can be added to this
driver by implementing the calls in this file.</dd>
<dt>vidtv_s302m.[ch]</dt>
<dd><p class="first">Implements a S302M encoder to make it possible to insert PCM audio
data in the generated MPEG Transport Stream. The relevant
specification is available online as <em>SMPTE 302M-2007: Television -
Mapping of AES3 Data into MPEG-2 Transport Stream</em>.</p>
<p>The resulting MPEG Elementary Stream is conveyed in a private
stream with a S302M registration descriptor attached.</p>
<p class="last">This shall enable passing an audio signal into userspace so it can
be decoded and played by media software. The corresponding decoder
in ffmpeg is located in ‘libavcodec/s302m.c’ and is experimental.</p>
</dd>
<dt>vidtv_channel.[ch]</dt>
<dd><p class="first">Implements a ‘channel’ abstraction.</p>
<p>When vidtv boots, it will create some hardcoded channels:</p>
<ol class="last arabic simple">
<li>Their services will be concatenated to populate the SDT.</li>
<li>Their programs will be concatenated to populate the PAT</li>
<li>Their events will be concatenated to populate the EIT</li>
<li>For each program in the PAT, a PMT section will be created</li>
<li>The PMT section for a channel will be assigned its streams.</li>
<li>Every stream will have its corresponding encoder polled in a
loop to produce TS packets.
These packets may be interleaved by the muxer and then delivered
to the bridge.</li>
</ol>
</dd>
<dt>vidtv_mux.[ch]</dt>
<dd><p class="first">Implements a MPEG TS mux, loosely based on the ffmpeg
implementation in “libavcodec/mpegtsenc.c”</p>
<p>The muxer runs a loop which is responsible for:</p>
<ol class="last arabic simple">
<li>Keeping track of the amount of time elapsed since the last
iteration.</li>
<li>Polling encoders in order to fetch ‘elapsed_time’ worth of data.</li>
<li>Inserting PSI and/or PCR packets, if needed.</li>
<li>Padding the resulting stream with NULL packets if
necessary in order to maintain the chosen bit rate.</li>
<li>Delivering the resulting TS packets to the bridge
driver so it can pass them to the demux.</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="testing-vidtv-with-v4l-utils">
<h2>9.2.3.6. Testing vidtv with v4l-utils<a class="headerlink" href="#testing-vidtv-with-v4l-utils" title="Permalink to this headline">¶</a></h2>
<p>Using the tools in v4l-utils is a great way to test and inspect the output of
vidtv. It is hosted here: <a class="reference external" href="https://linuxtv.org/wiki/index.php/V4l-utils">v4l-utils Documentation</a>.</p>
<p>From its webpage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The v4l-utils are a series of packages for handling media devices.

It is hosted at http://git.linuxtv.org/v4l-utils.git, and packaged
on most distributions.

It provides a series of libraries and utilities to be used to
control several aspect of the media boards.
</pre></div>
</div>
<p>Start by installing v4l-utils and then modprobing vidtv:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>modprobe dvb_vidtv_bridge
</pre></div>
</div>
<p>If the driver is OK, it should load and its probing code will run. This will
pull in the tuner and demod drivers.</p>
<div class="section" id="using-dvb-fe-tool">
<h3>9.2.3.6.1. Using dvb-fe-tool<a class="headerlink" href="#using-dvb-fe-tool" title="Permalink to this headline">¶</a></h3>
<p>The first step to check whether the demod loaded successfully is to run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dvb-fe-tool
Device Dummy demod for DVB-T/T2/C/S/S2 (/dev/dvb/adapter0/frontend0) capabilities:
    CAN_FEC_1_2
    CAN_FEC_2_3
    CAN_FEC_3_4
    CAN_FEC_4_5
    CAN_FEC_5_6
    CAN_FEC_6_7
    CAN_FEC_7_8
    CAN_FEC_8_9
    CAN_FEC_AUTO
    CAN_GUARD_INTERVAL_AUTO
    CAN_HIERARCHY_AUTO
    CAN_INVERSION_AUTO
    CAN_QAM_16
    CAN_QAM_32
    CAN_QAM_64
    CAN_QAM_128
    CAN_QAM_256
    CAN_QAM_AUTO
    CAN_QPSK
    CAN_TRANSMISSION_MODE_AUTO
DVB API Version 5.11, Current v5 delivery system: DVBC/ANNEX_A
Supported delivery systems:
    DVBT
    DVBT2
    [DVBC/ANNEX_A]
    DVBS
    DVBS2
Frequency range for the current standard:
From:            51.0 MHz
To:              2.15 GHz
Step:            62.5 kHz
Tolerance:       29.5 MHz
Symbol rate ranges for the current standard:
From:            1.00 MBauds
To:              45.0 MBauds
</pre></div>
</div>
<p>This should return what is currently set up at the demod struct, i.e.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct dvb_frontend_ops vidtv_demod_ops = {
        .delsys = {
                SYS_DVBT,
                SYS_DVBT2,
                SYS_DVBC_ANNEX_A,
                SYS_DVBS,
                SYS_DVBS2,
        },

        .info = {
                .name                   = &quot;Dummy demod for DVB-T/T2/C/S/S2&quot;,
                .frequency_min_hz       = 51 * MHz,
                .frequency_max_hz       = 2150 * MHz,
                .frequency_stepsize_hz  = 62500,
                .frequency_tolerance_hz = 29500 * kHz,
                .symbol_rate_min        = 1000000,
                .symbol_rate_max        = 45000000,

                .caps = FE_CAN_FEC_1_2 |
                        FE_CAN_FEC_2_3 |
                        FE_CAN_FEC_3_4 |
                        FE_CAN_FEC_4_5 |
                        FE_CAN_FEC_5_6 |
                        FE_CAN_FEC_6_7 |
                        FE_CAN_FEC_7_8 |
                        FE_CAN_FEC_8_9 |
                        FE_CAN_QAM_16 |
                        FE_CAN_QAM_64 |
                        FE_CAN_QAM_32 |
                        FE_CAN_QAM_128 |
                        FE_CAN_QAM_256 |
                        FE_CAN_QAM_AUTO |
                        FE_CAN_QPSK |
                        FE_CAN_FEC_AUTO |
                        FE_CAN_INVERSION_AUTO |
                        FE_CAN_TRANSMISSION_MODE_AUTO |
                        FE_CAN_GUARD_INTERVAL_AUTO |
                        FE_CAN_HIERARCHY_AUTO,
        }

        ....
</pre></div>
</div>
<p>For more information on dvb-fe-tools check its online documentation here:
<a class="reference external" href="https://www.linuxtv.org/wiki/index.php/Dvb-fe-tool">dvb-fe-tool Documentation</a>.</p>
</div>
<div class="section" id="using-dvb-scan">
<h3>9.2.3.6.2. Using dvb-scan<a class="headerlink" href="#using-dvb-scan" title="Permalink to this headline">¶</a></h3>
<p>In order to tune into a channel and read the PSI tables, we can use dvb-scan.</p>
<p>For this, one should provide a configuration file known as a ‘scan file’,
here’s an example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[Channel]
FREQUENCY = 474000000
MODULATION = QAM/AUTO
SYMBOL_RATE = 6940000
INNER_FEC = AUTO
DELIVERY_SYSTEM = DVBC/ANNEX_A
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The parameters depend on the video standard you’re testing.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Vidtv is a fake driver and does not validate much of the information
in the scan file. Just specifying ‘FREQUENCY’ and ‘DELIVERY_SYSTEM’
should be enough for DVB-T/DVB-T2. For DVB-S/DVB-C however, you
should also provide ‘SYMBOL_RATE’.</p>
</div>
<p>You can browse scan tables online here: <a class="reference external" href="https://git.linuxtv.org/dtv-scan-tables.git">dvb-scan-tables</a>.</p>
<p>Assuming this channel is named ‘channel.conf’, you can then run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dvbv5-scan channel.conf
dvbv5-scan ~/vidtv.conf
ERROR    command BANDWIDTH_HZ (5) not found during retrieve
Cannot calc frequency shift. Either bandwidth/symbol-rate is unavailable (yet).
Scanning frequency #1 330000000
    (0x00) Signal= -68.00dBm
Scanning frequency #2 474000000
Lock   (0x1f) Signal= -34.45dBm C/N= 33.74dB UCB= 0
Service Beethoven, provider LinuxTV.org: digital television
</pre></div>
</div>
<p>For more information on dvb-scan, check its documentation online here:
<a class="reference external" href="https://www.linuxtv.org/wiki/index.php/Dvbscan">dvb-scan Documentation</a>.</p>
</div>
<div class="section" id="using-dvb-zap">
<h3>9.2.3.6.3. Using dvb-zap<a class="headerlink" href="#using-dvb-zap" title="Permalink to this headline">¶</a></h3>
<p>dvbv5-zap is a command line tool that can be used to record MPEG-TS to disk. The
typical use is to tune into a channel and put it into record mode. The example
below - which is taken from the documentation - illustrates that<a class="footnote-reference" href="#id2" id="id1">[1]</a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dvbv5-zap -c dvb_channel.conf &quot;beethoven&quot; -o music.ts -P -t 10
using demux &#39;dvb0.demux0&#39;
reading channels from file &#39;dvb_channel.conf&#39;
tuning to 474000000 Hz
pass all PID&#39;s to TS
dvb_set_pesfilter 8192
dvb_dev_set_bufsize: buffer set to 6160384
Lock   (0x1f) Quality= Good Signal= -34.66dBm C/N= 33.41dB UCB= 0 postBER= 0 preBER= 1.05x10^-3 PER= 0
Lock   (0x1f) Quality= Good Signal= -34.57dBm C/N= 33.46dB UCB= 0 postBER= 0 preBER= 1.05x10^-3 PER= 0
Record to file &#39;music.ts&#39; started
received 24587768 bytes (2401 Kbytes/sec)
Lock   (0x1f) Quality= Good Signal= -34.42dBm C/N= 33.89dB UCB= 0 postBER= 0 preBER= 2.44x10^-3 PER= 0
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>In this example, it records 10 seconds with all program ID’s stored
at the music.ts file.</td></tr>
</tbody>
</table>
<p>The channel can be watched by playing the contents of the stream with some
player that  recognizes the MPEG-TS format, such as <code class="docutils literal notranslate"><span class="pre">mplayer</span></code> or <code class="docutils literal notranslate"><span class="pre">vlc</span></code>.</p>
<p>By playing the contents of the stream one can visually inspect the workings of
vidtv, e.g., to play a recorded TS file with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ mplayer music.ts
</pre></div>
</div>
<p>or, alternatively, running this command on one terminal:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dvbv5-zap -c dvb_channel.conf &quot;beethoven&quot; -P -r &amp;
</pre></div>
</div>
<p>And, on a second terminal, playing the contents from DVR interface with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ mplayer /dev/dvb/adapter0/dvr0
</pre></div>
</div>
<p>For more information on dvb-zap check its online documentation here:
<a class="reference external" href="https://www.linuxtv.org/wiki/index.php/Dvbv5-zap">dvb-zap Documentation</a>.
See also: <a class="reference external" href="https://www.linuxtv.org/wiki/index.php/Zap">zap</a>.</p>
</div>
</div>
<div class="section" id="what-can-still-be-improved-in-vidtv">
<h2>9.2.3.7. What can still be improved in vidtv<a class="headerlink" href="#what-can-still-be-improved-in-vidtv" title="Permalink to this headline">¶</a></h2>
<div class="section" id="add-debugfs-integration">
<h3>9.2.3.7.1. Add <em>debugfs</em> integration<a class="headerlink" href="#add-debugfs-integration" title="Permalink to this headline">¶</a></h3>
<p>Although frontend drivers provide DVBv5 statistics via the .read_status
call, a nice addition would be to make additional statistics available to
userspace via debugfs, which is a simple-to-use, RAM-based filesystem
specifically designed for debug purposes.</p>
<p>The logic for this would be implemented on a separate file so as not to
pollute the frontend driver.  These statistics are driver-specific and can
be useful during tests.</p>
<p>The Siano driver is one example of a driver using
debugfs to convey driver-specific statistics to userspace and it can be
used as a reference.</p>
<p>This should be further enabled and disabled via a Kconfig
option for convenience.</p>
</div>
<div class="section" id="add-a-way-to-test-video">
<h3>9.2.3.7.2. Add a way to test video<a class="headerlink" href="#add-a-way-to-test-video" title="Permalink to this headline">¶</a></h3>
<p>Currently, vidtv can only encode PCM audio. It would be great to implement
a barebones version of MPEG-2 video encoding so we can also test video. The
first place to look into is <em>ISO 13818-2: Information technology — Generic
coding of moving pictures and associated audio information — Part 2: Video</em>,
which covers the encoding of compressed video in MPEG Transport Streams.</p>
<p>This might optionally use the Video4Linux2 Test Pattern Generator, v4l2-tpg,
which resides at:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>drivers/media/common/v4l2-tpg/
</pre></div>
</div>
</div>
<div class="section" id="add-white-noise-simulation">
<h3>9.2.3.7.3. Add white noise simulation<a class="headerlink" href="#add-white-noise-simulation" title="Permalink to this headline">¶</a></h3>
<p>The vidtv tuner already has code to identify whether the chosen frequency
is too far away from a table of valid frequencies. For now, this means that
the demodulator can eventually lose the lock on the signal, since the tuner will
report a bad signal quality.</p>
<p>A nice addition is to simulate some noise when the signal quality is bad by:</p>
<ul class="simple">
<li>Randomly dropping some TS packets. This will trigger a continuity error if the
continuity counter is updated but the packet is not passed on to the demux.</li>
<li>Updating the error statistics accordingly (e.g. BER, etc).</li>
<li>Simulating some noise in the encoded data.</li>
</ul>
</div>
</div>
<div class="section" id="functions-and-structs-used-within-vidtv">
<h2>9.2.3.8. Functions and structs used within vidtv<a class="headerlink" href="#functions-and-structs-used-within-vidtv" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.vidtv_dvb">
struct <code class="descname">vidtv_dvb</code><a class="headerlink" href="#c.vidtv_dvb" title="Permalink to this definition">¶</a></dt>
<dd><p>Vidtv bridge state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_dvb {
  struct platform_device *pdev;
  struct dvb_frontend *fe[NUM_FE];
  struct dvb_adapter adapter;
  struct dvb_demux demux;
  struct dmxdev dmx_dev;
  struct dmx_frontend dmx_fe[NUM_FE];
  struct i2c_adapter i2c_adapter;
  struct i2c_client *i2c_client_demod[NUM_FE];
  struct i2c_client *i2c_client_tuner[NUM_FE];
  u32 nfeeds;
  struct mutex feed_lock;
  bool streaming;
  struct vidtv_mux *mux;
#ifdef CONFIG_MEDIA_CONTROLLER_DVB;
  struct media_device mdev;
#endif ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">pdev</span></code></dt>
<dd>The platform device. Obtained when the bridge is probed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fe</span></code></dt>
<dd>The frontends. Obtained when probing the demodulator modules.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adapter</span></code></dt>
<dd>Represents a DTV adapter. See ‘dvb_register_adapter’.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">demux</span></code></dt>
<dd>The demux used by the <a class="reference internal" href="../dtv-demux.html#c.dvb_dmx_swfilter_packets" title="dvb_dmx_swfilter_packets"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_dmx_swfilter_packets()</span></code></a> call.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmx_dev</span></code></dt>
<dd>Represents a demux device.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dmx_fe</span></code></dt>
<dd>The frontends associated with the demux.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c_adapter</span></code></dt>
<dd>The i2c_adapter associated with the bridge driver.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c_client_demod</span></code></dt>
<dd>The i2c_clients associated with the demodulator modules.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c_client_tuner</span></code></dt>
<dd>The i2c_clients associated with the tuner modules.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nfeeds</span></code></dt>
<dd>The number of feeds active.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">feed_lock</span></code></dt>
<dd>Protects access to the start/stop stream logic/data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">streaming</span></code></dt>
<dd>Whether we are streaming now.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mux</span></code></dt>
<dd>The abstraction responsible for delivering MPEG TS packets to the bridge.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mdev</span></code></dt>
<dd>The media_device struct for media controller support.</dd>
</dl>
<dl class="type">
<dt id="c.vidtv_channel">
struct <code class="descname">vidtv_channel</code><a class="headerlink" href="#c.vidtv_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>A ‘channel’ abstraction</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_channel {
  char *name;
  u16 transport_stream_id;
  struct vidtv_psi_table_sdt_service *service;
  u16 program_num;
  struct vidtv_psi_table_pat_program *program;
  struct vidtv_psi_table_pmt_stream *streams;
  struct vidtv_encoder *encoders;
  struct vidtv_psi_table_eit_event *events;
  struct vidtv_channel *next;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>name of the channel</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transport_stream_id</span></code></dt>
<dd>a number to identify the TS, chosen at will.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">service</span></code></dt>
<dd>A _single_ service. Will be concatenated into the SDT.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">program_num</span></code></dt>
<dd>The link between PAT, PMT and SDT.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">program</span></code></dt>
<dd>A _single_ program with one or more streams associated with it.
Will be concatenated into the PAT.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">streams</span></code></dt>
<dd>A stream loop used to populate the PMT section for ‘program’</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoders</span></code></dt>
<dd>A encoder loop. There must be one encoder for each stream.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events</span></code></dt>
<dd>Optional event information. This will feed into the EIT.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt>
<dd>Optionally chain this channel.</dd>
</dl>
<p><strong>Description</strong></p>
<p>When vidtv boots, it will create some hardcoded channels.
Their services will be concatenated to populate the SDT.
Their programs will be concatenated to populate the PAT
For each program in the PAT, a PMT section will be created
The PMT section for a channel will be assigned its streams.
Every stream will have its corresponding encoder polled to produce TS packets
These packets may be interleaved by the mux and then delivered to the bridge</p>
<dl class="function">
<dt id="c.vidtv_channel_si_init">
int <code class="descname">vidtv_channel_si_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vidtv_mux" title="vidtv_mux">vidtv_mux</a><em>&nbsp;*m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_channel_si_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Init the PSI tables from the channels in the mux</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_mux</span> <span class="pre">*m</span></code></dt>
<dd>The mux containing the channels.</dd>
</dl>
<dl class="function">
<dt id="c.vidtv_channels_init">
int <code class="descname">vidtv_channels_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vidtv_mux" title="vidtv_mux">vidtv_mux</a><em>&nbsp;*m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_channels_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Init hardcoded, fake ‘channels’.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_mux</span> <span class="pre">*m</span></code></dt>
<dd>The mux to store the channels into.</dd>
</dl>
<dl class="type">
<dt id="c.vidtv_demod_cnr_to_qual_s">
struct <code class="descname">vidtv_demod_cnr_to_qual_s</code><a class="headerlink" href="#c.vidtv_demod_cnr_to_qual_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Map CNR values to a given combination of modulation and fec_inner</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_demod_cnr_to_qual_s {
  u32 modulation;
  u32 fec;
  u32 cnr_ok;
  u32 cnr_good;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">modulation</span></code></dt>
<dd>see enum fe_modulation</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fec</span></code></dt>
<dd>see enum fe_fec_rate</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cnr_ok</span></code></dt>
<dd>S/N threshold to consider the signal as OK. Below that, there’s
a chance of losing sync.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cnr_good</span></code></dt>
<dd>S/N threshold to consider the signal strong.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct matches values for ‘good’ and ‘ok’ CNRs given the combination
of modulation and fec_inner in use. We might simulate some noise if the
signal quality is not too good.</p>
<p>The values were taken from libdvbv5.</p>
<dl class="type">
<dt id="c.vidtv_demod_config">
struct <code class="descname">vidtv_demod_config</code><a class="headerlink" href="#c.vidtv_demod_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration used to init the demod</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_demod_config {
  u8 drop_tslock_prob_on_low_snr;
  u8 recover_tslock_prob_on_good_snr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">drop_tslock_prob_on_low_snr</span></code></dt>
<dd>probability of losing the lock due to low snr</dd>
<dt><code class="docutils literal notranslate"><span class="pre">recover_tslock_prob_on_good_snr</span></code></dt>
<dd>probability of recovering when the signal
improves</dd>
</dl>
<p><strong>Description</strong></p>
<p>The configuration used to init the demodulator module, usually filled
by a bridge driver. For vidtv, this is filled by vidtv_bridge before the
demodulator module is probed.</p>
<dl class="type">
<dt id="c.vidtv_demod_state">
struct <code class="descname">vidtv_demod_state</code><a class="headerlink" href="#c.vidtv_demod_state" title="Permalink to this definition">¶</a></dt>
<dd><p>The demodulator state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_demod_state {
  struct dvb_frontend frontend;
  struct vidtv_demod_config config;
  enum fe_status status;
  u16 tuner_cnr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">frontend</span></code></dt>
<dd>The frontend structure allocated by the demod.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config</span></code></dt>
<dd>The config used to init the demod.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt>
<dd>the demod status.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tuner_cnr</span></code></dt>
<dd>current S/N ratio for the signal carrier</dd>
</dl>
<dl class="type">
<dt id="c.vidtv_encoder">
struct <code class="descname">vidtv_encoder</code><a class="headerlink" href="#c.vidtv_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic encoder type.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_encoder {
  enum vidtv_encoder_id id;
  char *name;
  u8 *encoder_buf;
  u32 encoder_buf_sz;
  u32 encoder_buf_offset;
  u64 sample_count;
  struct vidtv_access_unit *access_units;
  void *src_buf;
  u32 src_buf_sz;
  u32 src_buf_offset;
  bool is_video_encoder;
  void *ctx;
  __be16 stream_id;
  __be16 es_pid;
  void *(*encode)(struct vidtv_encoder *e);
  u32 (*clear)(struct vidtv_encoder *e);
  struct vidtv_encoder *sync;
  u32 sampling_rate_hz;
  void (*last_sample_cb)(u32 sample_no);
  void (*destroy)(struct vidtv_encoder *e);
  struct vidtv_encoder *next;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt>
<dd>So we can cast to a concrete implementation when needed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>Usually the same as the stream name.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_buf</span></code></dt>
<dd>The encoder internal buffer for the access units.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_buf_sz</span></code></dt>
<dd>The encoder buffer size, in bytes</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_buf_offset</span></code></dt>
<dd>Our byte position in the encoder buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sample_count</span></code></dt>
<dd>How many samples we have encoded in total.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">access_units</span></code></dt>
<dd>encoder payload units, used for clock references</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_buf</span></code></dt>
<dd>The source of raw data to be encoded, encoder might set a
default if null.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_buf_sz</span></code></dt>
<dd>size of <strong>src_buf</strong>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_buf_offset</span></code></dt>
<dd>Our position in the source buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_video_encoder</span></code></dt>
<dd>Whether this a video encoder (as opposed to audio)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx</span></code></dt>
<dd>Encoder-specific state.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_id</span></code></dt>
<dd>Examples: Audio streams (0xc0-0xdf), Video streams
(0xe0-0xef).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">es_pid</span></code></dt>
<dd>The TS PID to use for the elementary stream in this encoder.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encode</span></code></dt>
<dd>Prepare enough AUs for the given amount of time.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clear</span></code></dt>
<dd>Clear the encoder output.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync</span></code></dt>
<dd>Attempt to synchronize with this encoder.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sampling_rate_hz</span></code></dt>
<dd>The sampling rate (or fps, if video) used.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_sample_cb</span></code></dt>
<dd>Called when the encoder runs out of data.This is
so the source can read data in a
piecemeal fashion instead of having to
provide it all at once.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy</span></code></dt>
<dd>Destroy this encoder, freeing allocated resources.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt>
<dd>Next in the chain</dd>
</dl>
<dl class="type">
<dt id="c.vidtv_mux_timing">
struct <code class="descname">vidtv_mux_timing</code><a class="headerlink" href="#c.vidtv_mux_timing" title="Permalink to this definition">¶</a></dt>
<dd><p>Timing related information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_mux_timing {
  u64 start_jiffies;
  u64 current_jiffies;
  u64 past_jiffies;
  u64 clk;
  u64 pcr_period_usecs;
  u64 si_period_usecs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">start_jiffies</span></code></dt>
<dd>The value of ‘jiffies’ when we started the mux thread.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">current_jiffies</span></code></dt>
<dd>The value of ‘jiffies’ for the current iteration.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">past_jiffies</span></code></dt>
<dd>The value of ‘jiffies’ for the past iteration.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clk</span></code></dt>
<dd>A 27Mhz clock from which we will drive the PCR. Updated proportionally
on every iteration.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcr_period_usecs</span></code></dt>
<dd>How often we should send PCR packets.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">si_period_usecs</span></code></dt>
<dd>How often we should send PSI packets.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to decide when PCR or PSI packets should be sent. This will also
provide storage for the clock, which is used to compute the value for the PCR.</p>
<dl class="type">
<dt id="c.vidtv_mux_si">
struct <code class="descname">vidtv_mux_si</code><a class="headerlink" href="#c.vidtv_mux_si" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the PSI context.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_mux_si {
  struct vidtv_psi_table_pat *pat;
  struct vidtv_psi_table_pmt **pmt_secs;
  struct vidtv_psi_table_sdt *sdt;
  struct vidtv_psi_table_nit *nit;
  struct vidtv_psi_table_eit *eit;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">pat</span></code></dt>
<dd>The PAT in use by the muxer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmt_secs</span></code></dt>
<dd>The PMT sections in use by the muxer. One for each program in the PAT.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sdt</span></code></dt>
<dd>The SDT in use by the muxer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nit</span></code></dt>
<dd>The NIT in use by the muxer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eit</span></code></dt>
<dd>the EIT in use by the muxer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to store the PAT, PMT sections and SDT in use by the muxer.</p>
<p>The muxer acquire these by looking into the hardcoded channels in
vidtv_channel and then periodically sends the TS packets for them&gt;</p>
<dl class="type">
<dt id="c.vidtv_mux_pid_ctx">
struct <code class="descname">vidtv_mux_pid_ctx</code><a class="headerlink" href="#c.vidtv_mux_pid_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the context for a given TS PID.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_mux_pid_ctx {
  u16 pid;
  u8 cc;
  struct hlist_node h;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">pid</span></code></dt>
<dd>The TS PID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cc</span></code></dt>
<dd>The continuity counter for this PID. It is incremented on every TS
pack and it will wrap around at 0xf0. If the decoder notices a sudden jump in
this counter this will trigger a discontinuity state.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code></dt>
<dd>This is embedded in a hash table, mapping pid -&gt; vidtv_mux_pid_ctx</dd>
</dl>
<dl class="type">
<dt id="c.vidtv_mux">
struct <code class="descname">vidtv_mux</code><a class="headerlink" href="#c.vidtv_mux" title="Permalink to this definition">¶</a></dt>
<dd><p>A muxer abstraction loosely based in libavcodec/mpegtsenc.c</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_mux {
  struct dvb_frontend *fe;
  struct device *dev;
  struct vidtv_mux_timing timing;
  u32 mux_rate_kbytes_sec;
  unsigned long pid_ctx[1 &lt;&lt; ((3) - 1)];
  void (*on_new_packets_available_cb)(void *priv, u8 *buf, u32 npackets);
  u8 *mux_buf;
  u32 mux_buf_sz;
  u32 mux_buf_offset;
  struct vidtv_channel  *channels;
  struct vidtv_mux_si si;
  u64 num_streamed_pcr;
  u64 num_streamed_si;
  struct work_struct mpeg_thread;
  bool streaming;
  u16 pcr_pid;
  u16 transport_stream_id;
  u16 network_id;
  char *network_name;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">fe</span></code></dt>
<dd>The frontend structure allocated by the muxer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt>
<dd>pointer to <a class="reference internal" href="../../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timing</span></code></dt>
<dd>Keeps track of timing related information.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mux_rate_kbytes_sec</span></code></dt>
<dd>The bit rate for the TS, in kbytes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid_ctx</span></code></dt>
<dd>A hash table to keep track of per-PID metadata.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">on_new_packets_available_cb</span></code></dt>
<dd>A callback to inform of new TS packets ready.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mux_buf</span></code></dt>
<dd>A pointer to a buffer for this muxer. TS packets are stored there
and then passed on to the bridge driver.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mux_buf_sz</span></code></dt>
<dd>The size for ‘mux_buf’.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mux_buf_offset</span></code></dt>
<dd>The current offset into ‘mux_buf’.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channels</span></code></dt>
<dd>The channels associated with this muxer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">si</span></code></dt>
<dd>Keeps track of the PSI context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_streamed_pcr</span></code></dt>
<dd>Number of PCR packets streamed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_streamed_si</span></code></dt>
<dd>The number of PSI packets streamed.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mpeg_thread</span></code></dt>
<dd>Thread responsible for the muxer loop.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">streaming</span></code></dt>
<dd>whether ‘mpeg_thread’ is running.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcr_pid</span></code></dt>
<dd>The TS PID used for the PSI packets. All channels will share the
same PCR.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transport_stream_id</span></code></dt>
<dd>The transport stream ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">network_id</span></code></dt>
<dd>The network ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">network_name</span></code></dt>
<dd>The network name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt>
<dd>Private data.</dd>
</dl>
<dl class="type">
<dt id="c.vidtv_mux_init_args">
struct <code class="descname">vidtv_mux_init_args</code><a class="headerlink" href="#c.vidtv_mux_init_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments used to inix the muxer.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_mux_init_args {
  u32 mux_rate_kbytes_sec;
  void (*on_new_packets_available_cb)(void *priv, u8 *buf, u32 npackets);
  u32 mux_buf_sz;
  u64 pcr_period_usecs;
  u64 si_period_usecs;
  u16 pcr_pid;
  u16 transport_stream_id;
  struct vidtv_channel *channels;
  u16 network_id;
  char *network_name;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">mux_rate_kbytes_sec</span></code></dt>
<dd>The bit rate for the TS, in kbytes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">on_new_packets_available_cb</span></code></dt>
<dd>A callback to inform of new TS packets ready.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mux_buf_sz</span></code></dt>
<dd>The size for ‘mux_buf’.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcr_period_usecs</span></code></dt>
<dd>How often we should send PCR packets.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">si_period_usecs</span></code></dt>
<dd>How often we should send PSI packets.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcr_pid</span></code></dt>
<dd>The TS PID used for the PSI packets. All channels will share the
same PCR.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transport_stream_id</span></code></dt>
<dd>The transport stream ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channels</span></code></dt>
<dd>an optional list of channels to use</dd>
<dt><code class="docutils literal notranslate"><span class="pre">network_id</span></code></dt>
<dd>The network ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">network_name</span></code></dt>
<dd>The network name</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt>
<dd>Private data.</dd>
</dl>
<dl class="type">
<dt id="c.pes_header_write_args">
struct <code class="descname">pes_header_write_args</code><a class="headerlink" href="#c.pes_header_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments to write a PES header.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pes_header_write_args {
  void *dest_buf;
  u32 dest_offset;
  u32 dest_buf_sz;
  u32 encoder_id;
  bool send_pts;
  u64 pts;
  bool send_dts;
  u64 dts;
  u16 stream_id;
  u32 n_pes_h_s_bytes;
  u32 access_unit_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf</span></code></dt>
<dd>The buffer to write into.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_offset</span></code></dt>
<dd>where to start writing in the dest_buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf_sz</span></code></dt>
<dd>The size of the dest_buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_id</span></code></dt>
<dd>Encoder id (see vidtv_encoder.h)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_pts</span></code></dt>
<dd>Should we send PTS?</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pts</span></code></dt>
<dd>PTS value to send.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_dts</span></code></dt>
<dd>Should we send DTS?</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dts</span></code></dt>
<dd>DTS value to send.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_id</span></code></dt>
<dd>The stream id to use. Ex: Audio streams (0xc0-0xdf), Video
streams (0xe0-0xef).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_pes_h_s_bytes</span></code></dt>
<dd>Padding bytes. Might be used by an encoder if needed, gets
discarded by the decoder.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">access_unit_len</span></code></dt>
<dd>The size of _one_ access unit (with any headers it might need)</dd>
</dl>
<dl class="type">
<dt id="c.pes_ts_header_write_args">
struct <code class="descname">pes_ts_header_write_args</code><a class="headerlink" href="#c.pes_ts_header_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments to write a TS header.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pes_ts_header_write_args {
  void *dest_buf;
  u32 dest_offset;
  u32 dest_buf_sz;
  u16 pid;
  u8 *continuity_counter;
  bool wrote_pes_header;
  u32 n_stuffing_bytes;
  u64 pcr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf</span></code></dt>
<dd>The buffer to write into.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_offset</span></code></dt>
<dd>where to start writing in the dest_buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf_sz</span></code></dt>
<dd>The size of the dest_buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid</span></code></dt>
<dd>The PID to use for the TS packets.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>Incremented on every new TS packet.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wrote_pes_header</span></code></dt>
<dd>Flag to indicate that the PES header was written</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_stuffing_bytes</span></code></dt>
<dd>Padding bytes. Might be used by an encoder if needed, gets
discarded by the decoder.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcr</span></code></dt>
<dd>counter driven by a 27Mhz clock.</dd>
</dl>
<dl class="type">
<dt id="c.pes_write_args">
struct <code class="descname">pes_write_args</code><a class="headerlink" href="#c.pes_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments for the packetizer.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pes_write_args {
  void *dest_buf;
  void *from;
  u32 access_unit_len;
  u32 dest_offset;
  u32 dest_buf_sz;
  u16 pid;
  u32 encoder_id;
  u8 *continuity_counter;
  u16 stream_id;
  bool send_pts;
  u64 pts;
  bool send_dts;
  u64 dts;
  u32 n_pes_h_s_bytes;
  u64 pcr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf</span></code></dt>
<dd>The buffer to write into.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">from</span></code></dt>
<dd>A pointer to the encoder buffer containing one access unit.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">access_unit_len</span></code></dt>
<dd>The size of _one_ access unit (with any headers it might need)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_offset</span></code></dt>
<dd>where to start writing in the dest_buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf_sz</span></code></dt>
<dd>The size of the dest_buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid</span></code></dt>
<dd>The PID to use for the TS packets.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_id</span></code></dt>
<dd>Encoder id (see vidtv_encoder.h)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>Incremented on every new TS packet.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_id</span></code></dt>
<dd>The stream id to use. Ex: Audio streams (0xc0-0xdf), Video
streams (0xe0-0xef).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_pts</span></code></dt>
<dd>Should we send PTS?</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pts</span></code></dt>
<dd>PTS value to send.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_dts</span></code></dt>
<dd>Should we send DTS?</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dts</span></code></dt>
<dd>DTS value to send.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_pes_h_s_bytes</span></code></dt>
<dd>Padding bytes. Might be used by an encoder if needed, gets
discarded by the decoder.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcr</span></code></dt>
<dd>counter driven by a 27Mhz clock.</dd>
</dl>
<dl class="function">
<dt id="c.vidtv_pes_write_into">
u32 <code class="descname">vidtv_pes_write_into</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pes_write_args" title="pes_write_args">pes_write_args</a><em>&nbsp;*args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_pes_write_into" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a PES packet as MPEG-TS packets into a buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pes_write_args</span> <span class="pre">*args</span></code></dt>
<dd>The args to use when writing</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function translate the ES data for one access unit
from an encoder into MPEG TS packets. It does so by first encapsulating it
with a PES header and then splitting it into TS packets.</p>
<p>The data is then written into the buffer pointed to by ‘args.buf’</p>
<p><strong>Return</strong></p>
<p>The number of bytes written into the buffer. This is usually NOT
equal to the size of the access unit, since we need space for PES headers, TS headers
and padding bytes, if any.</p>
<dl class="type">
<dt id="c.psi_write_args">
struct <code class="descname">psi_write_args</code><a class="headerlink" href="#c.psi_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments for the PSI packetizer.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct psi_write_args {
  void *dest_buf;
  void *from;
  size_t len;
  u32 dest_offset;
  u16 pid;
  bool new_psi_section;
  u8 *continuity_counter;
  bool is_crc;
  u32 dest_buf_sz;
  u32 *crc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf</span></code></dt>
<dd>The buffer to write into.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">from</span></code></dt>
<dd>PSI data to be copied.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt>
<dd>How much to write.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_offset</span></code></dt>
<dd>where to start writing in the dest_buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid</span></code></dt>
<dd>TS packet ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_psi_section</span></code></dt>
<dd>Set when starting a table section.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>Incremented on every new packet.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_crc</span></code></dt>
<dd>Set when writing the CRC at the end.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf_sz</span></code></dt>
<dd>The size of the dest_buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crc</span></code></dt>
<dd>a pointer to store the crc for this chunk</dd>
</dl>
<dl class="type">
<dt id="c.desc_write_args">
struct <code class="descname">desc_write_args</code><a class="headerlink" href="#c.desc_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments in order to write a descriptor.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct desc_write_args {
  void *dest_buf;
  u32 dest_offset;
  struct vidtv_psi_desc *desc;
  u16 pid;
  u8 *continuity_counter;
  u32 dest_buf_sz;
  u32 *crc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf</span></code></dt>
<dd>The buffer to write into.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_offset</span></code></dt>
<dd>where to start writing in the dest_buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt>
<dd>A pointer to the descriptor</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid</span></code></dt>
<dd>TS packet ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>Incremented on every new packet.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf_sz</span></code></dt>
<dd>The size of the dest_buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crc</span></code></dt>
<dd>a pointer to store the crc for this chunk</dd>
</dl>
<dl class="type">
<dt id="c.crc32_write_args">
struct <code class="descname">crc32_write_args</code><a class="headerlink" href="#c.crc32_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments in order to write the CRC at the end of the PSI tables.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct crc32_write_args {
  void *dest_buf;
  u32 dest_offset;
  __be32 crc;
  u16 pid;
  u8 *continuity_counter;
  u32 dest_buf_sz;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf</span></code></dt>
<dd>The buffer to write into.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_offset</span></code></dt>
<dd>where to start writing in the dest_buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crc</span></code></dt>
<dd>the CRC value to write</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid</span></code></dt>
<dd>TS packet ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>Incremented on every new packet.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf_sz</span></code></dt>
<dd>The size of the dest_buffer</dd>
</dl>
<dl class="type">
<dt id="c.header_write_args">
struct <code class="descname">header_write_args</code><a class="headerlink" href="#c.header_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments in order to write the common table header</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct header_write_args {
  void *dest_buf;
  u32 dest_offset;
  struct vidtv_psi_table_header *h;
  u16 pid;
  u8 *continuity_counter;
  u32 dest_buf_sz;
  u32 *crc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf</span></code></dt>
<dd>The buffer to write into.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_offset</span></code></dt>
<dd>where to start writing in the dest_buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code></dt>
<dd>a pointer to the header.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid</span></code></dt>
<dd>TS packet ID.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>Incremented on every new packet.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf_sz</span></code></dt>
<dd>The size of the dest_buffer</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crc</span></code></dt>
<dd>a pointer to store the crc for this chunk</dd>
</dl>
<dl class="function">
<dt id="c.vidtv_psi_sdt_service_assign">
void <code class="descname">vidtv_psi_sdt_service_assign</code><span class="sig-paren">(</span>struct vidtv_psi_table_sdt<em>&nbsp;*sdt</em>, struct vidtv_psi_table_sdt_service<em>&nbsp;*service</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_sdt_service_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns the service loop to the SDT.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_sdt</span> <span class="pre">*sdt</span></code></dt>
<dd>The SDT to assign to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_sdt_service</span> <span class="pre">*service</span></code></dt>
<dd>The service loop (one or more services)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will free the previous service loop in the table.
This will assign ownership of the service loop to the table, i.e. the table
will free this service loop when a call to its destroy function is made.</p>
<dl class="function">
<dt id="c.vidtv_psi_desc_assign">
void <code class="descname">vidtv_psi_desc_assign</code><span class="sig-paren">(</span>struct vidtv_psi_desc<em>&nbsp;**to</em>, struct vidtv_psi_desc<em>&nbsp;*desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_desc_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a descriptor loop at some point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_desc</span> <span class="pre">**to</span></code></dt>
<dd>Where to assign this descriptor loop to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_desc</span> <span class="pre">*desc</span></code></dt>
<dd>The descriptor loop that will be assigned.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will free the loop in ‘to’, if any.</p>
<dl class="function">
<dt id="c.vidtv_pmt_desc_assign">
void <code class="descname">vidtv_pmt_desc_assign</code><span class="sig-paren">(</span>struct vidtv_psi_table_pmt<em>&nbsp;*pmt</em>, struct vidtv_psi_desc<em>&nbsp;**to</em>, struct vidtv_psi_desc<em>&nbsp;*desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_pmt_desc_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a descriptor loop at some point in a PMT section.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pmt</span> <span class="pre">*pmt</span></code></dt>
<dd>The PMT section that will contain the descriptor loop</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_desc</span> <span class="pre">**to</span></code></dt>
<dd>Where in the PMT to assign this descriptor loop to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_desc</span> <span class="pre">*desc</span></code></dt>
<dd>The descriptor loop that will be assigned.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will free the loop in ‘to’, if any.
This will assign ownership of the loop to the table, i.e. the table
will free this loop when a call to its destroy function is made.</p>
<dl class="function">
<dt id="c.vidtv_sdt_desc_assign">
void <code class="descname">vidtv_sdt_desc_assign</code><span class="sig-paren">(</span>struct vidtv_psi_table_sdt<em>&nbsp;*sdt</em>, struct vidtv_psi_desc<em>&nbsp;**to</em>, struct vidtv_psi_desc<em>&nbsp;*desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_sdt_desc_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a descriptor loop at some point in a SDT.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_sdt</span> <span class="pre">*sdt</span></code></dt>
<dd>The SDT that will contain the descriptor loop</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_desc</span> <span class="pre">**to</span></code></dt>
<dd>Where in the PMT to assign this descriptor loop to</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_desc</span> <span class="pre">*desc</span></code></dt>
<dd>The descriptor loop that will be assigned.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will free the loop in ‘to’, if any.
This will assign ownership of the loop to the table, i.e. the table
will free this loop when a call to its destroy function is made.</p>
<dl class="function">
<dt id="c.vidtv_psi_pat_program_assign">
void <code class="descname">vidtv_psi_pat_program_assign</code><span class="sig-paren">(</span>struct vidtv_psi_table_pat<em>&nbsp;*pat</em>, struct vidtv_psi_table_pat_program<em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_pat_program_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns the program loop to the PAT.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pat</span> <span class="pre">*pat</span></code></dt>
<dd>The PAT to assign to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pat_program</span> <span class="pre">*p</span></code></dt>
<dd>The program loop (one or more programs)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will free the previous program loop in the table.
This will assign ownership of the program loop to the table, i.e. the table
will free this program loop when a call to its destroy function is made.</p>
<dl class="function">
<dt id="c.vidtv_psi_pmt_stream_assign">
void <code class="descname">vidtv_psi_pmt_stream_assign</code><span class="sig-paren">(</span>struct vidtv_psi_table_pmt<em>&nbsp;*pmt</em>, struct vidtv_psi_table_pmt_stream<em>&nbsp;*s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_pmt_stream_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns the stream loop to the PAT.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pmt</span> <span class="pre">*pmt</span></code></dt>
<dd>The PMT to assign to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pmt_stream</span> <span class="pre">*s</span></code></dt>
<dd>The stream loop (one or more streams)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will free the previous stream loop in the table.
This will assign ownership of the stream loop to the table, i.e. the table
will free this stream loop when a call to its destroy function is made.</p>
<dl class="function">
<dt id="c.vidtv_psi_pmt_create_sec_for_each_pat_entry">
struct vidtv_psi_table_pmt** <code class="descname">vidtv_psi_pmt_create_sec_for_each_pat_entry</code><span class="sig-paren">(</span>struct vidtv_psi_table_pat<em>&nbsp;*pat</em>, u16<em>&nbsp;pcr_pid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_pmt_create_sec_for_each_pat_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a PMT section for each program found in the PAT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pat</span> <span class="pre">*pat</span></code></dt>
<dd>The PAT to look for programs.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">pcr_pid</span></code></dt>
<dd>packet ID for the PCR to be used for the program described in this
PMT section</dd>
</dl>
<dl class="function">
<dt id="c.vidtv_psi_pmt_get_pid">
u16 <code class="descname">vidtv_psi_pmt_get_pid</code><span class="sig-paren">(</span>struct vidtv_psi_table_pmt<em>&nbsp;*section</em>, struct vidtv_psi_table_pat<em>&nbsp;*pat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_pmt_get_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the TS PID for a PMT section.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pmt</span> <span class="pre">*section</span></code></dt>
<dd>The PMT section whose PID we want to retrieve.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pat</span> <span class="pre">*pat</span></code></dt>
<dd>The PAT table to look into.</dd>
</dl>
<p><strong>Return</strong></p>
<p>the TS PID for ‘section’</p>
<dl class="function">
<dt id="c.vidtv_psi_pat_table_update_sec_len">
void <code class="descname">vidtv_psi_pat_table_update_sec_len</code><span class="sig-paren">(</span>struct vidtv_psi_table_pat<em>&nbsp;*pat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_pat_table_update_sec_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute and update the PAT section length.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pat</span> <span class="pre">*pat</span></code></dt>
<dd>The PAT whose length is to be updated.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will traverse the table and accumulate the length of its components,
which is then used to replace the ‘section_length’ field.</p>
<p>If section_length &gt; MAX_SECTION_LEN, the operation fails.</p>
<dl class="function">
<dt id="c.vidtv_psi_pmt_table_update_sec_len">
void <code class="descname">vidtv_psi_pmt_table_update_sec_len</code><span class="sig-paren">(</span>struct vidtv_psi_table_pmt<em>&nbsp;*pmt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_pmt_table_update_sec_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute and update the PMT section length.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pmt</span> <span class="pre">*pmt</span></code></dt>
<dd>The PMT whose length is to be updated.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will traverse the table and accumulate the length of its components,
which is then used to replace the ‘section_length’ field.</p>
<p>If section_length &gt; MAX_SECTION_LEN, the operation fails.</p>
<dl class="function">
<dt id="c.vidtv_psi_sdt_table_update_sec_len">
void <code class="descname">vidtv_psi_sdt_table_update_sec_len</code><span class="sig-paren">(</span>struct vidtv_psi_table_sdt<em>&nbsp;*sdt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_sdt_table_update_sec_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute and update the SDT section length.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_sdt</span> <span class="pre">*sdt</span></code></dt>
<dd>The SDT whose length is to be updated.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will traverse the table and accumulate the length of its components,
which is then used to replace the ‘section_length’ field.</p>
<p>If section_length &gt; MAX_SECTION_LEN, the operation fails.</p>
<dl class="type">
<dt id="c.vidtv_psi_pat_write_args">
struct <code class="descname">vidtv_psi_pat_write_args</code><a class="headerlink" href="#c.vidtv_psi_pat_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments for writing a PAT table</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_psi_pat_write_args {
  char *buf;
  u32 offset;
  struct vidtv_psi_table_pat *pat;
  u32 buf_sz;
  u8 *continuity_counter;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt>
<dd>The destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt>
<dd>The offset into the destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pat</span></code></dt>
<dd>A pointer to the PAT.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_sz</span></code></dt>
<dd>The size of the destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>A pointer to the CC. Incremented on every new packet.</dd>
</dl>
<dl class="function">
<dt id="c.vidtv_psi_pat_write_into">
u32 <code class="descname">vidtv_psi_pat_write_into</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vidtv_psi_pat_write_args" title="vidtv_psi_pat_write_args">vidtv_psi_pat_write_args</a><em>&nbsp;*args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_pat_write_into" title="Permalink to this definition">¶</a></dt>
<dd><p>Write PAT as MPEG-TS packets into a buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_pat_write_args</span> <span class="pre">*args</span></code></dt>
<dd>An instance of <a class="reference internal" href="#c.vidtv_psi_pat_write_args" title="vidtv_psi_pat_write_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_pat_write_args</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function writes the MPEG TS packets for a PAT table into a buffer.
Calling code will usually generate the PAT via a call to its init function
and thus is responsible for freeing it.</p>
<p><strong>Return</strong></p>
<p>The number of bytes written into the buffer. This is NOT
equal to the size of the PAT, since more space is needed for TS headers during TS
encapsulation.</p>
<dl class="type">
<dt id="c.vidtv_psi_sdt_write_args">
struct <code class="descname">vidtv_psi_sdt_write_args</code><a class="headerlink" href="#c.vidtv_psi_sdt_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments for writing a SDT table</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_psi_sdt_write_args {
  char *buf;
  u32 offset;
  struct vidtv_psi_table_sdt *sdt;
  u32 buf_sz;
  u8 *continuity_counter;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt>
<dd>The destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt>
<dd>The offset into the destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sdt</span></code></dt>
<dd>A pointer to the SDT.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_sz</span></code></dt>
<dd>The size of the destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>A pointer to the CC. Incremented on every new packet.</dd>
</dl>
<dl class="function">
<dt id="c.vidtv_psi_sdt_write_into">
u32 <code class="descname">vidtv_psi_sdt_write_into</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vidtv_psi_sdt_write_args" title="vidtv_psi_sdt_write_args">vidtv_psi_sdt_write_args</a><em>&nbsp;*args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_sdt_write_into" title="Permalink to this definition">¶</a></dt>
<dd><p>Write SDT as MPEG-TS packets into a buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_sdt_write_args</span> <span class="pre">*args</span></code></dt>
<dd>an instance of <a class="reference internal" href="#c.vidtv_psi_sdt_write_args" title="vidtv_psi_sdt_write_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_sdt_write_args</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function writes the MPEG TS packets for a SDT table into a buffer.
Calling code will usually generate the SDT via a call to its init function
and thus is responsible for freeing it.</p>
<p><strong>Return</strong></p>
<p>The number of bytes written into the buffer. This is NOT
equal to the size of the SDT, since more space is needed for TS headers during TS
encapsulation.</p>
<dl class="type">
<dt id="c.vidtv_psi_pmt_write_args">
struct <code class="descname">vidtv_psi_pmt_write_args</code><a class="headerlink" href="#c.vidtv_psi_pmt_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments for writing a PMT section</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_psi_pmt_write_args {
  char *buf;
  u32 offset;
  struct vidtv_psi_table_pmt *pmt;
  u16 pid;
  u32 buf_sz;
  u8 *continuity_counter;
  u16 pcr_pid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt>
<dd>The destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt>
<dd>The offset into the destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pmt</span></code></dt>
<dd>A pointer to the PMT.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid</span></code></dt>
<dd>Program ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_sz</span></code></dt>
<dd>The size of the destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>A pointer to the CC. Incremented on every new packet.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcr_pid</span></code></dt>
<dd>The TS PID used for the PSI packets. All channels will share the
same PCR.</dd>
</dl>
<dl class="function">
<dt id="c.vidtv_psi_pmt_write_into">
u32 <code class="descname">vidtv_psi_pmt_write_into</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vidtv_psi_pmt_write_args" title="vidtv_psi_pmt_write_args">vidtv_psi_pmt_write_args</a><em>&nbsp;*args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_pmt_write_into" title="Permalink to this definition">¶</a></dt>
<dd><p>Write PMT as MPEG-TS packets into a buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_pmt_write_args</span> <span class="pre">*args</span></code></dt>
<dd>an instance of <a class="reference internal" href="#c.vidtv_psi_pmt_write_args" title="vidtv_psi_pmt_write_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_pmt_write_args</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function writes the MPEG TS packets for a PMT section into a buffer.
Calling code will usually generate the PMT section via a call to its init function
and thus is responsible for freeing it.</p>
<p><strong>Return</strong></p>
<p>The number of bytes written into the buffer. This is NOT
equal to the size of the PMT section, since more space is needed for TS headers
during TS encapsulation.</p>
<dl class="function">
<dt id="c.vidtv_psi_find_pmt_sec">
struct vidtv_psi_table_pmt * <code class="descname">vidtv_psi_find_pmt_sec</code><span class="sig-paren">(</span>struct vidtv_psi_table_pmt<em>&nbsp;**pmt_sections</em>, u16<em>&nbsp;nsections</em>, u16<em>&nbsp;program_num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_find_pmt_sec" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the PMT section for ‘program_num’</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_pmt</span> <span class="pre">**pmt_sections</span></code></dt>
<dd>The sections to look into.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">nsections</span></code></dt>
<dd>The number of sections.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">program_num</span></code></dt>
<dd>The ‘program_num’ from PAT pointing to a PMT section.</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the PMT, if found, or NULL.</p>
<dl class="type">
<dt id="c.vidtv_psi_table_transport">
struct <code class="descname">vidtv_psi_table_transport</code><a class="headerlink" href="#c.vidtv_psi_table_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>A entry in the TS loop for the NIT and/or other tables. See ETSI 300 468 section 5.2.1</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_psi_table_transport {
  __be16 transport_id;
  __be16 network_id;
  __be16 bitfield;
  struct vidtv_psi_desc *descriptor;
  struct vidtv_psi_table_transport *next;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">transport_id</span></code></dt>
<dd>The TS ID being described</dd>
<dt><code class="docutils literal notranslate"><span class="pre">network_id</span></code></dt>
<dd>The network_id that contains the TS ID</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitfield</span></code></dt>
<dd>Contains the descriptor loop length</dd>
<dt><code class="docutils literal notranslate"><span class="pre">descriptor</span></code></dt>
<dd>A descriptor loop</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt>
<dd>Pointer to the next entry</dd>
</dl>
<dl class="type">
<dt id="c.vidtv_psi_table_nit">
struct <code class="descname">vidtv_psi_table_nit</code><a class="headerlink" href="#c.vidtv_psi_table_nit" title="Permalink to this definition">¶</a></dt>
<dd><p>A Network Information Table (NIT). See ETSI 300 468 section 5.2.1</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_psi_table_nit {
  struct vidtv_psi_table_header header;
  __be16 bitfield;
  struct vidtv_psi_desc *descriptor;
  __be16 bitfield2;
  struct vidtv_psi_table_transport *transport;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">header</span></code></dt>
<dd>A PSI table header</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitfield</span></code></dt>
<dd>Contains the network descriptor length</dd>
<dt><code class="docutils literal notranslate"><span class="pre">descriptor</span></code></dt>
<dd>A descriptor loop describing the network</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitfield2</span></code></dt>
<dd>Contains the transport stream loop length</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transport</span></code></dt>
<dd>The transport stream loop</dd>
</dl>
<dl class="type">
<dt id="c.vidtv_psi_nit_write_args">
struct <code class="descname">vidtv_psi_nit_write_args</code><a class="headerlink" href="#c.vidtv_psi_nit_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments for writing a NIT section</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_psi_nit_write_args {
  char *buf;
  u32 offset;
  struct vidtv_psi_table_nit *nit;
  u32 buf_sz;
  u8 *continuity_counter;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt>
<dd>The destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt>
<dd>The offset into the destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nit</span></code></dt>
<dd>A pointer to the NIT</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_sz</span></code></dt>
<dd>The size of the destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>A pointer to the CC. Incremented on every new packet.</dd>
</dl>
<dl class="function">
<dt id="c.vidtv_psi_nit_write_into">
u32 <code class="descname">vidtv_psi_nit_write_into</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vidtv_psi_nit_write_args" title="vidtv_psi_nit_write_args">vidtv_psi_nit_write_args</a><em>&nbsp;*args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_nit_write_into" title="Permalink to this definition">¶</a></dt>
<dd><p>Write NIT as MPEG-TS packets into a buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_nit_write_args</span> <span class="pre">*args</span></code></dt>
<dd>an instance of <a class="reference internal" href="#c.vidtv_psi_nit_write_args" title="vidtv_psi_nit_write_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_nit_write_args</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function writes the MPEG TS packets for a NIT table into a buffer.
Calling code will usually generate the NIT via a call to its init function
and thus is responsible for freeing it.</p>
<p><strong>Return</strong></p>
<p>The number of bytes written into the buffer. This is NOT
equal to the size of the NIT, since more space is needed for TS headers during TS
encapsulation.</p>
<dl class="type">
<dt id="c.vidtv_psi_eit_write_args">
struct <code class="descname">vidtv_psi_eit_write_args</code><a class="headerlink" href="#c.vidtv_psi_eit_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments for writing an EIT section</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_psi_eit_write_args {
  char *buf;
  u32 offset;
  struct vidtv_psi_table_eit *eit;
  u32 buf_sz;
  u8 *continuity_counter;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt>
<dd>The destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt>
<dd>The offset into the destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eit</span></code></dt>
<dd>A pointer to the EIT</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_sz</span></code></dt>
<dd>The size of the destination buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>A pointer to the CC. Incremented on every new packet.</dd>
</dl>
<dl class="function">
<dt id="c.vidtv_psi_eit_write_into">
u32 <code class="descname">vidtv_psi_eit_write_into</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vidtv_psi_eit_write_args" title="vidtv_psi_eit_write_args">vidtv_psi_eit_write_args</a><em>&nbsp;*args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_eit_write_into" title="Permalink to this definition">¶</a></dt>
<dd><p>Write EIT as MPEG-TS packets into a buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_eit_write_args</span> <span class="pre">*args</span></code></dt>
<dd>an instance of <a class="reference internal" href="#c.vidtv_psi_nit_write_args" title="vidtv_psi_nit_write_args"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_nit_write_args</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function writes the MPEG TS packets for a EIT table into a buffer.
Calling code will usually generate the EIT via a call to its init function
and thus is responsible for freeing it.</p>
<p><strong>Return</strong></p>
<p>The number of bytes written into the buffer. This is NOT
equal to the size of the EIT, since more space is needed for TS headers during TS
encapsulation.</p>
<dl class="function">
<dt id="c.vidtv_psi_eit_table_update_sec_len">
void <code class="descname">vidtv_psi_eit_table_update_sec_len</code><span class="sig-paren">(</span>struct vidtv_psi_table_eit<em>&nbsp;*eit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_eit_table_update_sec_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute and update the EIT section length.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_eit</span> <span class="pre">*eit</span></code></dt>
<dd>The EIT whose length is to be updated.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will traverse the table and accumulate the length of its components,
which is then used to replace the ‘section_length’ field.</p>
<p>If section_length &gt; EIT_MAX_SECTION_LEN, the operation fails.</p>
<dl class="function">
<dt id="c.vidtv_psi_eit_event_assign">
void <code class="descname">vidtv_psi_eit_event_assign</code><span class="sig-paren">(</span>struct vidtv_psi_table_eit<em>&nbsp;*eit</em>, struct vidtv_psi_table_eit_event<em>&nbsp;*e</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_psi_eit_event_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns the event loop to the EIT.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_eit</span> <span class="pre">*eit</span></code></dt>
<dd>The EIT to assign to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vidtv_psi_table_eit_event</span> <span class="pre">*e</span></code></dt>
<dd>The event loop</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will free the previous event loop in the table.
This will assign ownership of the stream loop to the table, i.e. the table
will free this stream loop when a call to its destroy function is made.</p>
<dl class="type">
<dt id="c.vidtv_s302m_ctx">
struct <code class="descname">vidtv_s302m_ctx</code><a class="headerlink" href="#c.vidtv_s302m_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>s302m encoder context.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_s302m_ctx {
  struct vidtv_encoder *enc;
  u32 frame_index;
  u32 au_count;
  int last_duration;
  unsigned int note_offset;
  enum musical_notes last_tone;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">enc</span></code></dt>
<dd>A pointer to the containing encoder structure.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frame_index</span></code></dt>
<dd>The current frame in a block</dd>
<dt><code class="docutils literal notranslate"><span class="pre">au_count</span></code></dt>
<dd>The total number of access units encoded up to now</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_duration</span></code></dt>
<dd>Duration of the tone currently being played</dd>
<dt><code class="docutils literal notranslate"><span class="pre">note_offset</span></code></dt>
<dd>Position at the music tone array</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_tone</span></code></dt>
<dd>Tone currently being played</dd>
</dl>
<dl class="type">
<dt id="c.vidtv_s302m_encoder_init_args">
struct <code class="descname">vidtv_s302m_encoder_init_args</code><a class="headerlink" href="#c.vidtv_s302m_encoder_init_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Args for the s302m encoder.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_s302m_encoder_init_args {
  char *name;
  void *src_buf;
  u32 src_buf_sz;
  u16 es_pid;
  struct vidtv_encoder *sync;
  void (*last_sample_cb)(u32 sample_no);
  struct vidtv_encoder *head;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt>
<dd>A name to identify this particular instance</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_buf</span></code></dt>
<dd>The source buffer, encoder will default to a sine wave if this is NULL.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_buf_sz</span></code></dt>
<dd>The size of the source buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">es_pid</span></code></dt>
<dd>The MPEG Elementary Stream PID to use.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync</span></code></dt>
<dd>Attempt to synchronize audio with this video encoder, if not NULL.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_sample_cb</span></code></dt>
<dd>A callback called when the encoder runs out of data.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt>
<dd>Add to this chain</dd>
</dl>
<dl class="type">
<dt id="c.pcr_write_args">
struct <code class="descname">pcr_write_args</code><a class="headerlink" href="#c.pcr_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments for the pcr_write_into function.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pcr_write_args {
  void *dest_buf;
  u32 dest_offset;
  u16 pid;
  u32 buf_sz;
  u8 *continuity_counter;
  u64 pcr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf</span></code></dt>
<dd>The buffer to write into.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_offset</span></code></dt>
<dd>The byte offset into the buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid</span></code></dt>
<dd>The TS PID for the PCR packets.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_sz</span></code></dt>
<dd>The size of the buffer in bytes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>The TS continuity_counter.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcr</span></code></dt>
<dd>A sample from the system clock.</dd>
</dl>
<dl class="type">
<dt id="c.null_packet_write_args">
struct <code class="descname">null_packet_write_args</code><a class="headerlink" href="#c.null_packet_write_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments for the null_write_into function</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct null_packet_write_args {
  void *dest_buf;
  u32 dest_offset;
  u32 buf_sz;
  u8 *continuity_counter;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dest_buf</span></code></dt>
<dd>The buffer to write into.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dest_offset</span></code></dt>
<dd>The byte offset into the buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_sz</span></code></dt>
<dd>The size of the buffer in bytes.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuity_counter</span></code></dt>
<dd>The TS continuity_counter.</dd>
</dl>
<dl class="function">
<dt id="c.vidtv_ts_null_write_into">
u32 <code class="descname">vidtv_ts_null_write_into</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.null_packet_write_args" title="null_packet_write_args">null_packet_write_args</a><em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_ts_null_write_into" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a TS null packet into a buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">null_packet_write_args</span> <span class="pre">args</span></code></dt>
<dd>the arguments to use when writing.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will write a null packet into a buffer. This is usually used to
pad TS streams.</p>
<p><strong>Return</strong></p>
<p>The number of bytes written into the buffer.</p>
<dl class="function">
<dt id="c.vidtv_ts_pcr_write_into">
u32 <code class="descname">vidtv_ts_pcr_write_into</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pcr_write_args" title="pcr_write_args">pcr_write_args</a><em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_ts_pcr_write_into" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a PCR packet into a buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pcr_write_args</span> <span class="pre">args</span></code></dt>
<dd>the arguments to use when writing.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will write a PCR packet into a buffer. This is used to
synchronize the clocks between encoders and decoders.</p>
<p><strong>Return</strong></p>
<p>The number of bytes written into the buffer.</p>
<dl class="type">
<dt id="c.vidtv_tuner_config">
struct <code class="descname">vidtv_tuner_config</code><a class="headerlink" href="#c.vidtv_tuner_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration used to init the tuner.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_tuner_config {
  struct dvb_frontend *fe;
  u32 mock_power_up_delay_msec;
  u32 mock_tune_delay_msec;
  u32 vidtv_valid_dvb_t_freqs[NUM_VALID_TUNER_FREQS];
  u32 vidtv_valid_dvb_c_freqs[NUM_VALID_TUNER_FREQS];
  u32 vidtv_valid_dvb_s_freqs[NUM_VALID_TUNER_FREQS];
  u8 max_frequency_shift_hz;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">fe</span></code></dt>
<dd>A pointer to the dvb_frontend structure allocated by vidtv_demod.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mock_power_up_delay_msec</span></code></dt>
<dd>Simulate a power-up delay.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mock_tune_delay_msec</span></code></dt>
<dd>Simulate a tune delay.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vidtv_valid_dvb_t_freqs</span></code></dt>
<dd>The valid DVB-T frequencies to simulate.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vidtv_valid_dvb_c_freqs</span></code></dt>
<dd>The valid DVB-C frequencies to simulate.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vidtv_valid_dvb_s_freqs</span></code></dt>
<dd>The valid DVB-S frequencies to simulate.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_frequency_shift_hz</span></code></dt>
<dd>The maximum frequency shift in HZ allowed when
tuning in a channel</dd>
</dl>
<p><strong>Description</strong></p>
<p>The configuration used to init the tuner module, usually filled
by a bridge driver. For vidtv, this is filled by vidtv_bridge before the
tuner module is probed.</p>
<dl class="function">
<dt id="c.vidtv_memcpy">
u32 <code class="descname">vidtv_memcpy</code><span class="sig-paren">(</span>void<em>&nbsp;*to</em>, size_t<em>&nbsp;to_offset</em>, size_t<em>&nbsp;to_size</em>, const void<em>&nbsp;*from</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_memcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper routine to be used by MPEG-TS generator, in order to avoid going past the output buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*to</span></code></dt>
<dd>Starting element to where a MPEG-TS packet will
be copied.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">to_offset</span></code></dt>
<dd>Starting position of the <strong>to</strong> buffer to be filled.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">to_size</span></code></dt>
<dd>Size of the <strong>to</strong> buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*from</span></code></dt>
<dd>Starting element of the buffer to be copied.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>Number of elements to be copy from <strong>from</strong> buffer
into <strong>to**+ **to_offset</strong> buffer.</dd>
</dl>
<p><strong>Note</strong></p>
<blockquote>
<div>Real digital TV demod drivers should not have memcpy
wrappers. We use it here because emulating MPEG-TS
generation at kernelspace requires some extra care.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Returns the number of bytes written</div></blockquote>
<dl class="function">
<dt id="c.vidtv_memset">
u32 <code class="descname">vidtv_memset</code><span class="sig-paren">(</span>void<em>&nbsp;*to</em>, size_t<em>&nbsp;to_offset</em>, size_t<em>&nbsp;to_size</em>, const int<em>&nbsp;c</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vidtv_memset" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper routine to be used by MPEG-TS generator, in order to avoid going past the output buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*to</span></code></dt>
<dd>Starting element to set</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">to_offset</span></code></dt>
<dd>Starting position of the <strong>to</strong> buffer to be filled.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">to_size</span></code></dt>
<dd>Size of the <strong>to</strong> buffer.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The value to set the memory to.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>Number of elements to be copy from <strong>from</strong> buffer
into <strong>to**+ **to_offset</strong> buffer.</dd>
</dl>
<p><strong>Note</strong></p>
<blockquote>
<div>Real digital TV demod drivers should not have memset
wrappers. We use it here because emulating MPEG-TS
generation at kernelspace requires some extra care.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Returns the number of bytes written</div></blockquote>
<dl class="type">
<dt id="c.vidtv_tuner_hardware_state">
struct <code class="descname">vidtv_tuner_hardware_state</code><a class="headerlink" href="#c.vidtv_tuner_hardware_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the tuner hardware status</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_tuner_hardware_state {
  bool asleep;
  u32 lock_status;
  u32 if_frequency;
  u32 tuned_frequency;
  u32 bandwidth;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">asleep</span></code></dt>
<dd>whether the tuner is asleep, i.e whether _sleep() or _suspend() was
called.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock_status</span></code></dt>
<dd>Whether the tuner has managed to lock on the requested
frequency.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">if_frequency</span></code></dt>
<dd>The tuner’s intermediate frequency. Hardcoded for the purposes
of simulation.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tuned_frequency</span></code></dt>
<dd>The actual tuned frequency.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bandwidth</span></code></dt>
<dd>The actual bandwidth.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is meant to simulate the status of the tuner hardware, as if
we had a physical tuner hardware.</p>
<dl class="type">
<dt id="c.vidtv_tuner_dev">
struct <code class="descname">vidtv_tuner_dev</code><a class="headerlink" href="#c.vidtv_tuner_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>The tuner struct</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vidtv_tuner_dev {
  struct dvb_frontend *fe;
  struct vidtv_tuner_hardware_state hw_state;
  struct vidtv_tuner_config config;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">fe</span></code></dt>
<dd>A pointer to the dvb_frontend structure allocated by vidtv_demod</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_state</span></code></dt>
<dd>A struct to simulate the tuner’s hardware state as if we had a
physical tuner hardware.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config</span></code></dt>
<dd>The configuration used to start the tuner module, usually filled
by a bridge driver. For vidtv, this is filled by vidtv_bridge before the
tuner module is probed.</dd>
</dl>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="contributors.html" class="btn btn-neutral float-right" title="9.2.4. Contributors" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="frontends.html" class="btn btn-neutral" title="9.2.2. Frontend drivers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'5.18.0-rc1-torvalds+',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>