diff --git a/Documentation/vm/highmem.rst b/Documentation/vm/highmem.rst
index 0f69a9fec34d..2288e0257416 100644
--- a/Documentation/vm/highmem.rst
+++ b/Documentation/vm/highmem.rst
@@ -56,10 +56,24 @@ The kernel contains several ways of creating temporary mappings:
   physical pages into a contiguous virtual space.  It needs global
   synchronization to unmap.
 
-* kmap().  This permits a short duration mapping of a single page.  It needs
-  global synchronization, but is amortized somewhat.  It is also prone to
-  deadlocks when using in a nested fashion, and so it is not recommended for
-  new code.
+* kmap().  This permits long duration mapping of a single page with no
+  restrictions on preemption or migration. This comes with an overhead
+  as mapping space is restricted and protected by global lock for
+  synchronization. When mapping is no more needed, pages must be released
+  with kunmap().
+
+  Mapping changes must be propagated across all the CPUs. kmap() also
+  requires global TLB invalidation when the kmap's pool wraps and it
+  might block when the mapping space is fully utilized until a slot
+  becomes available. Therefore, kmap() is only callable from preemptible
+  context.
+
+  All the above work is necessary if a mapping must last for a relatively
+  long time but the bulk of high-memory mappings in the kernel are
+  short-lived and only used in one place.
+
+  This means that the cost of kmap() is mostly wasted in such cases.
+  Newer code is discouraged from using kmap().
 
 * kmap_atomic().  This permits a very short duration mapping of a single
   page.  Since the mapping is restricted to the CPU that issued it, it
@@ -67,10 +81,40 @@ The kernel contains several ways of creating temporary mappings:
   CPU until it has finished, lest some other task displace its mappings.
 
   kmap_atomic() may also be used by interrupt contexts, since it is does not
-  sleep and the caller may not sleep until after kunmap_atomic() is called.
+  sleep and the caller can not sleep until after kunmap_atomic() is called.
+  Each call of kmap_atomic() in the kernel creates a non-preemptible section
+  and disable page faults. That could be the source of unwanted latency, so
+  only use it if absolutely required, instead use the corresponding kmap_local
+  variant if possible (see below).
 
   It may be assumed that k[un]map_atomic() won't fail.
 
+  On 64-bit systems, calls to kmap() and kmap_atomic() have no real work
+  to do because a 64-bit address space is more than sufficient to address
+  all the physical memory, so all of physical memory appears in the direct
+  map.
+
+* kmap_local_*().  These provide a set of functions similar to kmap_atomic(),
+  they are used to require short term mappings and can be invoked from any
+  context including interrupts.
+
+  The mapping can only be used in the context which acquired the mapping,
+  which is per thread, CPU local (i.e., migration from one CPU to another
+  is disabled - this is why they are called "local"), but they have no need
+  to disable preemption. It's valid to take pagefaults in a kmap_local
+  region unless the context in which the local kmap is acquired does not
+  allow it for other reasons.
+
+  If a task holding local kmaps is preempted, the maps are removed on
+  context switch and restored when the task comes back on the CPU. As
+  the maps are strictly CPU local it is guaranteed that the task stays
+  on the CPU and the CPU cannot be unplugged until the local kmaps are
+  released.
+
+  Nesting kmap_local.*() and kmap_atomic.*() mappings is allowed to a
+  certain extent (up to KMAP_TYPE_NR). Nested kmap_local.*() and
+  kunmap_local.*() invocations have to be strictly ordered because the
+  map implementation is stack based.
 
 Using kmap_atomic
 =================
