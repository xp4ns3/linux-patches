From e18715e1e5541e1861f64a14766ef5d35b171801 Mon Sep 17 00:00:00 2001
From: "Fabio M. De Francesco" <fmdefrancesco@gmail.com>
Date: Mon, 10 May 2021 08:07:36 +0200
Subject: [PATCH] sched: Add the 'sched_no_switch()' event tracer to
 '__schedule()'

Added 'sched_no_switch()' to '__schedule()' to trace cases when
(prev != next) is false

Signed-off-by: Fabio M. De Francesco <fmdefrancesco@gmail.com>
---
 include/trace/events/sched.h | 52 ++++++++++++++++++++++++++++++++++++
 kernel/sched/core.c          |  3 +++
 2 files changed, 55 insertions(+)

diff --git a/include/trace/events/sched.h b/include/trace/events/sched.h
index c96a4337afe6..0bb379f69b1e 100644
--- a/include/trace/events/sched.h
+++ b/include/trace/events/sched.h
@@ -183,6 +183,58 @@ TRACE_EVENT(sched_switch,
 		__entry->next_comm, __entry->next_pid, __entry->next_prio)
 );
 
+
+/*
+ * Tracepoint for no task switches:
+ */
+TRACE_EVENT(sched_no_switch,
+
+        TP_PROTO(bool preempt,
+                 struct task_struct *prev,
+                 struct task_struct *next),
+
+        TP_ARGS(preempt, prev, next),
+
+        TP_STRUCT__entry(
+                __array(        char,   prev_comm,      TASK_COMM_LEN   )
+                __field(        pid_t,  prev_pid                        )
+                __field(        int,    prev_prio                       )
+                __field(        long,   prev_state                      )
+                __array(        char,   next_comm,      TASK_COMM_LEN   )
+                __field(        pid_t,  next_pid                        )
+                __field(        int,    next_prio                       )
+        ),
+
+        TP_fast_assign(
+                memcpy(__entry->next_comm, next->comm, TASK_COMM_LEN);
+                __entry->prev_pid       = prev->pid;
+                __entry->prev_prio      = prev->prio;
+                __entry->prev_state     = __trace_sched_switch_state(preempt, prev);
+                memcpy(__entry->prev_comm, prev->comm, TASK_COMM_LEN);
+                __entry->next_pid       = next->pid;
+                __entry->next_prio      = next->prio;
+                /* XXX SCHED_DEADLINE */
+        ),
+
+        TP_printk("prev_comm=%s prev_pid=%d prev_prio=%d prev_state=%s%s ==> next_comm=%s next_pid=%d next_prio=%d",
+                __entry->prev_comm, __entry->prev_pid, __entry->prev_prio,
+
+                (__entry->prev_state & (TASK_REPORT_MAX - 1)) ?
+                  __print_flags(__entry->prev_state & (TASK_REPORT_MAX - 1), "|",
+                                { TASK_INTERRUPTIBLE, "S" },
+                                { TASK_UNINTERRUPTIBLE, "D" },
+                                { __TASK_STOPPED, "T" },
+                                { __TASK_TRACED, "t" },
+                                { EXIT_DEAD, "X" },
+                                { EXIT_ZOMBIE, "Z" },
+                                { TASK_PARKED, "P" },
+                                { TASK_DEAD, "I" }) :
+                  "R",
+
+                __entry->prev_state & TASK_REPORT_MAX ? "+" : "",
+                __entry->next_comm, __entry->next_pid, __entry->next_prio)
+);
+
 /*
  * Tracepoint for a task being migrated:
  */
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 26235b06103c..12132ce40296 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -5558,6 +5558,9 @@ static void __sched notrace __schedule(bool preempt)
 		rq = context_switch(rq, prev, next, &rf);
 	} else {
 		rq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);
+
+		trace_sched_no_switch(preempt, prev, next);
+
 		rq_unlock_irq(rq, &rf);
 	}
 
-- 
2.31.1

